import{aP as le,Y as N,j as Q,a2 as de,a3 as K,w as ce,o as L,c as R,I as x,aI as C,aE as F,aQ as j,aL as w,aR as ue,aS as V,aT as I,aU as M,aV as fe,aW as ee,aX as z,aY as pe,aZ as U,a_ as te,a$ as ie,b0 as D,aJ as me,b1 as he,b2 as ve,am as ye,b3 as k,Z as $,$ as ge,a0 as we,a1 as Se,az as xe,s as _e,B as be,a5 as Me,a6 as Ce,U as E,a as O,a7 as Ee,a8 as Ae,a9 as Be,C as Te,V as ze,X as Ue}from"./vendor-71388792.js";import{C as Le}from"./vanilla-307d3a93.esm-0ae5fef7.js";const De=async()=>{const e=await le("./plugins/digitalCity/model/shanghai.FBX");let t=null,i=null;return e.traverse(n=>{n.name==="CITY_UNTRIANGULATED"&&(t=n),n.name==="LANDMASS"&&(i=n)}),{model:e,city:t,land:i}},Oe=["object"],Pe=N({__name:"buildingsModelCustomShader",props:{model:{},bulidingsColor:{default:"#e523ff"},landColor:{default:"#112233"},opacity:{default:.9},gradient:{type:Boolean,default:!0}},setup(l){const e=l,t=Q(0),i=e.model.city;i.renderOrder=1001;const n=e.model.land,a=(s,f)=>{let p;s==="cu"||s==="land"&&(p=Array.isArray(n.material)?n.material:[n.material],p.forEach(h=>{h[f].setStyle(e.landColor),h.side=F}))};(()=>{const{geometry:s}=i;s.computeBoundingBox(),s.computeBoundingSphere();const{max:f,min:p}=s.boundingBox;if(i.material.__csm)return;const h=new Le({baseMaterial:i.material,vertexShader:"\n		varying vec4 vPosition;\n		void main() {\n			vPosition = modelMatrix * vec4(position,1.0);\n			csm_Position = position * vec3(1.0);\n		}\n		",fragmentShader:"\n		uniform mat4 modelMatrix;\n		varying vec4 vPosition;\n		uniform vec3 uMax; \n		uniform vec3 uMin; \n		uniform float uOpacity;  \n		uniform float uBorderWidth; \n		uniform vec3 uLightColor;\n		uniform vec3 uColor;\n		uniform float uCircleTime; \n		uniform float uTime; \n		uniform vec3 uTopColor;					//顶部颜色\n		uniform bool uGradient;\n		vec4 uMax_world;\n		vec4 uMin_world;\n		void main() {\n			// 转世界坐标\n			uMax_world =  modelMatrix * vec4(uMax,1.0);\n			uMin_world =  modelMatrix * vec4(uMin,1.0);\n			vec3 distColor = uColor;\n			float residue = uTime - floor(uTime / uCircleTime) * uCircleTime;\n			float rate = residue / uCircleTime;\n			float lightOffset = rate * (uMax_world.y - uMin_world.y);\n\n			if (uMin_world.y + lightOffset < vPosition.y && uMin_world.y + lightOffset + uBorderWidth > vPosition.y) {\n				csm_DiffuseColor = vec4(uLightColor, uOpacity);\n			} else {\n				csm_DiffuseColor = vec4(distColor, uOpacity);\n			}\n\n			//根据高度计算颜色\n			if(uGradient){\n				float rateHight = (vPosition.y - uMin_world.y) / (uMax_world.y - uMin_world.y); \n				vec3 outColor = mix(distColor, uTopColor, rateHight*2.0);\n				csm_DiffuseColor = vec4(outColor, uOpacity);\n			}\n    }\n		",silent:!0,uniforms:{uMax:{value:f},uMin:{value:p},uBorderWidth:{value:5},uCircleTime:{value:5},uColor:{value:new C(e.bulidingsColor)},uOpacity:{value:e.opacity},uLightColor:{value:new C("#ffffff")},uTopColor:{value:new C("#ffff00")},uTime:t,uGradient:{value:e.gradient}},depthWrite:!0,depthTest:!0,transparent:!0,side:F});i.material.dispose(),i.material=h})();const{onLoop:o}=de();o(({delta:s})=>{t.value+=s}),K(()=>{e.bulidingsColor&&i.material.uniforms.uColor.value.setStyle(e.bulidingsColor),e.landColor&&a("land","color"),e.opacity&&(i.material.uniforms.uOpacity.value=e.opacity)}),ce(e,(s,f)=>{i.material.uniforms.uGradient.value=s.gradient});const m=e.model.model.clone();return(s,f)=>(L(),R("primitive",{object:x(m)},null,8,Oe))}}),q=new j,A=new w;class ne extends ue{constructor(){super(),this.isLineSegmentsGeometry=!0,this.type="LineSegmentsGeometry";const e=[-1,2,0,1,2,0,-1,1,0,1,1,0,-1,0,0,1,0,0,-1,-1,0,1,-1,0],t=[-1,2,1,2,-1,1,1,1,-1,-1,1,-1,-1,-2,1,-2],i=[0,2,1,2,3,1,2,4,3,4,5,3,4,6,5,6,7,5];this.setIndex(i),this.setAttribute("position",new V(e,3)),this.setAttribute("uv",new V(t,2))}applyMatrix4(e){const t=this.attributes.instanceStart,i=this.attributes.instanceEnd;return t!==void 0&&(t.applyMatrix4(e),i.applyMatrix4(e),t.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}setPositions(e){let t;e instanceof Float32Array?t=e:Array.isArray(e)&&(t=new Float32Array(e));const i=new I(t,6,1);return this.setAttribute("instanceStart",new M(i,3,0)),this.setAttribute("instanceEnd",new M(i,3,3)),this.computeBoundingBox(),this.computeBoundingSphere(),this}setColors(e){let t;e instanceof Float32Array?t=e:Array.isArray(e)&&(t=new Float32Array(e));const i=new I(t,6,1);return this.setAttribute("instanceColorStart",new M(i,3,0)),this.setAttribute("instanceColorEnd",new M(i,3,3)),this}fromWireframeGeometry(e){return this.setPositions(e.attributes.position.array),this}fromEdgesGeometry(e){return this.setPositions(e.attributes.position.array),this}fromMesh(e){return this.fromWireframeGeometry(new fe(e.geometry)),this}fromLineSegments(e){const t=e.geometry;return this.setPositions(t.attributes.position.array),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new j);const e=this.attributes.instanceStart,t=this.attributes.instanceEnd;e!==void 0&&t!==void 0&&(this.boundingBox.setFromBufferAttribute(e),q.setFromBufferAttribute(t),this.boundingBox.union(q))}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new ee),this.boundingBox===null&&this.computeBoundingBox();const e=this.attributes.instanceStart,t=this.attributes.instanceEnd;if(e!==void 0&&t!==void 0){const i=this.boundingSphere.center;this.boundingBox.getCenter(i);let n=0;for(let a=0,r=e.count;a<r;a++)A.fromBufferAttribute(e,a),n=Math.max(n,i.distanceToSquared(A)),A.fromBufferAttribute(t,a),n=Math.max(n,i.distanceToSquared(A));this.boundingSphere.radius=Math.sqrt(n),isNaN(this.boundingSphere.radius)&&console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",this)}}toJSON(){}applyMatrix(e){return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."),this.applyMatrix4(e)}}z.line={worldUnits:{value:1},linewidth:{value:1},resolution:{value:new pe(1,1)},dashOffset:{value:0},dashScale:{value:1},dashSize:{value:1},gapSize:{value:1}};U.line={uniforms:te.merge([z.common,z.fog,z.line]),vertexShader:"\n		#include <common>\n		#include <color_pars_vertex>\n		#include <fog_pars_vertex>\n		#include <logdepthbuf_pars_vertex>\n		#include <clipping_planes_pars_vertex>\n\n		uniform float linewidth;\n		uniform vec2 resolution;\n\n		attribute vec3 instanceStart;\n		attribute vec3 instanceEnd;\n\n		attribute vec3 instanceColorStart;\n		attribute vec3 instanceColorEnd;\n\n		#ifdef WORLD_UNITS\n\n			varying vec4 worldPos;\n			varying vec3 worldStart;\n			varying vec3 worldEnd;\n\n			#ifdef USE_DASH\n\n				varying vec2 vUv;\n\n			#endif\n\n		#else\n\n			varying vec2 vUv;\n\n		#endif\n\n		#ifdef USE_DASH\n\n			uniform float dashScale;\n			attribute float instanceDistanceStart;\n			attribute float instanceDistanceEnd;\n			varying float vLineDistance;\n\n		#endif\n\n		void trimSegment( const in vec4 start, inout vec4 end ) {\n\n			// trim end segment so it terminates between the camera plane and the near plane\n\n			// conservative estimate of the near plane\n			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n			float nearEstimate = - 0.5 * b / a;\n\n			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n			end.xyz = mix( start.xyz, end.xyz, alpha );\n\n		}\n\n		void main() {\n\n			#ifdef USE_COLOR\n\n				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n			#endif\n\n			#ifdef USE_DASH\n\n				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n				vUv = uv;\n\n			#endif\n\n			float aspect = resolution.x / resolution.y;\n\n			// camera space\n			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n			#ifdef WORLD_UNITS\n\n				worldStart = start.xyz;\n				worldEnd = end.xyz;\n\n			#else\n\n				vUv = uv;\n\n			#endif\n\n			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n			// perhaps there is a more elegant solution -- WestLangley\n\n			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n			if ( perspective ) {\n\n				if ( start.z < 0.0 && end.z >= 0.0 ) {\n\n					trimSegment( start, end );\n\n				} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n					trimSegment( end, start );\n\n				}\n\n			}\n\n			// clip space\n			vec4 clipStart = projectionMatrix * start;\n			vec4 clipEnd = projectionMatrix * end;\n\n			// ndc space\n			vec3 ndcStart = clipStart.xyz / clipStart.w;\n			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n			// direction\n			vec2 dir = ndcEnd.xy - ndcStart.xy;\n\n			// account for clip-space aspect ratio\n			dir.x *= aspect;\n			dir = normalize( dir );\n\n			#ifdef WORLD_UNITS\n\n				// get the offset direction as perpendicular to the view vector\n				vec3 worldDir = normalize( end.xyz - start.xyz );\n				vec3 offset;\n				if ( position.y < 0.5 ) {\n\n					offset = normalize( cross( start.xyz, worldDir ) );\n\n				} else {\n\n					offset = normalize( cross( end.xyz, worldDir ) );\n\n				}\n\n				// sign flip\n				if ( position.x < 0.0 ) offset *= - 1.0;\n\n				float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );\n\n				// don't extend the line if we're rendering dashes because we\n				// won't be rendering the endcaps\n				#ifndef USE_DASH\n\n					// extend the line bounds to encompass  endcaps\n					start.xyz += - worldDir * linewidth * 0.5;\n					end.xyz += worldDir * linewidth * 0.5;\n\n					// shift the position of the quad so it hugs the forward edge of the line\n					offset.xy -= dir * forwardOffset;\n					offset.z += 0.5;\n\n				#endif\n\n				// endcaps\n				if ( position.y > 1.0 || position.y < 0.0 ) {\n\n					offset.xy += dir * 2.0 * forwardOffset;\n\n				}\n\n				// adjust for linewidth\n				offset *= linewidth * 0.5;\n\n				// set the world position\n				worldPos = ( position.y < 0.5 ) ? start : end;\n				worldPos.xyz += offset;\n\n				// project the worldpos\n				vec4 clip = projectionMatrix * worldPos;\n\n				// shift the depth of the projected points so the line\n				// segments overlap neatly\n				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n				clip.z = clipPose.z * clip.w;\n\n			#else\n\n				vec2 offset = vec2( dir.y, - dir.x );\n				// undo aspect ratio adjustment\n				dir.x /= aspect;\n				offset.x /= aspect;\n\n				// sign flip\n				if ( position.x < 0.0 ) offset *= - 1.0;\n\n				// endcaps\n				if ( position.y < 0.0 ) {\n\n					offset += - dir;\n\n				} else if ( position.y > 1.0 ) {\n\n					offset += dir;\n\n				}\n\n				// adjust for linewidth\n				offset *= linewidth;\n\n				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n				offset /= resolution.y;\n\n				// select end\n				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n				// back to clip space\n				offset *= clip.w;\n\n				clip.xy += offset;\n\n			#endif\n\n			gl_Position = clip;\n\n			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n			#include <logdepthbuf_vertex>\n			#include <clipping_planes_vertex>\n			#include <fog_vertex>\n\n		}\n		",fragmentShader:"\n		uniform vec3 diffuse;\n		uniform float opacity;\n		uniform float linewidth;\n\n		#ifdef USE_DASH\n\n			uniform float dashOffset;\n			uniform float dashSize;\n			uniform float gapSize;\n\n		#endif\n\n		varying float vLineDistance;\n\n		#ifdef WORLD_UNITS\n\n			varying vec4 worldPos;\n			varying vec3 worldStart;\n			varying vec3 worldEnd;\n\n			#ifdef USE_DASH\n\n				varying vec2 vUv;\n\n			#endif\n\n		#else\n\n			varying vec2 vUv;\n\n		#endif\n\n		#include <common>\n		#include <color_pars_fragment>\n		#include <fog_pars_fragment>\n		#include <logdepthbuf_pars_fragment>\n		#include <clipping_planes_pars_fragment>\n\n		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n			float mua;\n			float mub;\n\n			vec3 p13 = p1 - p3;\n			vec3 p43 = p4 - p3;\n\n			vec3 p21 = p2 - p1;\n\n			float d1343 = dot( p13, p43 );\n			float d4321 = dot( p43, p21 );\n			float d1321 = dot( p13, p21 );\n			float d4343 = dot( p43, p43 );\n			float d2121 = dot( p21, p21 );\n\n			float denom = d2121 * d4343 - d4321 * d4321;\n\n			float numer = d1343 * d4321 - d1321 * d4343;\n\n			mua = numer / denom;\n			mua = clamp( mua, 0.0, 1.0 );\n			mub = ( d1343 + d4321 * ( mua ) ) / d4343;\n			mub = clamp( mub, 0.0, 1.0 );\n\n			return vec2( mua, mub );\n\n		}\n\n		void main() {\n\n			#include <clipping_planes_fragment>\n\n			#ifdef USE_DASH\n\n				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n			#endif\n\n			float alpha = opacity;\n\n			#ifdef WORLD_UNITS\n\n				// Find the closest points on the view ray and the line segment\n				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n				vec3 lineDir = worldEnd - worldStart;\n				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n				vec3 p1 = worldStart + lineDir * params.x;\n				vec3 p2 = rayEnd * params.y;\n				vec3 delta = p1 - p2;\n				float len = length( delta );\n				float norm = len / linewidth;\n\n				#ifndef USE_DASH\n\n					#ifdef USE_ALPHA_TO_COVERAGE\n\n						float dnorm = fwidth( norm );\n						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n					#else\n\n						if ( norm > 0.5 ) {\n\n							discard;\n\n						}\n\n					#endif\n\n				#endif\n\n			#else\n\n				#ifdef USE_ALPHA_TO_COVERAGE\n\n					// artifacts appear on some hardware if a derivative is taken within a conditional\n					float a = vUv.x;\n					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n					float len2 = a * a + b * b;\n					float dlen = fwidth( len2 );\n\n					if ( abs( vUv.y ) > 1.0 ) {\n\n						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n					}\n\n				#else\n\n					if ( abs( vUv.y ) > 1.0 ) {\n\n						float a = vUv.x;\n						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n						float len2 = a * a + b * b;\n\n						if ( len2 > 1.0 ) discard;\n\n					}\n\n				#endif\n\n			#endif\n\n			vec4 diffuseColor = vec4( diffuse, alpha );\n\n			#include <logdepthbuf_fragment>\n			#include <color_fragment>\n\n			gl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n			#include <tonemapping_fragment>\n			#include <colorspace_fragment>\n			#include <fog_fragment>\n			#include <premultiplied_alpha_fragment>\n\n		}\n		"};class oe extends ie{constructor(e){super({type:"LineMaterial",uniforms:te.clone(U.line.uniforms),vertexShader:U.line.vertexShader,fragmentShader:U.line.fragmentShader,clipping:!0}),this.isLineMaterial=!0,this.setValues(e)}get color(){return this.uniforms.diffuse.value}set color(e){this.uniforms.diffuse.value=e}get worldUnits(){return"WORLD_UNITS"in this.defines}set worldUnits(e){e===!0?this.defines.WORLD_UNITS="":delete this.defines.WORLD_UNITS}get linewidth(){return this.uniforms.linewidth.value}set linewidth(e){this.uniforms.linewidth&&(this.uniforms.linewidth.value=e)}get dashed(){return"USE_DASH"in this.defines}set dashed(e){e===!0!==this.dashed&&(this.needsUpdate=!0),e===!0?this.defines.USE_DASH="":delete this.defines.USE_DASH}get dashScale(){return this.uniforms.dashScale.value}set dashScale(e){this.uniforms.dashScale.value=e}get dashSize(){return this.uniforms.dashSize.value}set dashSize(e){this.uniforms.dashSize.value=e}get dashOffset(){return this.uniforms.dashOffset.value}set dashOffset(e){this.uniforms.dashOffset.value=e}get gapSize(){return this.uniforms.gapSize.value}set gapSize(e){this.uniforms.gapSize.value=e}get opacity(){return this.uniforms.opacity.value}set opacity(e){this.uniforms&&(this.uniforms.opacity.value=e)}get resolution(){return this.uniforms.resolution.value}set resolution(e){this.uniforms.resolution.value.copy(e)}get alphaToCoverage(){return"USE_ALPHA_TO_COVERAGE"in this.defines}set alphaToCoverage(e){this.defines&&(e===!0!==this.alphaToCoverage&&(this.needsUpdate=!0),e===!0?(this.defines.USE_ALPHA_TO_COVERAGE="",this.extensions.derivatives=!0):(delete this.defines.USE_ALPHA_TO_COVERAGE,this.extensions.derivatives=!1))}}const X=new w,Y=new w,d=new D,c=new D,v=new D,P=new w,W=new me,u=new he,J=new w,B=new j,T=new ee,y=new D;let g,_;function Z(l,e,t){return y.set(0,0,-e,1).applyMatrix4(l.projectionMatrix),y.multiplyScalar(1/y.w),y.x=_/t.width,y.y=_/t.height,y.applyMatrix4(l.projectionMatrixInverse),y.multiplyScalar(1/y.w),Math.abs(Math.max(y.x,y.y))}function We(l,e){const t=l.matrixWorld,i=l.geometry,n=i.attributes.instanceStart,a=i.attributes.instanceEnd,r=Math.min(i.instanceCount,n.count);for(let o=0,m=r;o<m;o++){u.start.fromBufferAttribute(n,o),u.end.fromBufferAttribute(a,o),u.applyMatrix4(t);const s=new w,f=new w;g.distanceSqToSegment(u.start,u.end,f,s),f.distanceTo(s)<_*.5&&e.push({point:f,pointOnLine:s,distance:g.origin.distanceTo(f),object:l,face:null,faceIndex:o,uv:null,uv1:null})}}function Ie(l,e,t){const i=e.projectionMatrix,a=l.material.resolution,r=l.matrixWorld,o=l.geometry,m=o.attributes.instanceStart,s=o.attributes.instanceEnd,f=Math.min(o.instanceCount,m.count),p=-e.near;g.at(1,v),v.w=1,v.applyMatrix4(e.matrixWorldInverse),v.applyMatrix4(i),v.multiplyScalar(1/v.w),v.x*=a.x/2,v.y*=a.y/2,v.z=0,P.copy(v),W.multiplyMatrices(e.matrixWorldInverse,r);for(let h=0,ae=f;h<ae;h++){if(d.fromBufferAttribute(m,h),c.fromBufferAttribute(s,h),d.w=1,c.w=1,d.applyMatrix4(W),c.applyMatrix4(W),d.z>p&&c.z>p)continue;if(d.z>p){const b=d.z-c.z,S=(d.z-p)/b;d.lerp(c,S)}else if(c.z>p){const b=c.z-d.z,S=(c.z-p)/b;c.lerp(d,S)}d.applyMatrix4(i),c.applyMatrix4(i),d.multiplyScalar(1/d.w),c.multiplyScalar(1/c.w),d.x*=a.x/2,d.y*=a.y/2,c.x*=a.x/2,c.y*=a.y/2,u.start.copy(d),u.start.z=0,u.end.copy(c),u.end.z=0;const G=u.closestPointToPointParameter(P,!0);u.at(G,J);const H=ye.lerp(d.z,c.z,G),re=H>=-1&&H<=1,se=P.distanceTo(J)<_*.5;if(re&&se){u.start.fromBufferAttribute(m,h),u.end.fromBufferAttribute(s,h),u.start.applyMatrix4(r),u.end.applyMatrix4(r);const b=new w,S=new w;g.distanceSqToSegment(u.start,u.end,S,b),t.push({point:S,pointOnLine:b,distance:g.origin.distanceTo(S),object:l,face:null,faceIndex:h,uv:null,uv1:null})}}}class Ne extends ve{constructor(e=new ne,t=new oe({color:Math.random()*16777215})){super(e,t),this.isLineSegments2=!0,this.type="LineSegments2"}computeLineDistances(){const e=this.geometry,t=e.attributes.instanceStart,i=e.attributes.instanceEnd,n=new Float32Array(2*t.count);for(let r=0,o=0,m=t.count;r<m;r++,o+=2)X.fromBufferAttribute(t,r),Y.fromBufferAttribute(i,r),n[o]=o===0?0:n[o-1],n[o+1]=n[o]+X.distanceTo(Y);const a=new I(n,2,1);return e.setAttribute("instanceDistanceStart",new M(a,1,0)),e.setAttribute("instanceDistanceEnd",new M(a,1,1)),this}raycast(e,t){const i=this.material.worldUnits,n=e.camera;n===null&&!i&&console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');const a=e.params.Line2!==void 0&&e.params.Line2.threshold||0;g=e.ray;const r=this.matrixWorld,o=this.geometry,m=this.material;_=m.linewidth+a,o.boundingSphere===null&&o.computeBoundingSphere(),T.copy(o.boundingSphere).applyMatrix4(r);let s;if(i)s=_*.5;else{const p=Math.max(n.near,T.distanceToPoint(g.origin));s=Z(n,p,m.resolution)}if(T.radius+=s,g.intersectsSphere(T)===!1)return;o.boundingBox===null&&o.computeBoundingBox(),B.copy(o.boundingBox).applyMatrix4(r);let f;if(i)f=_*.5;else{const p=Math.max(n.near,B.distanceToPoint(g.origin));f=Z(n,p,m.resolution)}B.expandByScalar(f),g.intersectsBox(B)!==!1&&(i?We(this,t):Ie(this,n,t))}}const Re=["object"],je=N({__name:"buildingsLines",props:{builds:{},width:{default:1},color:{default:"#FFF"},opacity:{default:1},style:{default:"Wireframe"}},setup(l){const e=l;let t=null,i=null;if(e.style==="Wireframe"){const n=new k(e.builds.geometry);let r=new ne().fromEdgesGeometry(n),o=new oe({color:e.color,linewidth:e.width,opacity:e.opacity,transparent:!0,depthWrite:!0,depthTest:!0});o.resolution.set(window.innerWidth,window.innerHeight),t=new Ne(r,o),t.applyMatrix4(e.builds.matrix.clone())}else{i={transparent:!0,uniforms:{uColor:{value:new C(e.color)},uOpacity:{value:e.opacity}},vertexShader:"\n       void main() {\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }\n      ",fragmentShader:" \n        uniform vec3 uColor;\n				uniform float uOpacity;\n        void main() {\n          gl_FragColor = vec4(uColor, uOpacity);\n        }\n      "};const n=new k(e.builds.geometry),a=new ie(i);t=new LineSegments(n,a),t.applyMatrix4(e.builds.matrix.clone()),t.material.linewidth=e.width,t.renderOrder=1e3}return K(()=>{e.style==="Shader"&&(e.color&&(i.uniforms.uColor.value=new C(e.color)),e.opacity&&(i.uniforms.uOpacity.value=e.opacity)),e.style==="Wireframe"&&(e.color&&(t.material.color=new C(e.color)),e.opacity&&(t.material.opacity=e.opacity)),e.width&&(t.material.linewidth=e.width)}),(n,a)=>(L(),R("primitive",{object:x(t)},null,8,Re))}}),Ge=E("TresAmbientLight",{color:"#ffffff"},null,-1),He=E("TresDirectionalLight",{position:[100,100,0],intensity:.5,color:"#ffffff"},null,-1),Fe=E("TresAxesHelper",{args:[1e3],position:[0,19,0]},null,-1),Ve=E("TresGridHelper",{args:[6e3,100],position:[0,19,0]},null,-1),Xe=N({__name:"pagesShow",props:{showBuildings:{type:Boolean,default:!0},autoRotate:{type:Boolean,default:!0}},async setup(l){let e,t;const i=l,n=$({clearColor:"#000000",shadows:!0,alpha:!1,useLegacyLights:!0,shadowMapType:ge,outputColorSpace:we,toneMapping:Se}),a=$({autoRotate:i.autoRotate,enableDamping:!0});let r=null;i.showBuildings&&(r=([e,t]=xe(()=>De()),e=await e,t(),e));const o=Q();return(m,s)=>(L(),_e(x(Ce),Me(n,{"window-size":""}),{default:be(()=>[E("TresPerspectiveCamera",{ref_key:"perspectiveCameraRef",ref:o,position:[600,750,-1221],fov:45,near:1,far:1e4},null,512),O(x(Be),Ee(Ae(a)),null,16),Ge,He,i.showBuildings&&x(r)?(L(),R(Te,{key:0},[O(Pe,{model:x(r)},null,8,["model"]),O(je,{builds:x(r).city,color:"#000"},null,8,["builds"])],64)):ze("",!0),Ue(m.$slots,"ability"),Fe,Ve]),_:3},16))}});export{Xe as _,Pe as a,je as b,De as l};
