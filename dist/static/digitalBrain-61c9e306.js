import{V as G,C as R,Q as oe,R as re,X as Q,x as F,F as j,Y as S,d as k,G as M,M as ie,Z as N,J as T,o as C,b as ne,D as ae,A as le,B as ce,S as ue,N as fe}from"./three.module-cbea6429.js";import{y as me,h as de,a as he,P as pe,l as ge,x as ye}from"./trescientos-a922f233.js";import{Y as H,ae as Z,o as A,c as K,I as V,j as be,ak as ee,U as B,ab as te,ac as se,a9 as E,s as L,B as D,aa as I,a as ve,V as J,al as xe}from"./vendor-19b019cc.js";const we=/^[og]\s*(.+)?/,_e=/^mtllib /,je=/^usemtl /,Ae=/^usemap /,Y=/\s+/,$=new G,P=new G,X=new G,q=new G,x=new G,U=new R;function Te(){const d={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(s,t){if(this.object&&this.object.fromDeclaration===!1){this.object.name=s,this.object.fromDeclaration=t!==!1;return}const o=this.object&&typeof this.object.currentMaterial=="function"?this.object.currentMaterial():void 0;if(this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0),this.object={name:s||"",fromDeclaration:t!==!1,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(e,r){const c=this._finalize(!1);c&&(c.inherited||c.groupCount<=0)&&this.materials.splice(c.index,1);const f={index:this.materials.length,name:e||"",mtllib:Array.isArray(r)&&r.length>0?r[r.length-1]:"",smooth:c!==void 0?c.smooth:this.smooth,groupStart:c!==void 0?c.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(m){const l={index:typeof m=="number"?m:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return l.clone=this.clone.bind(l),l}};return this.materials.push(f),f},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(e){const r=this.currentMaterial();if(r&&r.groupEnd===-1&&(r.groupEnd=this.geometry.vertices.length/3,r.groupCount=r.groupEnd-r.groupStart,r.inherited=!1),e&&this.materials.length>1)for(let c=this.materials.length-1;c>=0;c--)this.materials[c].groupCount<=0&&this.materials.splice(c,1);return e&&this.materials.length===0&&this.materials.push({name:"",smooth:this.smooth}),r}},o&&o.name&&typeof o.clone=="function"){const e=o.clone(0);e.inherited=!0,this.object.materials.push(e)}this.objects.push(this.object)},finalize:function(){this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0)},parseVertexIndex:function(s,t){const o=parseInt(s,10);return(o>=0?o-1:o+t/3)*3},parseNormalIndex:function(s,t){const o=parseInt(s,10);return(o>=0?o-1:o+t/3)*3},parseUVIndex:function(s,t){const o=parseInt(s,10);return(o>=0?o-1:o+t/2)*2},addVertex:function(s,t,o){const e=this.vertices,r=this.object.geometry.vertices;r.push(e[s+0],e[s+1],e[s+2]),r.push(e[t+0],e[t+1],e[t+2]),r.push(e[o+0],e[o+1],e[o+2])},addVertexPoint:function(s){const t=this.vertices;this.object.geometry.vertices.push(t[s+0],t[s+1],t[s+2])},addVertexLine:function(s){const t=this.vertices;this.object.geometry.vertices.push(t[s+0],t[s+1],t[s+2])},addNormal:function(s,t,o){const e=this.normals,r=this.object.geometry.normals;r.push(e[s+0],e[s+1],e[s+2]),r.push(e[t+0],e[t+1],e[t+2]),r.push(e[o+0],e[o+1],e[o+2])},addFaceNormal:function(s,t,o){const e=this.vertices,r=this.object.geometry.normals;$.fromArray(e,s),P.fromArray(e,t),X.fromArray(e,o),x.subVectors(X,P),q.subVectors($,P),x.cross(q),x.normalize(),r.push(x.x,x.y,x.z),r.push(x.x,x.y,x.z),r.push(x.x,x.y,x.z)},addColor:function(s,t,o){const e=this.colors,r=this.object.geometry.colors;e[s]!==void 0&&r.push(e[s+0],e[s+1],e[s+2]),e[t]!==void 0&&r.push(e[t+0],e[t+1],e[t+2]),e[o]!==void 0&&r.push(e[o+0],e[o+1],e[o+2])},addUV:function(s,t,o){const e=this.uvs,r=this.object.geometry.uvs;r.push(e[s+0],e[s+1]),r.push(e[t+0],e[t+1]),r.push(e[o+0],e[o+1])},addDefaultUV:function(){const s=this.object.geometry.uvs;s.push(0,0),s.push(0,0),s.push(0,0)},addUVLine:function(s){const t=this.uvs;this.object.geometry.uvs.push(t[s+0],t[s+1])},addFace:function(s,t,o,e,r,c,f,m,l){const i=this.vertices.length;let n=this.parseVertexIndex(s,i),u=this.parseVertexIndex(t,i),a=this.parseVertexIndex(o,i);if(this.addVertex(n,u,a),this.addColor(n,u,a),f!==void 0&&f!==""){const h=this.normals.length;n=this.parseNormalIndex(f,h),u=this.parseNormalIndex(m,h),a=this.parseNormalIndex(l,h),this.addNormal(n,u,a)}else this.addFaceNormal(n,u,a);if(e!==void 0&&e!==""){const h=this.uvs.length;n=this.parseUVIndex(e,h),u=this.parseUVIndex(r,h),a=this.parseUVIndex(c,h),this.addUV(n,u,a),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(s){this.object.geometry.type="Points";const t=this.vertices.length;for(let o=0,e=s.length;o<e;o++){const r=this.parseVertexIndex(s[o],t);this.addVertexPoint(r),this.addColor(r)}},addLineGeometry:function(s,t){this.object.geometry.type="Line";const o=this.vertices.length,e=this.uvs.length;for(let r=0,c=s.length;r<c;r++)this.addVertexLine(this.parseVertexIndex(s[r],o));for(let r=0,c=t.length;r<c;r++)this.addUVLine(this.parseUVIndex(t[r],e))}};return d.startObject("",!1),d}class Be extends oe{constructor(s){super(s),this.materials=null}load(s,t,o,e){const r=this,c=new re(this.manager);c.setPath(this.path),c.setRequestHeader(this.requestHeader),c.setWithCredentials(this.withCredentials),c.load(s,function(f){try{t(r.parse(f))}catch(m){e?e(m):console.error(m),r.manager.itemError(s)}},o,e)}setMaterials(s){return this.materials=s,this}parse(s){const t=new Te;s.indexOf("\r\n")!==-1&&(s=s.replace(/\r\n/g,"\n")),s.indexOf("\\\n")!==-1&&(s=s.replace(/\\\n/g,""));const o=s.split("\n");let e=[];for(let f=0,m=o.length;f<m;f++){const l=o[f].trimStart();if(l.length===0)continue;const i=l.charAt(0);if(i!=="#")if(i==="v"){const n=l.split(Y);switch(n[0]){case"v":t.vertices.push(parseFloat(n[1]),parseFloat(n[2]),parseFloat(n[3])),n.length>=7?(U.setRGB(parseFloat(n[4]),parseFloat(n[5]),parseFloat(n[6])).convertSRGBToLinear(),t.colors.push(U.r,U.g,U.b)):t.colors.push(void 0,void 0,void 0);break;case"vn":t.normals.push(parseFloat(n[1]),parseFloat(n[2]),parseFloat(n[3]));break;case"vt":t.uvs.push(parseFloat(n[1]),parseFloat(n[2]));break}}else if(i==="f"){const u=l.slice(1).trim().split(Y),a=[];for(let p=0,y=u.length;p<y;p++){const b=u[p];if(b.length>0){const v=b.split("/");a.push(v)}}const h=a[0];for(let p=1,y=a.length-1;p<y;p++){const b=a[p],v=a[p+1];t.addFace(h[0],b[0],v[0],h[1],b[1],v[1],h[2],b[2],v[2])}}else if(i==="l"){const n=l.substring(1).trim().split(" ");let u=[];const a=[];if(l.indexOf("/")===-1)u=n;else for(let h=0,p=n.length;h<p;h++){const y=n[h].split("/");y[0]!==""&&u.push(y[0]),y[1]!==""&&a.push(y[1])}t.addLineGeometry(u,a)}else if(i==="p"){const u=l.slice(1).trim().split(" ");t.addPointGeometry(u)}else if((e=we.exec(l))!==null){const n=(" "+e[0].slice(1).trim()).slice(1);t.startObject(n)}else if(je.test(l))t.object.startMaterial(l.substring(7).trim(),t.materialLibraries);else if(_e.test(l))t.materialLibraries.push(l.substring(7).trim());else if(Ae.test(l))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if(i==="s"){if(e=l.split(" "),e.length>1){const u=e[1].trim().toLowerCase();t.object.smooth=u!=="0"&&u!=="off"}else t.object.smooth=!0;const n=t.object.currentMaterial();n&&(n.smooth=t.object.smooth)}else{if(l==="\0")continue;console.warn('THREE.OBJLoader: Unexpected line: "'+l+'"')}}t.finalize();const r=new Q;if(r.materialLibraries=[].concat(t.materialLibraries),!(t.objects.length===1&&t.objects[0].geometry.vertices.length===0)===!0)for(let f=0,m=t.objects.length;f<m;f++){const l=t.objects[f],i=l.geometry,n=l.materials,u=i.type==="Line",a=i.type==="Points";let h=!1;if(i.vertices.length===0)continue;const p=new F;p.setAttribute("position",new j(i.vertices,3)),i.normals.length>0&&p.setAttribute("normal",new j(i.normals,3)),i.colors.length>0&&(h=!0,p.setAttribute("color",new j(i.colors,3))),i.hasUVIndices===!0&&p.setAttribute("uv",new j(i.uvs,2));const y=[];for(let v=0,z=n.length;v<z;v++){const w=n[v],O=w.name+"_"+w.smooth+"_"+h;let g=t.materials[O];if(this.materials!==null){if(g=this.materials.create(w.name),u&&g&&!(g instanceof S)){const _=new S;k.prototype.copy.call(_,g),_.color.copy(g.color),g=_}else if(a&&g&&!(g instanceof M)){const _=new M({size:10,sizeAttenuation:!1});k.prototype.copy.call(_,g),_.color.copy(g.color),_.map=g.map,g=_}}g===void 0&&(u?g=new S:a?g=new M({size:1,sizeAttenuation:!1}):g=new ie,g.name=w.name,g.flatShading=!w.smooth,g.vertexColors=h,t.materials[O]=g),y.push(g)}let b;if(y.length>1){for(let v=0,z=n.length;v<z;v++){const w=n[v];p.addGroup(w.groupStart,w.groupCount,v)}u?b=new N(p,y):a?b=new T(p,y):b=new C(p,y)}else u?b=new N(p,y[0]):a?b=new T(p,y[0]):b=new C(p,y[0]);b.name=l.name,r.add(b)}else if(t.vertices.length>0){const f=new M({size:1,sizeAttenuation:!1}),m=new F;m.setAttribute("position",new j(t.vertices,3)),t.colors.length>0&&t.colors[0]!==void 0&&(m.setAttribute("color",new j(t.colors,3)),f.vertexColors=!0);const l=new T(m,f);r.add(l)}return r}}const Me=(d,s)=>new Promise((t,o)=>{s.setCrossOrigin("Anonymous"),s.load(d,e=>{t(e)},e=>{console.log("".concat(e.loaded/e.total*100,"% loaded"))},e=>{console.error(e),o(e)})}),Ve=["object"],Ge=H({__name:"cloudPoints",props:{model:{},color:{default:"#FFF"},opacity:{default:1}},setup(d){const s=d,t=new Q;return s.model.traverse(o=>{if(o instanceof C){const e=o.geometry.clone();o.geometry.dispose(),o.material.dispose();const r=new M({color:s.color});r.opacity=s.opacity,r.transparent=!0;const c=new T(e,r);t.add(c)}}),Z(()=>{s.color&&t.traverse(o=>{o instanceof T&&(o.material.color=new R(s.color))}),s.opacity&&t.traverse(o=>{o instanceof T&&(o.material.opacity=s.opacity)})}),(o,e)=>(A(),K("primitive",{object:V(t)},null,8,Ve))}});function Ee(d,s=!1){const t=d[0].index!==null,o=new Set(Object.keys(d[0].attributes)),e=new Set(Object.keys(d[0].morphAttributes)),r={},c={},f=d[0].morphTargetsRelative,m=new F;let l=0;for(let i=0;i<d.length;++i){const n=d[i];let u=0;if(t!==(n.index!==null))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+i+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const a in n.attributes){if(!o.has(a))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+i+'. All geometries must have compatible attributes; make sure "'+a+'" attribute exists among all geometries, or in none of them.'),null;r[a]===void 0&&(r[a]=[]),r[a].push(n.attributes[a]),u++}if(u!==o.size)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+i+". Make sure all geometries have the same number of attributes."),null;if(f!==n.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+i+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const a in n.morphAttributes){if(!e.has(a))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+i+".  .morphAttributes must be consistent throughout all geometries."),null;c[a]===void 0&&(c[a]=[]),c[a].push(n.morphAttributes[a])}if(s){let a;if(t)a=n.index.count;else if(n.attributes.position!==void 0)a=n.attributes.position.count;else return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+i+". The geometry must have either an index or a position attribute"),null;m.addGroup(l,a,i),l+=a}}if(t){let i=0;const n=[];for(let u=0;u<d.length;++u){const a=d[u].index;for(let h=0;h<a.count;++h)n.push(a.getX(h)+i);i+=d[u].attributes.position.count}m.setIndex(n)}for(const i in r){const n=W(r[i]);if(!n)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+i+" attribute."),null;m.setAttribute(i,n)}for(const i in c){const n=c[i][0].length;if(n===0)break;m.morphAttributes=m.morphAttributes||{},m.morphAttributes[i]=[];for(let u=0;u<n;++u){const a=[];for(let p=0;p<c[i].length;++p)a.push(c[i][p][u]);const h=W(a);if(!h)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+i+" morphAttribute."),null;m.morphAttributes[i].push(h)}}return m}function W(d){let s,t,o,e=-1,r=0;for(let l=0;l<d.length;++l){const i=d[l];if(i.isInterleavedBufferAttribute)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. InterleavedBufferAttributes are not supported."),null;if(s===void 0&&(s=i.array.constructor),s!==i.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(t===void 0&&(t=i.itemSize),t!==i.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(o===void 0&&(o=i.normalized),o!==i.normalized)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;if(e===-1&&(e=i.gpuType),e!==i.gpuType)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."),null;r+=i.array.length}const c=new s(r);let f=0;for(let l=0;l<d.length;++l)c.set(d[l].array,f),f+=d[l].array.length;const m=new ne(c,t,o);return e!==void 0&&(m.gpuType=e),m}const Le=B("TresBufferGeometry",null,null,-1),Ue="\nuniform float c;\nuniform float p;\nuniform float uTime;\nvarying float intensity;\nvarying  vec2 vUv;\nvoid main(){\n    vUv = uv;\n    vec3 vNormal = normalize( normalMatrix * normal );\n    intensity = pow(c - abs(dot(vNormal, vec3(0, 0, 1))), p);\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n }\n",Re="\nuniform vec3 glowColor;\nuniform sampler2D lightningTexture;\nvarying float intensity;\nvarying vec2 vUv;\nuniform float offsetY;\nuniform float uTime;\nuniform float uOpacity;\n\nvoid main(){\n  vec2 uv=vUv;\n  uv.y+=offsetY;\n  vec3 glow=glowColor*intensity;\n  vec3 color=vec3(step(.1,uv.y)-step(.2,uv.y))-vec3(texture2D(lightningTexture,uv));\n  float alpha=clamp(cos(uTime*3.),.5,1.);\n  gl_FragColor=vec4(glow+color,alpha*uOpacity);\n}\n",Ce=H({__name:"xRayEffect",props:{model:{},color:{default:"#84ccff"},opacity:{default:1}},async setup(d){let s,t;const o=d,e=be(),r=[];o.model.traverse(i=>{i instanceof C&&(i.geometry.verticesNeedUpdate=!0,r.push(i.geometry))});const c=([s,t]=ee(()=>me({map:"./plugins/medical/image/brainXRayLight.png"})),s=await s,t(),s),f={uniforms:{c:{type:"f",value:1.11},p:{type:"f",value:1},glowColor:{type:"c",value:new R(o.color)},lightningTexture:{type:"t",value:c.map},offsetY:{type:"f",value:.1},uTime:{type:"f",value:0},uOpacity:{type:"f",value:o.opacity}},vertexShader:Ue,fragmentShader:Re,side:ae,blending:le,depthWrite:!1};f.uniforms.offsetY.value=Math.sin(5);const{camera:m}=de(),{onLoop:l}=he();return l(({delta:i})=>{m.value.position&&e.value&&(f.uniforms.uTime.value+=i)}),Z(()=>{e.value&&(e.value.geometry.dispose(),e.value.geometry=Ee(r)),o.color&&(f.uniforms.glowColor.value=new R(o.color)),o.opacity&&(f.uniforms.uOpacity.value=o.opacity)}),(i,n)=>(A(),K("TresMesh",{ref_key:"TresMeshRef",ref:e},[Le,B("TresShaderMaterial",te(se(f)),null,16)],512))}}),ze=B("TresPerspectiveCamera",{position:[100,400,500],fov:45,near:.1,far:1e4,"look-at":[0,0,0]},null,-1),Se=B("TresAmbientLight",{intensity:.5},null,-1),Ie=B("TresGridHelper",{args:[400,10]},null,-1),Pe={position:[0,120,0]},Fe="./plugins/medical/model/brainparts.OBJ",Ne=H({__name:"digitalBrain",async setup(d){let s,t;const o=E({color:"#fff",show:!0,opacity:1}),e=new pe({title:"参数"});e.addBinding(o,"show",{label:"点云显示"}),e.addBinding(o,"color",{label:"点云颜色"}),e.addBinding(o,"opacity",{label:"点云透明度",min:0,max:1,step:.1});const r=E({color:"#84ccff",show:!0,opacity:1});e.addBinding(r,"show",{label:"脑组织显示"}),e.addBinding(r,"color",{label:"脑组织颜色"}),e.addBinding(r,"opacity",{label:"脑组织透明度",min:0,max:1,step:.1});const c=new Be,f=([s,t]=ee(()=>Me(Fe,c)),s=await s,t(),s),m=E({clearColor:"#000",shadows:!0,alpha:!1,shadowMapType:ce,outputColorSpace:ue,toneMapping:fe}),l=E({autoRotate:!0,autoRotateSpeed:2});return(i,n)=>(A(),L(V(ge),I(m,{"window-size":""}),{default:D(()=>[ze,ve(V(ye),te(se(l)),null,16),Se,Ie,B("TresGroup",Pe,[o.show?(A(),L(Ge,I({key:0,model:V(f)},o),null,16,["model"])):J("",!0),(A(),L(xe,null,{default:D(()=>[r.show?(A(),L(Ce,I({key:0,model:V(f)},r),null,16,["model"])):J("",!0)]),_:1}))])]),_:1},16))}});export{Ne as default};
