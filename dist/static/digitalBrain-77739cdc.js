import{aG as I,aL as V,bI as le,bJ as ce,bK as oe,aI as q,aZ as x,bF as O,bH as W,bp as L,ak as ue,bG as Z,bq as B,b8 as U,Y as D,a3 as H,o as j,c as $,I as C,j as k,az as ne,aP as fe,aE as se,ah as ie,aM as pe,a2 as ae,U as z,a7 as J,a8 as Y,b6 as me,am as A,Z as T,ae as de,$ as he,a0 as ge,a1 as be,s as F,B as K,a5 as G,a6 as ve,a as ye,a9 as _e,V as E,aC as we}from"./vendor-b8789ef6.js";import{m as re}from"./BufferGeometryUtils-41617806.js";const xe=/^[og]\s*(.+)?/,Pe=/^mtllib /,je=/^usemtl /,ze=/^usemap /,X=/\s+/,Q=new I,N=new I,ee=new I,te=new I,w=new I,R=new V;function Me(){const y={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(o,t){if(this.object&&this.object.fromDeclaration===!1){this.object.name=o,this.object.fromDeclaration=t!==!1;return}const n=this.object&&typeof this.object.currentMaterial=="function"?this.object.currentMaterial():void 0;if(this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0),this.object={name:o||"",fromDeclaration:t!==!1,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(e,s){const l=this._finalize(!1);l&&(l.inherited||l.groupCount<=0)&&this.materials.splice(l.index,1);const c={index:this.materials.length,name:e||"",mtllib:Array.isArray(s)&&s.length>0?s[s.length-1]:"",smooth:l!==void 0?l.smooth:this.smooth,groupStart:l!==void 0?l.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(d){const a={index:typeof d=="number"?d:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return a.clone=this.clone.bind(a),a}};return this.materials.push(c),c},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(e){const s=this.currentMaterial();if(s&&s.groupEnd===-1&&(s.groupEnd=this.geometry.vertices.length/3,s.groupCount=s.groupEnd-s.groupStart,s.inherited=!1),e&&this.materials.length>1)for(let l=this.materials.length-1;l>=0;l--)this.materials[l].groupCount<=0&&this.materials.splice(l,1);return e&&this.materials.length===0&&this.materials.push({name:"",smooth:this.smooth}),s}},n&&n.name&&typeof n.clone=="function"){const e=n.clone(0);e.inherited=!0,this.object.materials.push(e)}this.objects.push(this.object)},finalize:function(){this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0)},parseVertexIndex:function(o,t){const n=parseInt(o,10);return(n>=0?n-1:n+t/3)*3},parseNormalIndex:function(o,t){const n=parseInt(o,10);return(n>=0?n-1:n+t/3)*3},parseUVIndex:function(o,t){const n=parseInt(o,10);return(n>=0?n-1:n+t/2)*2},addVertex:function(o,t,n){const e=this.vertices,s=this.object.geometry.vertices;s.push(e[o+0],e[o+1],e[o+2]),s.push(e[t+0],e[t+1],e[t+2]),s.push(e[n+0],e[n+1],e[n+2])},addVertexPoint:function(o){const t=this.vertices;this.object.geometry.vertices.push(t[o+0],t[o+1],t[o+2])},addVertexLine:function(o){const t=this.vertices;this.object.geometry.vertices.push(t[o+0],t[o+1],t[o+2])},addNormal:function(o,t,n){const e=this.normals,s=this.object.geometry.normals;s.push(e[o+0],e[o+1],e[o+2]),s.push(e[t+0],e[t+1],e[t+2]),s.push(e[n+0],e[n+1],e[n+2])},addFaceNormal:function(o,t,n){const e=this.vertices,s=this.object.geometry.normals;Q.fromArray(e,o),N.fromArray(e,t),ee.fromArray(e,n),w.subVectors(ee,N),te.subVectors(Q,N),w.cross(te),w.normalize(),s.push(w.x,w.y,w.z),s.push(w.x,w.y,w.z),s.push(w.x,w.y,w.z)},addColor:function(o,t,n){const e=this.colors,s=this.object.geometry.colors;e[o]!==void 0&&s.push(e[o+0],e[o+1],e[o+2]),e[t]!==void 0&&s.push(e[t+0],e[t+1],e[t+2]),e[n]!==void 0&&s.push(e[n+0],e[n+1],e[n+2])},addUV:function(o,t,n){const e=this.uvs,s=this.object.geometry.uvs;s.push(e[o+0],e[o+1]),s.push(e[t+0],e[t+1]),s.push(e[n+0],e[n+1])},addDefaultUV:function(){const o=this.object.geometry.uvs;o.push(0,0),o.push(0,0),o.push(0,0)},addUVLine:function(o){const t=this.uvs;this.object.geometry.uvs.push(t[o+0],t[o+1])},addFace:function(o,t,n,e,s,l,c,d,a){const r=this.vertices.length;let i=this.parseVertexIndex(o,r),u=this.parseVertexIndex(t,r),f=this.parseVertexIndex(n,r);if(this.addVertex(i,u,f),this.addColor(i,u,f),c!==void 0&&c!==""){const b=this.normals.length;i=this.parseNormalIndex(c,b),u=this.parseNormalIndex(d,b),f=this.parseNormalIndex(a,b),this.addNormal(i,u,f)}else this.addFaceNormal(i,u,f);if(e!==void 0&&e!==""){const b=this.uvs.length;i=this.parseUVIndex(e,b),u=this.parseUVIndex(s,b),f=this.parseUVIndex(l,b),this.addUV(i,u,f),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(o){this.object.geometry.type="Points";const t=this.vertices.length;for(let n=0,e=o.length;n<e;n++){const s=this.parseVertexIndex(o[n],t);this.addVertexPoint(s),this.addColor(s)}},addLineGeometry:function(o,t){this.object.geometry.type="Line";const n=this.vertices.length,e=this.uvs.length;for(let s=0,l=o.length;s<l;s++)this.addVertexLine(this.parseVertexIndex(o[s],n));for(let s=0,l=t.length;s<l;s++)this.addUVLine(this.parseUVIndex(t[s],e))}};return y.startObject("",!1),y}class Ce extends le{constructor(o){super(o),this.materials=null}load(o,t,n,e){const s=this,l=new ce(this.manager);l.setPath(this.path),l.setRequestHeader(this.requestHeader),l.setWithCredentials(this.withCredentials),l.load(o,function(c){try{t(s.parse(c))}catch(d){e?e(d):console.error(d),s.manager.itemError(o)}},n,e)}setMaterials(o){return this.materials=o,this}parse(o){const t=new Me;o.indexOf("\r\n")!==-1&&(o=o.replace(/\r\n/g,"\n")),o.indexOf("\\\n")!==-1&&(o=o.replace(/\\\n/g,""));const n=o.split("\n");let e=[];for(let c=0,d=n.length;c<d;c++){const a=n[c].trimStart();if(a.length===0)continue;const r=a.charAt(0);if(r!=="#")if(r==="v"){const i=a.split(X);switch(i[0]){case"v":t.vertices.push(parseFloat(i[1]),parseFloat(i[2]),parseFloat(i[3])),i.length>=7?(R.setRGB(parseFloat(i[4]),parseFloat(i[5]),parseFloat(i[6])).convertSRGBToLinear(),t.colors.push(R.r,R.g,R.b)):t.colors.push(void 0,void 0,void 0);break;case"vn":t.normals.push(parseFloat(i[1]),parseFloat(i[2]),parseFloat(i[3]));break;case"vt":t.uvs.push(parseFloat(i[1]),parseFloat(i[2]));break}}else if(r==="f"){const u=a.slice(1).trim().split(X),f=[];for(let h=0,g=u.length;h<g;h++){const p=u[h];if(p.length>0){const v=p.split("/");f.push(v)}}const b=f[0];for(let h=1,g=f.length-1;h<g;h++){const p=f[h],v=f[h+1];t.addFace(b[0],p[0],v[0],b[1],p[1],v[1],b[2],p[2],v[2])}}else if(r==="l"){const i=a.substring(1).trim().split(" ");let u=[];const f=[];if(a.indexOf("/")===-1)u=i;else for(let b=0,h=i.length;b<h;b++){const g=i[b].split("/");g[0]!==""&&u.push(g[0]),g[1]!==""&&f.push(g[1])}t.addLineGeometry(u,f)}else if(r==="p"){const u=a.slice(1).trim().split(" ");t.addPointGeometry(u)}else if((e=xe.exec(a))!==null){const i=(" "+e[0].slice(1).trim()).slice(1);t.startObject(i)}else if(je.test(a))t.object.startMaterial(a.substring(7).trim(),t.materialLibraries);else if(Pe.test(a))t.materialLibraries.push(a.substring(7).trim());else if(ze.test(a))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if(r==="s"){if(e=a.split(" "),e.length>1){const u=e[1].trim().toLowerCase();t.object.smooth=u!=="0"&&u!=="off"}else t.object.smooth=!0;const i=t.object.currentMaterial();i&&(i.smooth=t.object.smooth)}else{if(a==="\0")continue;console.warn('THREE.OBJLoader: Unexpected line: "'+a+'"')}}t.finalize();const s=new oe;if(s.materialLibraries=[].concat(t.materialLibraries),!(t.objects.length===1&&t.objects[0].geometry.vertices.length===0)===!0)for(let c=0,d=t.objects.length;c<d;c++){const a=t.objects[c],r=a.geometry,i=a.materials,u=r.type==="Line",f=r.type==="Points";let b=!1;if(r.vertices.length===0)continue;const h=new q;h.setAttribute("position",new x(r.vertices,3)),r.normals.length>0&&h.setAttribute("normal",new x(r.normals,3)),r.colors.length>0&&(b=!0,h.setAttribute("color",new x(r.colors,3))),r.hasUVIndices===!0&&h.setAttribute("uv",new x(r.uvs,2));const g=[];for(let v=0,M=i.length;v<M;v++){const _=i[v],S=_.name+"_"+_.smooth+"_"+b;let m=t.materials[S];if(this.materials!==null){if(m=this.materials.create(_.name),u&&m&&!(m instanceof O)){const P=new O;W.prototype.copy.call(P,m),P.color.copy(m.color),m=P}else if(f&&m&&!(m instanceof L)){const P=new L({size:10,sizeAttenuation:!1});W.prototype.copy.call(P,m),P.color.copy(m.color),P.map=m.map,m=P}}m===void 0&&(u?m=new O:f?m=new L({size:1,sizeAttenuation:!1}):m=new ue,m.name=_.name,m.flatShading=!_.smooth,m.vertexColors=b,t.materials[S]=m),g.push(m)}let p;if(g.length>1){for(let v=0,M=i.length;v<M;v++){const _=i[v];h.addGroup(_.groupStart,_.groupCount,v)}u?p=new Z(h,g):f?p=new B(h,g):p=new U(h,g)}else u?p=new Z(h,g[0]):f?p=new B(h,g[0]):p=new U(h,g[0]);p.name=a.name,s.add(p)}else if(t.vertices.length>0){const c=new L({size:1,sizeAttenuation:!1}),d=new q;d.setAttribute("position",new x(t.vertices,3)),t.colors.length>0&&t.colors[0]!==void 0&&(d.setAttribute("color",new x(t.colors,3)),c.vertexColors=!0);const a=new B(d,c);s.add(a)}return s}}const Se=(y,o)=>new Promise((t,n)=>{o.setCrossOrigin("Anonymous"),o.load(y,e=>{t(e)},e=>{console.log("".concat(e.loaded/e.total*100,"% loaded"))},e=>{console.error(e),n(e)})}),Be=["object"],Ve=D({__name:"cloudPoints",props:{model:{},color:{default:"#FFF"},opacity:{default:1}},setup(y){const o=y,t=new oe;return o.model.traverse(n=>{if(n instanceof U){const e=n.geometry.clone();n.geometry.dispose(),n.material.dispose();const s=new L({color:o.color});s.opacity=o.opacity,s.transparent=!0;const l=new B(e,s);t.add(l)}}),H(()=>{o.color&&t.traverse(n=>{n instanceof B&&(n.material.color=new V(o.color))}),o.opacity&&t.traverse(n=>{n instanceof B&&(n.material.opacity=o.opacity)})}),(n,e)=>(j(),$("primitive",{object:C(t)},null,8,Be))}}),Te="uniform float c;\nuniform float p;\nuniform float uTime;\nvarying float intensity;\nvarying vec2 vUv;\nvoid main(){\n    vUv=uv;\n    vec3 vNormal=normalize(normalMatrix*normal);\n    intensity=pow(c-abs(dot(vNormal,vec3(0,0,1))),p);\n    gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.);\n}",Fe="uniform vec3 glowColor;\nuniform sampler2D lightningTexture;\nvarying float intensity;\nvarying vec2 vUv;\nuniform float offsetY;\nuniform float uTime;\nuniform float uOpacity;\n\nvoid main(){\n  vec2 uv=vUv;\n  uv.y+=offsetY;\n  vec3 glow=glowColor*intensity;\n  vec3 color=vec3(step(.1,uv.y)-step(.2,uv.y))-vec3(texture2D(lightningTexture,uv));\n  float alpha=clamp(cos(uTime*3.),.5,1.);\n  gl_FragColor=vec4(glow+color,alpha*uOpacity);\n}",Le=z("TresBufferGeometry",null,null,-1),Ue=D({__name:"xRayEffect",props:{model:{},color:{default:"#84ccff"},opacity:{default:1}},async setup(y){let o,t;const n=y,e=k(),s=[];n.model.traverse(r=>{r instanceof U&&(r.geometry.verticesNeedUpdate=!0,s.push(r.geometry))});const l=([o,t]=ne(()=>fe({map:"./plugins/medical/image/brainXRayLight.png"})),o=await o,t(),o),c={uniforms:{c:{type:"f",value:1.11},p:{type:"f",value:1},glowColor:{type:"c",value:new V(n.color)},lightningTexture:{type:"t",value:l.map},offsetY:{type:"f",value:.1},uTime:{type:"f",value:0},uOpacity:{type:"f",value:n.opacity}},vertexShader:Te,fragmentShader:Fe,side:se,blending:ie,depthWrite:!1};c.uniforms.offsetY.value=Math.sin(5);const{camera:d}=pe(),{onLoop:a}=ae();return a(({delta:r})=>{d.value.position&&e.value&&(c.uniforms.uTime.value+=r)}),H(()=>{e.value&&(e.value.geometry.dispose(),e.value.geometry=re(s)),n.color&&(c.uniforms.glowColor.value=new V(n.color)),n.opacity&&(c.uniforms.uOpacity.value=n.opacity)}),(r,i)=>(j(),$("TresMesh",{ref_key:"TresMeshRef",ref:e},[Le,z("TresShaderMaterial",J(Y(c)),null,16)],512))}}),Ie="uniform float p;\nuniform float uTime;\nuniform float uSlowTime;\nuniform float uBubblesUp;\nvarying float intensity;\nattribute vec2 aDelayDuration;\nattribute float size;\nattribute vec4 bubbles;\nvarying float alpha;\n\nfloat easeExpoInOut(float p){\n    return((p*=2.)<1.)?.5*pow(2.,10.*(p-1.)):.5*(2.-pow(2.,-10.*(p-1.)));\n}\n\nvoid main()\n{\n    intensity=.9;\n    vec4 mvPosition=modelViewMatrix*vec4(position,1.);\n    gl_PointSize=size*(300./-mvPosition.z);\n    float m=mod(size,sin(uSlowTime*.12+size));\n    \n    alpha=step(.5,abs(m));\n    if(m>.5&&m<.7){\n        gl_PointSize=.9*size;\n    }\n    if(m>.8){\n        gl_PointSize=.9*size;\n    }\n    \n    gl_Position=projectionMatrix*mvPosition;\n    \n    if(bubbles.w>0.&&bubbles.w<2.&&bubbles.x!=0.&&bubbles.y!=0.){\n        gl_PointSize=size+15.;\n        alpha=clamp(abs(sin(uTime-bubbles.y)),.3,1.);\n        \n        float tProgress=smoothstep(0.,aDelayDuration.x,uBubblesUp);\n        vec3 tranlated=mix(position,bubbles.xyz,tProgress);\n        vec4 bPosition=modelViewMatrix*vec4(tranlated,1.);\n        \n        gl_PointSize=uBubblesUp*gl_PointSize;\n        gl_Position+=projectionMatrix*bPosition;\n        alpha=5.;\n    }\n    \n    if(bubbles.w==2.){\n        alpha=clamp(abs(sin(uTime-bubbles.y)),.3,.6);\n        gl_PointSize=size+60.;\n        \n        gl_PointSize=uBubblesUp*gl_PointSize;\n        float normalized=clamp(uBubblesUp,0.,2.)*2.;\n        vec3 tranlated=mix(position,bubbles.xyz,normalized);\n        vec4 bPosition=modelViewMatrix*vec4(tranlated,1.);\n        gl_Position+=projectionMatrix*bPosition;\n    }\n    if(bubbles.w==3.){\n        alpha=clamp(abs(sin(uTime-bubbles.y)),.3,1.);\n        gl_PointSize=size+90.;\n        \n        gl_PointSize=uBubblesUp*gl_PointSize;\n        float normalized=clamp(uBubblesUp,0.,2.)*2.;\n        vec3 tranlated=mix(position,bubbles.xyz,normalized);\n        vec4 bPosition=modelViewMatrix*vec4(tranlated,1.);\n        gl_Position+=projectionMatrix*bPosition;\n    }\n}",Ae="uniform vec3 glowColor;\nvarying float intensity;\nvarying float alpha;\nuniform float uOpacity;\nvoid main()\n{\n    float distanceToCenter=distance(gl_PointCoord,vec2(.5));\n    float pct=1.-smoothstep(0.,.5,distanceToCenter);\n    vec3 color=vec3(1.)*gl_FragColor.rgb;\n    vec3 glow=glowColor*intensity;\n    gl_FragColor=vec4(glow,clamp(alpha,0.,1.));\n    gl_FragColor=vec4(glow,pct*gl_FragColor.a);\n    gl_FragColor=vec4(gl_FragColor.rgb,gl_FragColor.a*uOpacity);\n    // gl_FragColor=vec4(1.,1.,0.,1.);\n}",Ge=D({__name:"bubblesEffect",props:{model:{},color:{default:"#FFF"},opacity:{default:1}},setup(y){const o=y,t=["afective","semantic","episodic","process","amigdala","brainstem","bridge","cerebellum","analitic"],n={};o.model.traverse(a=>{a instanceof U&&t.map(r=>{if(a.name.includes(r)){if(n[r]){const i=[n[r],a.geometry];return n[r]=re(i),n}return n[r]=a.geometry}return[]})});const e=k(),s=()=>{const r=[],i=[],u=[],f=[],g=[];for(let p=0;p<2e4-t.length*3;p+=1){const v=A.randInt(0,t.length-1),M=t[v],_=n[M].attributes.position.array[p*3+0]||0,S=n[M].attributes.position.array[p*3+1]||0,m=n[M].attributes.position.array[p*3+2]||0;if(i.push(_,S,m),r[p]=A.randFloat(10,20),p%100===0){const P=A.randInt(100,250)+S;g.push(_,P,m,1)}else g.push(_,S,m,0);f[p*2+0]=A.randFloat(.5,1.5),f[p*2+1]=2.5}e.value.setAttribute("aDelayDuration",new x(f,2)),e.value.setAttribute("bubbles",new x(g,4)),e.value.setAttribute("position",new x(i,3)),e.value.setAttribute("color",new x(u,3)),e.value.setAttribute("size",new x(r,1)),e.value.computeBoundingSphere()},l=new me({uniforms:{glowColor:{type:"c",value:new V(o.color)},uTime:{type:"f",value:0},uSlowTime:{type:"f",value:0},uBubblesUp:{type:"f",value:1},uOpacity:{type:"f",value:o.opacity}},vertexShader:Ie,fragmentShader:Ae,blending:ie,side:se,depthTest:!1,vertexColors:!1,transparent:!0});H(()=>{e.value&&s()});const c=k(),{onLoop:d}=ae();return d(({delta:a})=>{c.value&&(c.value.material.uniforms.uTime.value+=1/20,c.value.material.uniforms.uSlowTime.value+=1/400),o.color&&(l.uniforms.glowColor.value=new V(o.color)),o.opacity&&(l.uniforms.uOpacity.value=o.opacity)}),(a,r)=>(j(),$("TresPoints",{ref_key:"TresMeshRef",ref:c},[z("TresBufferGeometry",{ref_key:"BufferGeometryRef",ref:e},null,512),z("TresShaderMaterial",J(Y(C(l))),null,16)],512))}}),Re=z("TresPerspectiveCamera",{position:[100,400,500],fov:45,near:.1,far:1e4,"look-at":[0,0,0]},null,-1),De=z("TresAmbientLight",{intensity:.5},null,-1),Oe=z("TresGridHelper",{args:[400,10]},null,-1),Ee={position:[0,120,0]},Ne="./plugins/medical/model/brainparts.OBJ",$e=D({__name:"digitalBrain",async setup(y){let o,t;const n=T({color:"#fff",show:!0,opacity:1}),e=new de({title:"参数"});e.addBinding(n,"show",{label:"点云显示"}),e.addBinding(n,"color",{label:"点云颜色"}),e.addBinding(n,"opacity",{label:"点云透明度",min:0,max:1,step:.1});const s=T({color:"#84ccff",show:!0,opacity:1});e.addBinding(s,"show",{label:"脑轮廓显示"}),e.addBinding(s,"color",{label:"脑轮廓颜色"}),e.addBinding(s,"opacity",{label:"脑轮廓透明度",min:0,max:1,step:.1});const l=T({color:"#9e00af",show:!0,opacity:1});e.addBinding(l,"show",{label:"脑组织显示"}),e.addBinding(l,"color",{label:"脑组织颜色"}),e.addBinding(l,"opacity",{label:"脑组织透明度",min:0,max:1,step:.1});const c=new Ce,d=([o,t]=ne(()=>Se(Ne,c)),o=await o,t(),o),a=T({clearColor:"#000",shadows:!0,alpha:!1,shadowMapType:he,outputColorSpace:ge,toneMapping:be}),r=T({autoRotate:!0,autoRotateSpeed:2});return(i,u)=>(j(),F(C(ve),G(a,{"window-size":""}),{default:K(()=>[Re,ye(C(_e),J(Y(r)),null,16),De,Oe,z("TresGroup",Ee,[n.show?(j(),F(Ve,G({key:0,model:C(d)},n),null,16,["model"])):E("",!0),(j(),F(we,null,{default:K(()=>[s.show?(j(),F(Ue,G({key:0,model:C(d)},s),null,16,["model"])):E("",!0)]),_:1})),l.show?(j(),F(Ge,G({key:1,model:C(d)},l),null,16,["model"])):E("",!0)])]),_:1},16))}});export{$e as default};
