import{aL as E,aI as S,bq as ce,br as ue,bs as ne,bi as H,aT as _,bt as O,aQ as W,bl as G,ak as fe,bu as X,bn as M,b3 as V,Y as I,a4 as $,o as B,c as J,I as A,aG as me,j as N,az as se,aM as pe,aE as ie,ah as re,bv as de,a3 as ae,U as z,a8 as Y,a9 as q,b0 as he,am as L,Z as C,ae as ge,$ as be,a0 as ye,a1 as ve,s as U,B as Q,a6 as R,a7 as we,a as xe,aa as _e,V as D,aC as Te}from"./vendor-e1483ee8.js";const Be=/^[og]\s*(.+)?/,ze=/^mtllib /,je=/^usemtl /,Ae=/^usemap /,Z=/\s+/,K=new E,k=new E,ee=new E,te=new E,x=new E,F=new S;function Pe(){const p={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(o,t){if(this.object&&this.object.fromDeclaration===!1){this.object.name=o,this.object.fromDeclaration=t!==!1;return}const n=this.object&&typeof this.object.currentMaterial=="function"?this.object.currentMaterial():void 0;if(this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0),this.object={name:o||"",fromDeclaration:t!==!1,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(e,s){const l=this._finalize(!1);l&&(l.inherited||l.groupCount<=0)&&this.materials.splice(l.index,1);const f={index:this.materials.length,name:e||"",mtllib:Array.isArray(s)&&s.length>0?s[s.length-1]:"",smooth:l!==void 0?l.smooth:this.smooth,groupStart:l!==void 0?l.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(m){const a={index:typeof m=="number"?m:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return a.clone=this.clone.bind(a),a}};return this.materials.push(f),f},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(e){const s=this.currentMaterial();if(s&&s.groupEnd===-1&&(s.groupEnd=this.geometry.vertices.length/3,s.groupCount=s.groupEnd-s.groupStart,s.inherited=!1),e&&this.materials.length>1)for(let l=this.materials.length-1;l>=0;l--)this.materials[l].groupCount<=0&&this.materials.splice(l,1);return e&&this.materials.length===0&&this.materials.push({name:"",smooth:this.smooth}),s}},n&&n.name&&typeof n.clone=="function"){const e=n.clone(0);e.inherited=!0,this.object.materials.push(e)}this.objects.push(this.object)},finalize:function(){this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0)},parseVertexIndex:function(o,t){const n=parseInt(o,10);return(n>=0?n-1:n+t/3)*3},parseNormalIndex:function(o,t){const n=parseInt(o,10);return(n>=0?n-1:n+t/3)*3},parseUVIndex:function(o,t){const n=parseInt(o,10);return(n>=0?n-1:n+t/2)*2},addVertex:function(o,t,n){const e=this.vertices,s=this.object.geometry.vertices;s.push(e[o+0],e[o+1],e[o+2]),s.push(e[t+0],e[t+1],e[t+2]),s.push(e[n+0],e[n+1],e[n+2])},addVertexPoint:function(o){const t=this.vertices;this.object.geometry.vertices.push(t[o+0],t[o+1],t[o+2])},addVertexLine:function(o){const t=this.vertices;this.object.geometry.vertices.push(t[o+0],t[o+1],t[o+2])},addNormal:function(o,t,n){const e=this.normals,s=this.object.geometry.normals;s.push(e[o+0],e[o+1],e[o+2]),s.push(e[t+0],e[t+1],e[t+2]),s.push(e[n+0],e[n+1],e[n+2])},addFaceNormal:function(o,t,n){const e=this.vertices,s=this.object.geometry.normals;K.fromArray(e,o),k.fromArray(e,t),ee.fromArray(e,n),x.subVectors(ee,k),te.subVectors(K,k),x.cross(te),x.normalize(),s.push(x.x,x.y,x.z),s.push(x.x,x.y,x.z),s.push(x.x,x.y,x.z)},addColor:function(o,t,n){const e=this.colors,s=this.object.geometry.colors;e[o]!==void 0&&s.push(e[o+0],e[o+1],e[o+2]),e[t]!==void 0&&s.push(e[t+0],e[t+1],e[t+2]),e[n]!==void 0&&s.push(e[n+0],e[n+1],e[n+2])},addUV:function(o,t,n){const e=this.uvs,s=this.object.geometry.uvs;s.push(e[o+0],e[o+1]),s.push(e[t+0],e[t+1]),s.push(e[n+0],e[n+1])},addDefaultUV:function(){const o=this.object.geometry.uvs;o.push(0,0),o.push(0,0),o.push(0,0)},addUVLine:function(o){const t=this.uvs;this.object.geometry.uvs.push(t[o+0],t[o+1])},addFace:function(o,t,n,e,s,l,f,m,a){const i=this.vertices.length;let r=this.parseVertexIndex(o,i),u=this.parseVertexIndex(t,i),c=this.parseVertexIndex(n,i);if(this.addVertex(r,u,c),this.addColor(r,u,c),f!==void 0&&f!==""){const d=this.normals.length;r=this.parseNormalIndex(f,d),u=this.parseNormalIndex(m,d),c=this.parseNormalIndex(a,d),this.addNormal(r,u,c)}else this.addFaceNormal(r,u,c);if(e!==void 0&&e!==""){const d=this.uvs.length;r=this.parseUVIndex(e,d),u=this.parseUVIndex(s,d),c=this.parseUVIndex(l,d),this.addUV(r,u,c),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(o){this.object.geometry.type="Points";const t=this.vertices.length;for(let n=0,e=o.length;n<e;n++){const s=this.parseVertexIndex(o[n],t);this.addVertexPoint(s),this.addColor(s)}},addLineGeometry:function(o,t){this.object.geometry.type="Line";const n=this.vertices.length,e=this.uvs.length;for(let s=0,l=o.length;s<l;s++)this.addVertexLine(this.parseVertexIndex(o[s],n));for(let s=0,l=t.length;s<l;s++)this.addUVLine(this.parseUVIndex(t[s],e))}};return p.startObject("",!1),p}class Me extends ce{constructor(o){super(o),this.materials=null}load(o,t,n,e){const s=this,l=new ue(this.manager);l.setPath(this.path),l.setRequestHeader(this.requestHeader),l.setWithCredentials(this.withCredentials),l.load(o,function(f){try{t(s.parse(f))}catch(m){e?e(m):console.error(m),s.manager.itemError(o)}},n,e)}setMaterials(o){return this.materials=o,this}parse(o){const t=new Pe;o.indexOf("\r\n")!==-1&&(o=o.replace(/\r\n/g,"\n")),o.indexOf("\\\n")!==-1&&(o=o.replace(/\\\n/g,""));const n=o.split("\n");let e=[];for(let f=0,m=n.length;f<m;f++){const a=n[f].trimStart();if(a.length===0)continue;const i=a.charAt(0);if(i!=="#")if(i==="v"){const r=a.split(Z);switch(r[0]){case"v":t.vertices.push(parseFloat(r[1]),parseFloat(r[2]),parseFloat(r[3])),r.length>=7?(F.setRGB(parseFloat(r[4]),parseFloat(r[5]),parseFloat(r[6])).convertSRGBToLinear(),t.colors.push(F.r,F.g,F.b)):t.colors.push(void 0,void 0,void 0);break;case"vn":t.normals.push(parseFloat(r[1]),parseFloat(r[2]),parseFloat(r[3]));break;case"vt":t.uvs.push(parseFloat(r[1]),parseFloat(r[2]));break}}else if(i==="f"){const u=a.slice(1).trim().split(Z),c=[];for(let h=0,y=u.length;h<y;h++){const g=u[h];if(g.length>0){const v=g.split("/");c.push(v)}}const d=c[0];for(let h=1,y=c.length-1;h<y;h++){const g=c[h],v=c[h+1];t.addFace(d[0],g[0],v[0],d[1],g[1],v[1],d[2],g[2],v[2])}}else if(i==="l"){const r=a.substring(1).trim().split(" ");let u=[];const c=[];if(a.indexOf("/")===-1)u=r;else for(let d=0,h=r.length;d<h;d++){const y=r[d].split("/");y[0]!==""&&u.push(y[0]),y[1]!==""&&c.push(y[1])}t.addLineGeometry(u,c)}else if(i==="p"){const u=a.slice(1).trim().split(" ");t.addPointGeometry(u)}else if((e=Be.exec(a))!==null){const r=(" "+e[0].slice(1).trim()).slice(1);t.startObject(r)}else if(je.test(a))t.object.startMaterial(a.substring(7).trim(),t.materialLibraries);else if(ze.test(a))t.materialLibraries.push(a.substring(7).trim());else if(Ae.test(a))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if(i==="s"){if(e=a.split(" "),e.length>1){const u=e[1].trim().toLowerCase();t.object.smooth=u!=="0"&&u!=="off"}else t.object.smooth=!0;const r=t.object.currentMaterial();r&&(r.smooth=t.object.smooth)}else{if(a==="\0")continue;console.warn('THREE.OBJLoader: Unexpected line: "'+a+'"')}}t.finalize();const s=new ne;if(s.materialLibraries=[].concat(t.materialLibraries),!(t.objects.length===1&&t.objects[0].geometry.vertices.length===0)===!0)for(let f=0,m=t.objects.length;f<m;f++){const a=t.objects[f],i=a.geometry,r=a.materials,u=i.type==="Line",c=i.type==="Points";let d=!1;if(i.vertices.length===0)continue;const h=new H;h.setAttribute("position",new _(i.vertices,3)),i.normals.length>0&&h.setAttribute("normal",new _(i.normals,3)),i.colors.length>0&&(d=!0,h.setAttribute("color",new _(i.colors,3))),i.hasUVIndices===!0&&h.setAttribute("uv",new _(i.uvs,2));const y=[];for(let v=0,j=r.length;v<j;v++){const w=r[v],P=w.name+"_"+w.smooth+"_"+d;let b=t.materials[P];if(this.materials!==null){if(b=this.materials.create(w.name),u&&b&&!(b instanceof O)){const T=new O;W.prototype.copy.call(T,b),T.color.copy(b.color),b=T}else if(c&&b&&!(b instanceof G)){const T=new G({size:10,sizeAttenuation:!1});W.prototype.copy.call(T,b),T.color.copy(b.color),T.map=b.map,b=T}}b===void 0&&(u?b=new O:c?b=new G({size:1,sizeAttenuation:!1}):b=new fe,b.name=w.name,b.flatShading=!w.smooth,b.vertexColors=d,t.materials[P]=b),y.push(b)}let g;if(y.length>1){for(let v=0,j=r.length;v<j;v++){const w=r[v];h.addGroup(w.groupStart,w.groupCount,v)}u?g=new X(h,y):c?g=new M(h,y):g=new V(h,y)}else u?g=new X(h,y[0]):c?g=new M(h,y[0]):g=new V(h,y[0]);g.name=a.name,s.add(g)}else if(t.vertices.length>0){const f=new G({size:1,sizeAttenuation:!1}),m=new H;m.setAttribute("position",new _(t.vertices,3)),t.colors.length>0&&t.colors[0]!==void 0&&(m.setAttribute("color",new _(t.colors,3)),f.vertexColors=!0);const a=new M(m,f);s.add(a)}return s}}const Se=(p,o)=>new Promise((t,n)=>{o.setCrossOrigin("Anonymous"),o.load(p,e=>{t(e)},e=>{console.log("".concat(e.loaded/e.total*100,"% loaded"))},e=>{console.error(e),n(e)})}),Ce=["object"],Ue=I({__name:"cloudPoints",props:{model:{},color:{default:"#FFF"},opacity:{default:1}},setup(p){const o=p,t=new ne;return o.model.traverse(n=>{if(n instanceof V){const e=n.geometry.clone();n.geometry.dispose(),n.material.dispose();const s=new G({color:o.color});s.opacity=o.opacity,s.transparent=!0;const l=new M(e,s);t.add(l)}}),$(()=>{o.color&&t.traverse(n=>{n instanceof M&&(n.material.color=new S(o.color))}),o.opacity&&t.traverse(n=>{n instanceof M&&(n.material.opacity=o.opacity)})}),(n,e)=>(B(),J("primitive",{object:A(t)},null,8,Ce))}}),Ge="uniform float c;\nuniform float p;\nuniform float uTime;\nvarying float intensity;\nvarying vec2 vUv;\nvoid main(){\n    vUv=uv;\n    vec3 vNormal=normalize(normalMatrix*normal);\n    intensity=pow(c-abs(dot(vNormal,vec3(0,0,1))),p);\n    gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.);\n}",Ve="uniform vec3 glowColor;\nuniform sampler2D lightningTexture;\nvarying float intensity;\nvarying vec2 vUv;\nuniform float offsetY;\nuniform float uTime;\nuniform float uOpacity;\n\nvoid main(){\n  vec2 uv=vUv;\n  uv.y+=offsetY;\n  vec3 glow=glowColor*intensity;\n  vec3 color=vec3(step(.1,uv.y)-step(.2,uv.y))-vec3(texture2D(lightningTexture,uv));\n  float alpha=clamp(cos(uTime*3.),.5,1.);\n  gl_FragColor=vec4(glow+color,alpha*uOpacity);\n}";function le(p,o=!1){const t=p[0].index!==null,n=new Set(Object.keys(p[0].attributes)),e=new Set(Object.keys(p[0].morphAttributes)),s={},l={},f=p[0].morphTargetsRelative,m=new H;let a=0;for(let i=0;i<p.length;++i){const r=p[i];let u=0;if(t!==(r.index!==null))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+i+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const c in r.attributes){if(!n.has(c))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+i+'. All geometries must have compatible attributes; make sure "'+c+'" attribute exists among all geometries, or in none of them.'),null;s[c]===void 0&&(s[c]=[]),s[c].push(r.attributes[c]),u++}if(u!==n.size)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+i+". Make sure all geometries have the same number of attributes."),null;if(f!==r.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+i+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const c in r.morphAttributes){if(!e.has(c))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+i+".  .morphAttributes must be consistent throughout all geometries."),null;l[c]===void 0&&(l[c]=[]),l[c].push(r.morphAttributes[c])}if(o){let c;if(t)c=r.index.count;else if(r.attributes.position!==void 0)c=r.attributes.position.count;else return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+i+". The geometry must have either an index or a position attribute"),null;m.addGroup(a,c,i),a+=c}}if(t){let i=0;const r=[];for(let u=0;u<p.length;++u){const c=p[u].index;for(let d=0;d<c.count;++d)r.push(c.getX(d)+i);i+=p[u].attributes.position.count}m.setIndex(r)}for(const i in s){const r=oe(s[i]);if(!r)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+i+" attribute."),null;m.setAttribute(i,r)}for(const i in l){const r=l[i][0].length;if(r===0)break;m.morphAttributes=m.morphAttributes||{},m.morphAttributes[i]=[];for(let u=0;u<r;++u){const c=[];for(let h=0;h<l[i].length;++h)c.push(l[i][h][u]);const d=oe(c);if(!d)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+i+" morphAttribute."),null;m.morphAttributes[i].push(d)}}return m}function oe(p){let o,t,n,e=-1,s=0;for(let a=0;a<p.length;++a){const i=p[a];if(i.isInterleavedBufferAttribute)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. InterleavedBufferAttributes are not supported."),null;if(o===void 0&&(o=i.array.constructor),o!==i.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(t===void 0&&(t=i.itemSize),t!==i.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(n===void 0&&(n=i.normalized),n!==i.normalized)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;if(e===-1&&(e=i.gpuType),e!==i.gpuType)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."),null;s+=i.array.length}const l=new o(s);let f=0;for(let a=0;a<p.length;++a)l.set(p[a].array,f),f+=p[a].array.length;const m=new me(l,t,n);return e!==void 0&&(m.gpuType=e),m}const Ee=z("TresBufferGeometry",null,null,-1),Le=I({__name:"xRayEffect",props:{model:{},color:{default:"#84ccff"},opacity:{default:1}},async setup(p){let o,t;const n=p,e=N(),s=[];n.model.traverse(i=>{i instanceof V&&(i.geometry.verticesNeedUpdate=!0,s.push(i.geometry))});const l=([o,t]=se(()=>pe({map:"./plugins/medical/image/brainXRayLight.png"})),o=await o,t(),o),f={uniforms:{c:{type:"f",value:1.11},p:{type:"f",value:1},glowColor:{type:"c",value:new S(n.color)},lightningTexture:{type:"t",value:l.map},offsetY:{type:"f",value:.1},uTime:{type:"f",value:0},uOpacity:{type:"f",value:n.opacity}},vertexShader:Ge,fragmentShader:Ve,side:ie,blending:re,depthWrite:!1};f.uniforms.offsetY.value=Math.sin(5);const{camera:m}=de(),{onLoop:a}=ae();return a(({delta:i})=>{m.value.position&&e.value&&(f.uniforms.uTime.value+=i)}),$(()=>{e.value&&(e.value.geometry.dispose(),e.value.geometry=le(s)),n.color&&(f.uniforms.glowColor.value=new S(n.color)),n.opacity&&(f.uniforms.uOpacity.value=n.opacity)}),(i,r)=>(B(),J("TresMesh",{ref_key:"TresMeshRef",ref:e},[Ee,z("TresShaderMaterial",Y(q(f)),null,16)],512))}}),Re="uniform float p;\nuniform float uTime;\nuniform float uSlowTime;\nuniform float uBubblesUp;\nvarying float intensity;\nattribute vec2 aDelayDuration;\nattribute float size;\nattribute vec4 bubbles;\nvarying float alpha;\n\nfloat easeExpoInOut(float p){\n    return((p*=2.)<1.)?.5*pow(2.,10.*(p-1.)):.5*(2.-pow(2.,-10.*(p-1.)));\n}\n\nvoid main()\n{\n    intensity=.9;\n    vec4 mvPosition=modelViewMatrix*vec4(position,1.);\n    gl_PointSize=size*(300./-mvPosition.z);\n    float m=mod(size,sin(uSlowTime*.12+size));\n    \n    alpha=step(.5,abs(m));\n    if(m>.5&&m<.7){\n        gl_PointSize=.9*size;\n    }\n    if(m>.8){\n        gl_PointSize=.9*size;\n    }\n    \n    gl_Position=projectionMatrix*mvPosition;\n    \n    if(bubbles.w>0.&&bubbles.w<2.&&bubbles.x!=0.&&bubbles.y!=0.){\n        gl_PointSize=size+15.;\n        alpha=clamp(abs(sin(uTime-bubbles.y)),.3,1.);\n        \n        float tProgress=smoothstep(0.,aDelayDuration.x,uBubblesUp);\n        vec3 tranlated=mix(position,bubbles.xyz,tProgress);\n        vec4 bPosition=modelViewMatrix*vec4(tranlated,1.);\n        \n        gl_PointSize=uBubblesUp*gl_PointSize;\n        gl_Position+=projectionMatrix*bPosition;\n        alpha=5.;\n    }\n    \n    if(bubbles.w==2.){\n        alpha=clamp(abs(sin(uTime-bubbles.y)),.3,.6);\n        gl_PointSize=size+60.;\n        \n        gl_PointSize=uBubblesUp*gl_PointSize;\n        float normalized=clamp(uBubblesUp,0.,2.)*2.;\n        vec3 tranlated=mix(position,bubbles.xyz,normalized);\n        vec4 bPosition=modelViewMatrix*vec4(tranlated,1.);\n        gl_Position+=projectionMatrix*bPosition;\n    }\n    if(bubbles.w==3.){\n        alpha=clamp(abs(sin(uTime-bubbles.y)),.3,1.);\n        gl_PointSize=size+90.;\n        \n        gl_PointSize=uBubblesUp*gl_PointSize;\n        float normalized=clamp(uBubblesUp,0.,2.)*2.;\n        vec3 tranlated=mix(position,bubbles.xyz,normalized);\n        vec4 bPosition=modelViewMatrix*vec4(tranlated,1.);\n        gl_Position+=projectionMatrix*bPosition;\n    }\n}",Fe="uniform vec3 glowColor;\nvarying float intensity;\nvarying float alpha;\nuniform float uOpacity;\nvoid main()\n{\n    float distanceToCenter=distance(gl_PointCoord,vec2(.5));\n    float pct=1.-smoothstep(0.,.5,distanceToCenter);\n    vec3 color=vec3(1.)*gl_FragColor.rgb;\n    vec3 glow=glowColor*intensity;\n    gl_FragColor=vec4(glow,clamp(alpha,0.,1.));\n    gl_FragColor=vec4(glow,pct*gl_FragColor.a);\n    gl_FragColor=vec4(gl_FragColor.rgb,gl_FragColor.a*uOpacity);\n    // gl_FragColor=vec4(1.,1.,0.,1.);\n}",Ie=I({__name:"bubblesEffect",props:{model:{},color:{default:"#FFF"},opacity:{default:1}},setup(p){const o=p,t=["afective","semantic","episodic","process","amigdala","brainstem","bridge","cerebellum","analitic"],n={};o.model.traverse(a=>{a instanceof V&&t.map(i=>{if(a.name.includes(i)){if(n[i]){const r=[n[i],a.geometry];return n[i]=le(r),n}return n[i]=a.geometry}return[]})});const e=N(),s=()=>{const i=[],r=[],u=[],c=[],y=[];for(let g=0;g<2e4-t.length*3;g+=1){const v=L.randInt(0,t.length-1),j=t[v],w=n[j].attributes.position.array[g*3+0]||0,P=n[j].attributes.position.array[g*3+1]||0,b=n[j].attributes.position.array[g*3+2]||0;if(r.push(w,P,b),i[g]=L.randFloat(10,20),g%100===0){const T=L.randInt(100,250)+P;y.push(w,T,b,1)}else y.push(w,P,b,0);c[g*2+0]=L.randFloat(.5,1.5),c[g*2+1]=2.5}e.value.setAttribute("aDelayDuration",new _(c,2)),e.value.setAttribute("bubbles",new _(y,4)),e.value.setAttribute("position",new _(r,3)),e.value.setAttribute("color",new _(u,3)),e.value.setAttribute("size",new _(i,1)),e.value.computeBoundingSphere()},l=new he({uniforms:{glowColor:{type:"c",value:new S(o.color)},uTime:{type:"f",value:0},uSlowTime:{type:"f",value:0},uBubblesUp:{type:"f",value:1},uOpacity:{type:"f",value:o.opacity}},vertexShader:Re,fragmentShader:Fe,blending:re,side:ie,depthTest:!1,vertexColors:!1,transparent:!0});$(()=>{e.value&&s()});const f=N(),{onLoop:m}=ae();return m(({delta:a})=>{f.value&&(f.value.material.uniforms.uTime.value+=1/20,f.value.material.uniforms.uSlowTime.value+=1/400),o.color&&(l.uniforms.glowColor.value=new S(o.color)),o.opacity&&(l.uniforms.uOpacity.value=o.opacity)}),(a,i)=>(B(),J("TresPoints",{ref_key:"TresMeshRef",ref:f},[z("TresBufferGeometry",{ref_key:"BufferGeometryRef",ref:e},null,512),z("TresShaderMaterial",Y(q(A(l))),null,16)],512))}}),Oe=z("TresPerspectiveCamera",{position:[100,400,500],fov:45,near:.1,far:1e4,"look-at":[0,0,0]},null,-1),De=z("TresAmbientLight",{intensity:.5},null,-1),ke=z("TresGridHelper",{args:[400,10]},null,-1),He={position:[0,120,0]},Ne="./plugins/medical/model/brainparts.OBJ",Je=I({__name:"digitalBrain",async setup(p){let o,t;const n=C({color:"#fff",show:!0,opacity:1}),e=new ge({title:"参数"});e.addBinding(n,"show",{label:"点云显示"}),e.addBinding(n,"color",{label:"点云颜色"}),e.addBinding(n,"opacity",{label:"点云透明度",min:0,max:1,step:.1});const s=C({color:"#84ccff",show:!0,opacity:1});e.addBinding(s,"show",{label:"脑轮廓显示"}),e.addBinding(s,"color",{label:"脑轮廓颜色"}),e.addBinding(s,"opacity",{label:"脑轮廓透明度",min:0,max:1,step:.1});const l=C({color:"#9e00af",show:!0,opacity:1});e.addBinding(l,"show",{label:"脑组织显示"}),e.addBinding(l,"color",{label:"脑组织颜色"}),e.addBinding(l,"opacity",{label:"脑组织透明度",min:0,max:1,step:.1});const f=new Me,m=([o,t]=se(()=>Se(Ne,f)),o=await o,t(),o),a=C({clearColor:"#000",shadows:!0,alpha:!1,shadowMapType:be,outputColorSpace:ye,toneMapping:ve}),i=C({autoRotate:!0,autoRotateSpeed:2});return(r,u)=>(B(),U(A(we),R(a,{"window-size":""}),{default:Q(()=>[Oe,xe(A(_e),Y(q(i)),null,16),De,ke,z("TresGroup",He,[n.show?(B(),U(Ue,R({key:0,model:A(m)},n),null,16,["model"])):D("",!0),(B(),U(Te,null,{default:Q(()=>[s.show?(B(),U(Le,R({key:0,model:A(m)},s),null,16,["model"])):D("",!0)]),_:1})),l.show?(B(),U(Ie,R({key:1,model:A(m)},l),null,16,["model"])):D("",!0)])]),_:1},16))}});export{Je as default};
