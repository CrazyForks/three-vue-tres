import{bh as p,aL as y}from"./vendor-8e4d08ca.js";function E(i,c=!1){const l=i[0].index!==null,f=new Set(Object.keys(i[0].attributes)),m=new Set(Object.keys(i[0].morphAttributes)),a={},u={},d=i[0].morphTargetsRelative,o=new p;let n=0;for(let e=0;e<i.length;++e){const r=i[e];let s=0;if(l!==(r.index!==null))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const t in r.attributes){if(!f.has(t))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+'. All geometries must have compatible attributes; make sure "'+t+'" attribute exists among all geometries, or in none of them.'),null;a[t]===void 0&&(a[t]=[]),a[t].push(r.attributes[t]),s++}if(s!==f.size)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+". Make sure all geometries have the same number of attributes."),null;if(d!==r.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const t in r.morphAttributes){if(!m.has(t))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+".  .morphAttributes must be consistent throughout all geometries."),null;u[t]===void 0&&(u[t]=[]),u[t].push(r.morphAttributes[t])}if(c){let t;if(l)t=r.index.count;else if(r.attributes.position!==void 0)t=r.attributes.position.count;else return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+". The geometry must have either an index or a position attribute"),null;o.addGroup(n,t,e),n+=t}}if(l){let e=0;const r=[];for(let s=0;s<i.length;++s){const t=i[s].index;for(let h=0;h<t.count;++h)r.push(t.getX(h)+e);e+=i[s].attributes.position.count}o.setIndex(r)}for(const e in a){const r=b(a[e]);if(!r)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+e+" attribute."),null;o.setAttribute(e,r)}for(const e in u){const r=u[e][0].length;if(r===0)break;o.morphAttributes=o.morphAttributes||{},o.morphAttributes[e]=[];for(let s=0;s<r;++s){const t=[];for(let g=0;g<u[e].length;++g)t.push(u[e][g][s]);const h=b(t);if(!h)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+e+" morphAttribute."),null;o.morphAttributes[e].push(h)}}return o}function b(i){let c,l,f,m=-1,a=0;for(let n=0;n<i.length;++n){const e=i[n];if(e.isInterleavedBufferAttribute)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. InterleavedBufferAttributes are not supported."),null;if(c===void 0&&(c=e.array.constructor),c!==e.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(l===void 0&&(l=e.itemSize),l!==e.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(f===void 0&&(f=e.normalized),f!==e.normalized)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;if(m===-1&&(m=e.gpuType),m!==e.gpuType)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."),null;a+=e.array.length}const u=new c(a);let d=0;for(let n=0;n<i.length;++n)u.set(i[n].array,d),d+=i[n].array.length;const o=new y(u,l,f);return m!==void 0&&(o.gpuType=m),o}export{E as m};
