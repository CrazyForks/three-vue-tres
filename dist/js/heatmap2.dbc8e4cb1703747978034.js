var oe=Object.defineProperty,re=Object.defineProperties;var ce=Object.getOwnPropertyDescriptors;var bn=Object.getOwnPropertySymbols;var ae=Object.prototype.hasOwnProperty,le=Object.prototype.propertyIsEnumerable;var Tn=(e,n,t)=>n in e?oe(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t,Mt=(e,n)=>{for(var t in n||(n={}))ae.call(n,t)&&Tn(e,t,n[t]);if(bn)for(var t of bn(n))le.call(n,t)&&Tn(e,t,n[t]);return e},Bn=(e,n)=>re(e,ce(n));import{an as Wt,aK as Kn,aH as U,aV as pt,aZ as Jn,ba as W,aI as Bt,bb as ue,a_ as K,bc as Z,aO as fe,aF as Qn,aL as Pn,aX as cn,bd as pe,be as ye,k as Xt,Z as On,bf as de,a4 as me,o as hn,c as xn,V as _n,J as _t,D as Gn,aJ as Mn,aT as he,_ as xe,a5 as we,ak as Ae,H as ge,I as be,t as Te,X as Be,aB as Pe,$ as Sn,af as _e,a as St,C as Me,a6 as vn}from"./vendor.08a60d9a1703747978034.js";import{_ as Se,l as ve,b as Ce}from"./pagesShow.vue_vue_type_script_setup_true_lang.e04b06be1703747978034.js";import{h as Ue}from"./heatmap.a17deb0e1703747978034.js";import{r as Le}from"./utils.9bccc6641703747978034.js";import{m as Fe}from"./BufferGeometryUtils.c44ebaec1703747978034.js";import"./vanilla-307d3a93.esm.2411fe671703747978034.js";import"./_commonjsHelpers.725317a41703747978034.js";const Cn=36,an=-10,Un=(e,n)=>e.getValueAt(n)+an,De=(e,n)=>{if(!n){let t=0;for(n=[];t<1e3;)n.push({x:Wt.randInt(1,e._config.width),y:Wt.randInt(1,e._config.height),value:Wt.randInt(an,Cn)}),t++}e.setData({max:Cn,min:an,data:n})},Ee=(e=250,n=250,t=!0)=>{const s=document.createElement("heatmap-canvas");return s.style.position="absolute",t||(s.style.display="none"),s.style.top="0",s.style.left="0",document.body.appendChild(s),Ue.create({container:s,width:e,height:n,blur:".8",radius:10,gradient:{.25:"rgb(0,0,255)",.55:"rgb(0,255,0)",.85:"yellow",1:"rgb(255,0,0)"}})},te=0,Ie=1,ze=2,Ln=2,Kt=1.25,Fn=1,Ht=6*4+4+4,Zt=65535,Ve=Math.pow(2,-24),Jt=Symbol("SKIP_GENERATION");function Re(e){return e.index?e.index.count:e.attributes.position.count}function yt(e){return Re(e)/3}function Ne(e,n=ArrayBuffer){return e>65535?new Uint32Array(new n(4*e)):new Uint16Array(new n(2*e))}function $e(e,n){if(!e.index){const t=e.attributes.position.count,s=n.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=Ne(t,s);e.setIndex(new Kn(i,1));for(let a=0;a<t;a++)i[a]=a}}function ne(e){const n=yt(e),t=e.drawRange,s=t.start/3,i=(t.start+t.count)/3,a=Math.max(0,s),o=Math.min(n,i)-a;return[{offset:Math.floor(a),count:Math.floor(o)}]}function ee(e){if(!e.groups||!e.groups.length)return ne(e);const n=[],t=new Set,s=e.drawRange,i=s.start/3,a=(s.start+s.count)/3;for(const c of e.groups){const r=c.start/3,p=(c.start+c.count)/3;t.add(Math.max(i,r)),t.add(Math.min(a,p))}const o=Array.from(t.values()).sort((c,r)=>c-r);for(let c=0;c<o.length-1;c++){const r=o[c],p=o[c+1];n.push({offset:Math.floor(r),count:Math.floor(p-r)})}return n}function qe(e){if(e.groups.length===0)return!1;const n=yt(e),t=ee(e).sort((a,o)=>a.offset-o.offset),s=t[t.length-1];s.count=Math.min(n-s.offset,s.count);let i=0;return t.forEach(({count:a})=>i+=a),n!==i}function E(e,n,t){return t.min.x=n[e],t.min.y=n[e+1],t.min.z=n[e+2],t.max.x=n[e+3],t.max.y=n[e+4],t.max.z=n[e+5],t}function ke(e){e[0]=e[1]=e[2]=1/0,e[3]=e[4]=e[5]=-1/0}function Dn(e){let n=-1,t=-1/0;for(let s=0;s<3;s++){const i=e[s+3]-e[s];i>t&&(t=i,n=s)}return n}function En(e,n){n.set(e)}function In(e,n,t){let s,i;for(let a=0;a<3;a++){const o=a+3;s=e[a],i=n[a],t[a]=s<i?s:i,s=e[o],i=n[o],t[o]=s>i?s:i}}function vt(e,n,t){for(let s=0;s<3;s++){const i=n[e+2*s],a=n[e+2*s+1],o=i-a,c=i+a;o<t[s]&&(t[s]=o),c>t[s+3]&&(t[s+3]=c)}}function xt(e){const n=e[3]-e[0],t=e[4]-e[1],s=e[5]-e[2];return 2*(n*t+t*s+s*n)}function Qt(e,n,t,s,i=null){let a=1/0,o=1/0,c=1/0,r=-1/0,p=-1/0,u=-1/0,f=1/0,l=1/0,y=1/0,m=-1/0,T=-1/0,g=-1/0;const d=i!==null;for(let h=n*6,A=(n+t)*6;h<A;h+=6){const x=e[h+0],w=e[h+1],b=x-w,_=x+w;b<a&&(a=b),_>r&&(r=_),d&&x<f&&(f=x),d&&x>m&&(m=x);const B=e[h+2],M=e[h+3],S=B-M,C=B+M;S<o&&(o=S),C>p&&(p=C),d&&B<l&&(l=B),d&&B>T&&(T=B);const P=e[h+4],v=e[h+5],L=P-v,F=P+v;L<c&&(c=L),F>u&&(u=F),d&&P<y&&(y=P),d&&P>g&&(g=P)}s[0]=a,s[1]=o,s[2]=c,s[3]=r,s[4]=p,s[5]=u,d&&(i[0]=f,i[1]=l,i[2]=y,i[3]=m,i[4]=T,i[5]=g)}function He(e,n,t,s){let i=1/0,a=1/0,o=1/0,c=-1/0,r=-1/0,p=-1/0;for(let u=n*6,f=(n+t)*6;u<f;u+=6){const l=e[u+0];l<i&&(i=l),l>c&&(c=l);const y=e[u+2];y<a&&(a=y),y>r&&(r=y);const m=e[u+4];m<o&&(o=m),m>p&&(p=m)}s[0]=i,s[1]=a,s[2]=o,s[3]=c,s[4]=r,s[5]=p}function Xe(e,n){ke(n);const t=e.attributes.position,s=e.index?e.index.array:null,i=yt(e),a=new Float32Array(i*6),o=t.normalized,c=t.array,r=t.offset||0;let p=3;t.isInterleavedBufferAttribute&&(p=t.data.stride);const u=["getX","getY","getZ"];for(let f=0;f<i;f++){const l=f*3,y=f*6;let m=l+0,T=l+1,g=l+2;s&&(m=s[m],T=s[T],g=s[g]),o||(m=m*p+r,T=T*p+r,g=g*p+r);for(let d=0;d<3;d++){let h,A,x;o?(h=t[u[d]](m),A=t[u[d]](T),x=t[u[d]](g)):(h=c[m+d],A=c[T+d],x=c[g+d]);let w=h;A<w&&(w=A),x<w&&(w=x);let b=h;A>b&&(b=A),x>b&&(b=x);const _=(b-w)/2,B=d*2;a[y+B+0]=w+_,a[y+B+1]=_+(Math.abs(w)+_)*Ve,w<n[d]&&(n[d]=w),b>n[d+3]&&(n[d+3]=b)}}return a}const Y=32,je=(e,n)=>e.candidate-n.candidate,Q=new Array(Y).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),Ct=new Float32Array(6);function Ze(e,n,t,s,i,a){let o=-1,c=0;if(a===te)o=Dn(n),o!==-1&&(c=(n[o]+n[o+3])/2);else if(a===Ie)o=Dn(e),o!==-1&&(c=Ye(t,s,i,o));else if(a===ze){const r=xt(e);let p=Kt*i;const u=s*6,f=(s+i)*6;for(let l=0;l<3;l++){const y=n[l],g=(n[l+3]-y)/Y;if(i<Y/4){const d=[...Q];d.length=i;let h=0;for(let x=u;x<f;x+=6,h++){const w=d[h];w.candidate=t[x+2*l],w.count=0;const{bounds:b,leftCacheBounds:_,rightCacheBounds:B}=w;for(let M=0;M<3;M++)B[M]=1/0,B[M+3]=-1/0,_[M]=1/0,_[M+3]=-1/0,b[M]=1/0,b[M+3]=-1/0;vt(x,t,b)}d.sort(je);let A=i;for(let x=0;x<A;x++){const w=d[x];for(;x+1<A&&d[x+1].candidate===w.candidate;)d.splice(x+1,1),A--}for(let x=u;x<f;x+=6){const w=t[x+2*l];for(let b=0;b<A;b++){const _=d[b];w>=_.candidate?vt(x,t,_.rightCacheBounds):(vt(x,t,_.leftCacheBounds),_.count++)}}for(let x=0;x<A;x++){const w=d[x],b=w.count,_=i-w.count,B=w.leftCacheBounds,M=w.rightCacheBounds;let S=0;b!==0&&(S=xt(B)/r);let C=0;_!==0&&(C=xt(M)/r);const P=Fn+Kt*(S*b+C*_);P<p&&(o=l,p=P,c=w.candidate)}}else{for(let A=0;A<Y;A++){const x=Q[A];x.count=0,x.candidate=y+g+A*g;const w=x.bounds;for(let b=0;b<3;b++)w[b]=1/0,w[b+3]=-1/0}for(let A=u;A<f;A+=6){let b=~~((t[A+2*l]-y)/g);b>=Y&&(b=Y-1);const _=Q[b];_.count++,vt(A,t,_.bounds)}const d=Q[Y-1];En(d.bounds,d.rightCacheBounds);for(let A=Y-2;A>=0;A--){const x=Q[A],w=Q[A+1];In(x.bounds,w.rightCacheBounds,x.rightCacheBounds)}let h=0;for(let A=0;A<Y-1;A++){const x=Q[A],w=x.count,b=x.bounds,B=Q[A+1].rightCacheBounds;w!==0&&(h===0?En(b,Ct):In(b,Ct,Ct)),h+=w;let M=0,S=0;h!==0&&(M=xt(Ct)/r);const C=i-h;C!==0&&(S=xt(B)/r);const P=Fn+Kt*(M*h+S*C);P<p&&(o=l,p=P,c=x.candidate)}}}}else console.warn("MeshBVH: Invalid build strategy value ".concat(a," used."));return{axis:o,pos:c}}function Ye(e,n,t,s){let i=0;for(let a=n,o=n+t;a<o;a++)i+=e[a*6+s*2];return i/t}class Ut{constructor(){}}function We(e,n,t,s,i,a){let o=s,c=s+i-1;const r=a.pos,p=a.axis*2;for(;;){for(;o<=c&&t[o*6+p]<r;)o++;for(;o<=c&&t[c*6+p]>=r;)c--;if(o<c){for(let u=0;u<3;u++){let f=n[o*3+u];n[o*3+u]=n[c*3+u],n[c*3+u]=f}for(let u=0;u<6;u++){let f=t[o*6+u];t[o*6+u]=t[c*6+u],t[c*6+u]=f}o++,c--}else return o}}function Ke(e,n,t,s,i,a){let o=s,c=s+i-1;const r=a.pos,p=a.axis*2;for(;;){for(;o<=c&&t[o*6+p]<r;)o++;for(;o<=c&&t[c*6+p]>=r;)c--;if(o<c){let u=e[o];e[o]=e[c],e[c]=u;for(let f=0;f<6;f++){let l=t[o*6+f];t[o*6+f]=t[c*6+f],t[c*6+f]=l}o++,c--}else return o}}function Je(e,n){const t=(e.index?e.index.count:e.attributes.position.count)/3,s=t>2**16,i=s?4:2,a=n?new SharedArrayBuffer(t*i):new ArrayBuffer(t*i),o=s?new Uint32Array(a):new Uint16Array(a);for(let c=0,r=o.length;c<r;c++)o[c]=c;return o}function Qe(e,n){const t=e.geometry,s=t.index?t.index.array:null,i=n.maxDepth,a=n.verbose,o=n.maxLeafTris,c=n.strategy,r=n.onProgress,p=yt(t),u=e._indirectBuffer;let f=!1;const l=new Float32Array(6),y=new Float32Array(6),m=Xe(t,l),T=n.indirect?Ke:We,g=[],d=n.indirect?ne(t):ee(t);if(d.length===1){const x=d[0],w=new Ut;w.boundingData=l,He(m,x.offset,x.count,y),A(w,x.offset,x.count,y),g.push(w)}else for(let x of d){const w=new Ut;w.boundingData=new Float32Array(6),Qt(m,x.offset,x.count,w.boundingData,y),A(w,x.offset,x.count,y),g.push(w)}return g;function h(x){r&&r(x/p)}function A(x,w,b,_=null,B=0){if(!f&&B>=i&&(f=!0,a&&(console.warn("MeshBVH: Max depth of ".concat(i," reached when generating BVH. Consider increasing maxDepth.")),console.warn(t))),b<=o||B>=i)return h(w+b),x.offset=w,x.count=b,x;const M=Ze(x.boundingData,_,m,w,b,c);if(M.axis===-1)return h(w+b),x.offset=w,x.count=b,x;const S=T(u,s,m,w,b,M);if(S===w||S===w+b)h(w+b),x.offset=w,x.count=b;else{x.splitAxis=M.axis;const C=new Ut,P=w,v=S-w;x.left=C,C.boundingData=new Float32Array(6),Qt(m,P,v,C.boundingData,y),A(C,P,v,y,B+1);const L=new Ut,F=S,I=b-v;x.right=L,L.boundingData=new Float32Array(6),Qt(m,F,I,L.boundingData,y),A(L,F,I,y,B+1)}return x}}function Oe(e,n){const t=e.geometry;n.indirect&&(e._indirectBuffer=Je(t,n.useSharedArrayBuffer),qe(t)&&!n.verbose&&console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),e._indirectBuffer||$e(t,n);const s=Qe(e,n);let i,a,o;const c=[],r=n.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let f=0;f<s.length;f++){const l=s[f];let y=p(l);const m=new r(Ht*y);i=new Float32Array(m),a=new Uint32Array(m),o=new Uint16Array(m),u(0,l),c.push(m)}e._roots=c;return;function p(f){return f.count?1:1+p(f.left)+p(f.right)}function u(f,l){const y=f/4,m=f/2,T=!!l.count,g=l.boundingData;for(let d=0;d<6;d++)i[y+d]=g[d];if(T){const d=l.offset,h=l.count;return a[y+6]=d,o[m+14]=h,o[m+15]=Zt,f+Ht}else{const d=l.left,h=l.right,A=l.splitAxis;let x;if(x=u(f+Ht,d),x/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return a[y+6]=x/4,x=u(x,h),a[y+7]=A,x}}}class J{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(n,t){let s=1/0,i=-1/0;for(let a=0,o=n.length;a<o;a++){const r=n[a][t];s=r<s?r:s,i=r>i?r:i}this.min=s,this.max=i}setFromPoints(n,t){let s=1/0,i=-1/0;for(let a=0,o=t.length;a<o;a++){const c=t[a],r=n.dot(c);s=r<s?r:s,i=r>i?r:i}this.min=s,this.max=i}isSeparated(n){return this.min>n.max||n.min>this.max}}J.prototype.setFromBox=function(){const e=new U;return function(t,s){const i=s.min,a=s.max;let o=1/0,c=-1/0;for(let r=0;r<=1;r++)for(let p=0;p<=1;p++)for(let u=0;u<=1;u++){e.x=i.x*r+a.x*(1-r),e.y=i.y*p+a.y*(1-p),e.z=i.z*u+a.z*(1-u);const f=t.dot(e);o=Math.min(f,o),c=Math.max(f,c)}this.min=o,this.max=c}}();const Ge=function(){const e=new U,n=new U,t=new U;return function(i,a,o){const c=i.start,r=e,p=a.start,u=n;t.subVectors(c,p),e.subVectors(i.end,i.start),n.subVectors(a.end,a.start);const f=t.dot(u),l=u.dot(r),y=u.dot(u),m=t.dot(r),g=r.dot(r)*y-l*l;let d,h;g!==0?d=(f*l-m*y)/g:d=0,h=(f+d*l)/y,o.x=d,o.y=h}}(),wn=function(){const e=new pt,n=new U,t=new U;return function(i,a,o,c){Ge(i,a,e);let r=e.x,p=e.y;if(r>=0&&r<=1&&p>=0&&p<=1){i.at(r,o),a.at(p,c);return}else if(r>=0&&r<=1){p<0?a.at(0,c):a.at(1,c),i.closestPointToPoint(c,!0,o);return}else if(p>=0&&p<=1){r<0?i.at(0,o):i.at(1,o),a.closestPointToPoint(o,!0,c);return}else{let u;r<0?u=i.start:u=i.end;let f;p<0?f=a.start:f=a.end;const l=n,y=t;if(i.closestPointToPoint(f,!0,n),a.closestPointToPoint(u,!0,t),l.distanceToSquared(f)<=y.distanceToSquared(u)){o.copy(l),c.copy(f);return}else{o.copy(u),c.copy(y);return}}}}(),ts=function(){const e=new U,n=new U,t=new Jn,s=new W;return function(a,o){const{radius:c,center:r}=a,{a:p,b:u,c:f}=o;if(s.start=p,s.end=u,s.closestPointToPoint(r,!0,e).distanceTo(r)<=c||(s.start=p,s.end=f,s.closestPointToPoint(r,!0,e).distanceTo(r)<=c)||(s.start=u,s.end=f,s.closestPointToPoint(r,!0,e).distanceTo(r)<=c))return!0;const T=o.getPlane(t);if(Math.abs(T.distanceToPoint(r))<=c){const d=T.projectPoint(r,n);if(o.containsPoint(d))return!0}return!1}}(),ns=1e-15;function Ot(e){return Math.abs(e)<ns}class j extends Bt{constructor(...n){super(...n),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new U),this.satBounds=new Array(4).fill().map(()=>new J),this.points=[this.a,this.b,this.c],this.sphere=new ue,this.plane=new Jn,this.needsUpdate=!0}intersectsSphere(n){return ts(n,this)}update(){const n=this.a,t=this.b,s=this.c,i=this.points,a=this.satAxes,o=this.satBounds,c=a[0],r=o[0];this.getNormal(c),r.setFromPoints(c,i);const p=a[1],u=o[1];p.subVectors(n,t),u.setFromPoints(p,i);const f=a[2],l=o[2];f.subVectors(t,s),l.setFromPoints(f,i);const y=a[3],m=o[3];y.subVectors(s,n),m.setFromPoints(y,i),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(c,n),this.needsUpdate=!1}}j.prototype.closestPointToSegment=function(){const e=new U,n=new U,t=new W;return function(i,a=null,o=null){const{start:c,end:r}=i,p=this.points;let u,f=1/0;for(let l=0;l<3;l++){const y=(l+1)%3;t.start.copy(p[l]),t.end.copy(p[y]),wn(t,i,e,n),u=e.distanceToSquared(n),u<f&&(f=u,a&&a.copy(e),o&&o.copy(n))}return this.closestPointToPoint(c,e),u=c.distanceToSquared(e),u<f&&(f=u,a&&a.copy(e),o&&o.copy(c)),this.closestPointToPoint(r,e),u=r.distanceToSquared(e),u<f&&(f=u,a&&a.copy(e),o&&o.copy(r)),Math.sqrt(f)}}();j.prototype.intersectsTriangle=function(){const e=new j,n=new Array(3),t=new Array(3),s=new J,i=new J,a=new U,o=new U,c=new U,r=new U,p=new U,u=new W,f=new W,l=new W,y=new U;function m(T,g,d){const h=T.points;let A=0,x=-1;for(let w=0;w<3;w++){const{start:b,end:_}=u;b.copy(h[w]),_.copy(h[(w+1)%3]),u.delta(o);const B=Ot(g.distanceToPoint(b));if(Ot(g.normal.dot(o))&&B){d.copy(u),A=2;break}const M=g.intersectLine(u,y);if(!M&&B&&y.copy(b),(M||B)&&!Ot(y.distanceTo(_))){if(A<=1)(A===1?d.start:d.end).copy(y),B&&(x=A);else if(A>=2){(x===1?d.start:d.end).copy(y),A=2;break}if(A++,A===2&&x===-1)break}}return A}return function(g,d=null,h=!1){this.needsUpdate&&this.update(),g.isExtendedTriangle?g.needsUpdate&&g.update():(e.copy(g),e.update(),g=e);const A=this.plane,x=g.plane;if(Math.abs(A.normal.dot(x.normal))>1-1e-10){const w=this.satBounds,b=this.satAxes;t[0]=g.a,t[1]=g.b,t[2]=g.c;for(let M=0;M<4;M++){const S=w[M],C=b[M];if(s.setFromPoints(C,t),S.isSeparated(s))return!1}const _=g.satBounds,B=g.satAxes;n[0]=this.a,n[1]=this.b,n[2]=this.c;for(let M=0;M<4;M++){const S=_[M],C=B[M];if(s.setFromPoints(C,n),S.isSeparated(s))return!1}for(let M=0;M<4;M++){const S=b[M];for(let C=0;C<4;C++){const P=B[C];if(a.crossVectors(S,P),s.setFromPoints(a,n),i.setFromPoints(a,t),s.isSeparated(i))return!1}}return d&&(h||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),d.start.set(0,0,0),d.end.set(0,0,0)),!0}else{const w=m(this,x,f);if(w===1&&g.containsPoint(f.end))return d&&(d.start.copy(f.end),d.end.copy(f.end)),!0;if(w!==2)return!1;const b=m(g,A,l);if(b===1&&this.containsPoint(l.end))return d&&(d.start.copy(l.end),d.end.copy(l.end)),!0;if(b!==2)return!1;if(f.delta(c),l.delta(r),c.dot(r)<0){let v=l.start;l.start=l.end,l.end=v}const _=f.start.dot(c),B=f.end.dot(c),M=l.start.dot(c),S=l.end.dot(c),C=B<M,P=_<S;return _!==S&&M!==B&&C===P?!1:(d&&(p.subVectors(f.start,l.start),p.dot(c)>0?d.start.copy(f.start):d.start.copy(l.start),p.subVectors(f.end,l.end),p.dot(c)<0?d.end.copy(f.end):d.end.copy(l.end)),!0)}}}();j.prototype.distanceToPoint=function(){const e=new U;return function(t){return this.closestPointToPoint(t,e),t.distanceTo(e)}}();j.prototype.distanceToTriangle=function(){const e=new U,n=new U,t=["a","b","c"],s=new W,i=new W;return function(o,c=null,r=null){const p=c||r?s:null;if(this.intersectsTriangle(o,p))return(c||r)&&(c&&p.getCenter(c),r&&p.getCenter(r)),0;let u=1/0;for(let f=0;f<3;f++){let l;const y=t[f],m=o[y];this.closestPointToPoint(m,e),l=m.distanceToSquared(e),l<u&&(u=l,c&&c.copy(e),r&&r.copy(m));const T=this[y];o.closestPointToPoint(T,e),l=T.distanceToSquared(e),l<u&&(u=l,c&&c.copy(T),r&&r.copy(e))}for(let f=0;f<3;f++){const l=t[f],y=t[(f+1)%3];s.set(this[l],this[y]);for(let m=0;m<3;m++){const T=t[m],g=t[(m+1)%3];i.set(o[T],o[g]),wn(s,i,e,n);const d=e.distanceToSquared(n);d<u&&(u=d,c&&c.copy(e),r&&r.copy(n))}}return Math.sqrt(u)}}();class V{constructor(n,t,s){this.isOrientedBox=!0,this.min=new U,this.max=new U,this.matrix=new K,this.invMatrix=new K,this.points=new Array(8).fill().map(()=>new U),this.satAxes=new Array(3).fill().map(()=>new U),this.satBounds=new Array(3).fill().map(()=>new J),this.alignedSatBounds=new Array(3).fill().map(()=>new J),this.needsUpdate=!1,n&&this.min.copy(n),t&&this.max.copy(t),s&&this.matrix.copy(s)}set(n,t,s){this.min.copy(n),this.max.copy(t),this.matrix.copy(s),this.needsUpdate=!0}copy(n){this.min.copy(n.min),this.max.copy(n.max),this.matrix.copy(n.matrix),this.needsUpdate=!0}}V.prototype.update=function(){return function(){const n=this.matrix,t=this.min,s=this.max,i=this.points;for(let p=0;p<=1;p++)for(let u=0;u<=1;u++)for(let f=0;f<=1;f++){const l=1*p|2*u|4*f,y=i[l];y.x=p?s.x:t.x,y.y=u?s.y:t.y,y.z=f?s.z:t.z,y.applyMatrix4(n)}const a=this.satBounds,o=this.satAxes,c=i[0];for(let p=0;p<3;p++){const u=o[p],f=a[p],l=1<<p,y=i[l];u.subVectors(c,y),f.setFromPoints(u,i)}const r=this.alignedSatBounds;r[0].setFromPointsField(i,"x"),r[1].setFromPointsField(i,"y"),r[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();V.prototype.intersectsBox=function(){const e=new J;return function(t){this.needsUpdate&&this.update();const s=t.min,i=t.max,a=this.satBounds,o=this.satAxes,c=this.alignedSatBounds;if(e.min=s.x,e.max=i.x,c[0].isSeparated(e)||(e.min=s.y,e.max=i.y,c[1].isSeparated(e))||(e.min=s.z,e.max=i.z,c[2].isSeparated(e)))return!1;for(let r=0;r<3;r++){const p=o[r],u=a[r];if(e.setFromBox(p,t),u.isSeparated(e))return!1}return!0}}();V.prototype.intersectsTriangle=function(){const e=new j,n=new Array(3),t=new J,s=new J,i=new U;return function(o){this.needsUpdate&&this.update(),o.isExtendedTriangle?o.needsUpdate&&o.update():(e.copy(o),e.update(),o=e);const c=this.satBounds,r=this.satAxes;n[0]=o.a,n[1]=o.b,n[2]=o.c;for(let l=0;l<3;l++){const y=c[l],m=r[l];if(t.setFromPoints(m,n),y.isSeparated(t))return!1}const p=o.satBounds,u=o.satAxes,f=this.points;for(let l=0;l<3;l++){const y=p[l],m=u[l];if(t.setFromPoints(m,f),y.isSeparated(t))return!1}for(let l=0;l<3;l++){const y=r[l];for(let m=0;m<4;m++){const T=u[m];if(i.crossVectors(y,T),t.setFromPoints(i,n),s.setFromPoints(i,f),t.isSeparated(s))return!1}}return!0}}();V.prototype.closestPointToPoint=function(){return function(n,t){return this.needsUpdate&&this.update(),t.copy(n).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),t}}();V.prototype.distanceToPoint=function(){const e=new U;return function(t){return this.closestPointToPoint(t,e),t.distanceTo(e)}}();V.prototype.distanceToBox=function(){const e=["x","y","z"],n=new Array(12).fill().map(()=>new W),t=new Array(12).fill().map(()=>new W),s=new U,i=new U;return function(o,c=0,r=null,p=null){if(this.needsUpdate&&this.update(),this.intersectsBox(o))return(r||p)&&(o.getCenter(i),this.closestPointToPoint(i,s),o.closestPointToPoint(s,i),r&&r.copy(s),p&&p.copy(i)),0;const u=c*c,f=o.min,l=o.max,y=this.points;let m=1/0;for(let g=0;g<8;g++){const d=y[g];i.copy(d).clamp(f,l);const h=d.distanceToSquared(i);if(h<m&&(m=h,r&&r.copy(d),p&&p.copy(i),h<u))return Math.sqrt(h)}let T=0;for(let g=0;g<3;g++)for(let d=0;d<=1;d++)for(let h=0;h<=1;h++){const A=(g+1)%3,x=(g+2)%3,w=d<<A|h<<x,b=1<<g|d<<A|h<<x,_=y[w],B=y[b];n[T].set(_,B);const S=e[g],C=e[A],P=e[x],v=t[T],L=v.start,F=v.end;L[S]=f[S],L[C]=d?f[C]:l[C],L[P]=h?f[P]:l[C],F[S]=l[S],F[C]=d?f[C]:l[C],F[P]=h?f[P]:l[C],T++}for(let g=0;g<=1;g++)for(let d=0;d<=1;d++)for(let h=0;h<=1;h++){i.x=g?l.x:f.x,i.y=d?l.y:f.y,i.z=h?l.z:f.z,this.closestPointToPoint(i,s);const A=i.distanceToSquared(s);if(A<m&&(m=A,r&&r.copy(s),p&&p.copy(i),A<u))return Math.sqrt(A)}for(let g=0;g<12;g++){const d=n[g];for(let h=0;h<12;h++){const A=t[h];wn(d,A,s,i);const x=s.distanceToSquared(i);if(x<m&&(m=x,r&&r.copy(s),p&&p.copy(i),x<u))return Math.sqrt(x)}}return Math.sqrt(m)}}();class An{constructor(n){this._getNewPrimitive=n,this._primitives=[]}getPrimitive(){const n=this._primitives;return n.length===0?this._getNewPrimitive():n.pop()}releasePrimitive(n){this._primitives.push(n)}}class es extends An{constructor(){super(()=>new j)}}const $=new es;function R(e,n){return n[e+15]===65535}function N(e,n){return n[e+6]}function q(e,n){return n[e+14]}function k(e){return e+8}function H(e,n){return n[e+6]}function se(e,n){return n[e+7]}class ss{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const n=[];let t=null;this.setBuffer=s=>{t&&n.push(t),t=s,this.float32Array=new Float32Array(s),this.uint16Array=new Uint16Array(s),this.uint32Array=new Uint32Array(s)},this.clearBuffer=()=>{t=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,n.length!==0&&this.setBuffer(n.pop())}}}const D=new ss;let G,ft;const nt=[],Lt=new An(()=>new Z);function is(e,n,t,s,i,a){G=Lt.getPrimitive(),ft=Lt.getPrimitive(),nt.push(G,ft),D.setBuffer(e._roots[n]);const o=ln(0,e.geometry,t,s,i,a);D.clearBuffer(),Lt.releasePrimitive(G),Lt.releasePrimitive(ft),nt.pop(),nt.pop();const c=nt.length;return c>0&&(ft=nt[c-1],G=nt[c-2]),o}function ln(e,n,t,s,i=null,a=0,o=0){const{float32Array:c,uint16Array:r,uint32Array:p}=D;let u=e*2;if(R(u,r)){const l=N(e,p),y=q(u,r);return E(e,c,G),s(l,y,!1,o,a+e,G)}else{let S=function(P){const{uint16Array:v,uint32Array:L}=D;let F=P*2;for(;!R(F,v);)P=k(P),F=P*2;return N(P,L)},C=function(P){const{uint16Array:v,uint32Array:L}=D;let F=P*2;for(;!R(F,v);)P=H(P,L),F=P*2;return N(P,L)+q(F,v)};const l=k(e),y=H(e,p);let m=l,T=y,g,d,h,A;if(i&&(h=G,A=ft,E(m,c,h),E(T,c,A),g=i(h),d=i(A),d<g)){m=y,T=l;const P=g;g=d,d=P,h=A}h||(h=G,E(m,c,h));const x=R(m*2,r),w=t(h,x,g,o+1,a+m);let b;if(w===Ln){const P=S(m),L=C(m)-P;b=s(P,L,!0,o+1,a+m,h)}else b=w&&ln(m,n,t,s,i,a,o+1);if(b)return!0;A=ft,E(T,c,A);const _=R(T*2,r),B=t(A,_,d,o+1,a+T);let M;if(B===Ln){const P=S(T),L=C(T)-P;M=s(P,L,!0,o+1,a+T,A)}else M=B&&ln(T,n,t,s,i,a,o+1);return!!M}}const wt=new U,Gt=new U;function os(e,n,t={},s=0,i=1/0){const a=s*s,o=i*i;let c=1/0,r=null;if(e.shapecast({boundsTraverseOrder:u=>(wt.copy(n).clamp(u.min,u.max),wt.distanceToSquared(n)),intersectsBounds:(u,f,l)=>l<c&&l<o,intersectsTriangle:(u,f)=>{u.closestPointToPoint(n,wt);const l=n.distanceToSquared(wt);return l<c&&(Gt.copy(wt),c=l,r=f),l<a}}),c===1/0)return null;const p=Math.sqrt(c);return t.point?t.point.copy(Gt):t.point=Gt.clone(),t.distance=p,t.faceIndex=r,t}const et=new U,st=new U,it=new U,Ft=new pt,Dt=new pt,Et=new pt,zn=new U,Vn=new U,Rn=new U,It=new U;function rs(e,n,t,s,i,a){let o;return a===fe?o=e.intersectTriangle(s,t,n,!0,i):o=e.intersectTriangle(n,t,s,a!==Qn,i),o===null?null:{distance:e.origin.distanceTo(i),point:i.clone()}}function cs(e,n,t,s,i,a,o,c,r){et.fromBufferAttribute(n,a),st.fromBufferAttribute(n,o),it.fromBufferAttribute(n,c);const p=rs(e,et,st,it,It,r);if(p){s&&(Ft.fromBufferAttribute(s,a),Dt.fromBufferAttribute(s,o),Et.fromBufferAttribute(s,c),p.uv=Bt.getInterpolation(It,et,st,it,Ft,Dt,Et,new pt)),i&&(Ft.fromBufferAttribute(i,a),Dt.fromBufferAttribute(i,o),Et.fromBufferAttribute(i,c),p.uv1=Bt.getInterpolation(It,et,st,it,Ft,Dt,Et,new pt)),t&&(zn.fromBufferAttribute(t,a),Vn.fromBufferAttribute(t,o),Rn.fromBufferAttribute(t,c),p.normal=Bt.getInterpolation(It,et,st,it,zn,Vn,Rn,new U),p.normal.dot(e.direction)>0&&p.normal.multiplyScalar(-1));const u={a,b:o,c,normal:new U,materialIndex:0};Bt.getNormal(et,st,it,u.normal),p.face=u,p.faceIndex=a}return p}function Yt(e,n,t,s,i){const a=s*3;let o=a+0,c=a+1,r=a+2;const p=e.index;e.index&&(o=p.getX(o),c=p.getX(c),r=p.getX(r));const{position:u,normal:f,uv:l,uv1:y}=e.attributes,m=cs(t,u,f,l,y,o,c,r,n);return m?(m.faceIndex=s,i&&i.push(m),m):null}function z(e,n,t,s){const i=e.a,a=e.b,o=e.c;let c=n,r=n+1,p=n+2;t&&(c=t.getX(c),r=t.getX(r),p=t.getX(p)),i.x=s.getX(c),i.y=s.getY(c),i.z=s.getZ(c),a.x=s.getX(r),a.y=s.getY(r),a.z=s.getZ(r),o.x=s.getX(p),o.y=s.getY(p),o.z=s.getZ(p)}function as(e,n,t,s,i,a){const{geometry:o,_indirectBuffer:c}=e;for(let r=s,p=s+i;r<p;r++)Yt(o,n,t,r,a)}function ls(e,n,t,s,i){const{geometry:a,_indirectBuffer:o}=e;let c=1/0,r=null;for(let p=s,u=s+i;p<u;p++){let f;f=Yt(a,n,t,p),f&&f.distance<c&&(r=f,c=f.distance)}return r}function us(e,n,t,s,i,a,o){const{geometry:c}=t,{index:r}=c,p=c.attributes.position;for(let u=e,f=n+e;u<f;u++){let l;if(l=u,z(o,l*3,r,p),o.needsUpdate=!0,s(o,l,i,a))return!0}return!1}function fs(e,n=null){n&&Array.isArray(n)&&(n=new Set(n));const t=e.geometry,s=t.index?t.index.array:null,i=t.attributes.position;let a,o,c,r,p=0;const u=e._roots;for(let l=0,y=u.length;l<y;l++)a=u[l],o=new Uint32Array(a),c=new Uint16Array(a),r=new Float32Array(a),f(0,p),p+=a.byteLength;function f(l,y,m=!1){const T=l*2;if(c[T+15]===Zt){const d=o[l+6],h=c[T+14];let A=1/0,x=1/0,w=1/0,b=-1/0,_=-1/0,B=-1/0;for(let M=3*d,S=3*(d+h);M<S;M++){let C=s[M];const P=i.getX(C),v=i.getY(C),L=i.getZ(C);P<A&&(A=P),P>b&&(b=P),v<x&&(x=v),v>_&&(_=v),L<w&&(w=L),L>B&&(B=L)}return r[l+0]!==A||r[l+1]!==x||r[l+2]!==w||r[l+3]!==b||r[l+4]!==_||r[l+5]!==B?(r[l+0]=A,r[l+1]=x,r[l+2]=w,r[l+3]=b,r[l+4]=_,r[l+5]=B,!0):!1}else{const d=l+8,h=o[l+6],A=d+y,x=h+y;let w=m,b=!1,_=!1;n?w||(b=n.has(A),_=n.has(x),w=!b&&!_):(b=!0,_=!0);const B=w||b,M=w||_;let S=!1;B&&(S=f(d,y,w));let C=!1;M&&(C=f(h,y,w));const P=S||C;if(P)for(let v=0;v<3;v++){const L=d+v,F=h+v,I=r[L],dt=r[L+3],mt=r[F],ht=r[F+3];r[l+v]=I<mt?I:mt,r[l+v+3]=dt>ht?dt:ht}return P}}}const Nn=new Z;function tt(e,n,t,s){return E(e,n,Nn),t.intersectBox(Nn,s)}function ps(e,n,t,s,i,a){const{geometry:o,_indirectBuffer:c}=e;for(let r=s,p=s+i;r<p;r++){let u=c?c[r]:r;Yt(o,n,t,u,a)}}function ys(e,n,t,s,i){const{geometry:a,_indirectBuffer:o}=e;let c=1/0,r=null;for(let p=s,u=s+i;p<u;p++){let f;f=Yt(a,n,t,o?o[p]:p),f&&f.distance<c&&(r=f,c=f.distance)}return r}function ds(e,n,t,s,i,a,o){const{geometry:c}=t,{index:r}=c,p=c.attributes.position;for(let u=e,f=n+e;u<f;u++){let l;if(l=t.resolveTriangleIndex(u),z(o,l*3,r,p),o.needsUpdate=!0,s(o,l,i,a))return!0}return!1}const $n=new U;function ms(e,n,t,s,i){D.setBuffer(e._roots[n]),un(0,e,t,s,i),D.clearBuffer()}function un(e,n,t,s,i){const{float32Array:a,uint16Array:o,uint32Array:c}=D,r=e*2;if(R(r,o)){const u=N(e,c),f=q(r,o);as(n,t,s,u,f,i)}else{const u=k(e);tt(u,a,s,$n)&&un(u,n,t,s,i);const f=H(e,c);tt(f,a,s,$n)&&un(f,n,t,s,i)}}const qn=new U,hs=["x","y","z"];function xs(e,n,t,s){D.setBuffer(e._roots[n]);const i=fn(0,e,t,s);return D.clearBuffer(),i}function fn(e,n,t,s){const{float32Array:i,uint16Array:a,uint32Array:o}=D;let c=e*2;if(R(c,a)){const p=N(e,o),u=q(c,a);return ls(n,t,s,p,u)}else{const p=se(e,o),u=hs[p],l=s.direction[u]>=0;let y,m;l?(y=k(e),m=H(e,o)):(y=H(e,o),m=k(e));const g=tt(y,i,s,qn)?fn(y,n,t,s):null;if(g){const A=g.point[u];if(l?A<=i[m+p]:A>=i[m+p+3])return g}const h=tt(m,i,s,qn)?fn(m,n,t,s):null;return g&&h?g.distance<=h.distance?g:h:g||h||null}}const zt=new Z,ot=new j,rt=new j,At=new K,kn=new V,Vt=new V;function ws(e,n,t,s){D.setBuffer(e._roots[n]);const i=pn(0,e,t,s);return D.clearBuffer(),i}function pn(e,n,t,s,i=null){const{float32Array:a,uint16Array:o,uint32Array:c}=D;let r=e*2;if(i===null&&(t.boundingBox||t.computeBoundingBox(),kn.set(t.boundingBox.min,t.boundingBox.max,s),i=kn),R(r,o)){const u=n.geometry,f=u.index,l=u.attributes.position,y=t.index,m=t.attributes.position,T=N(e,c),g=q(r,o);if(At.copy(s).invert(),t.boundsTree)return E(e,a,Vt),Vt.matrix.copy(At),Vt.needsUpdate=!0,t.boundsTree.shapecast({intersectsBounds:h=>Vt.intersectsBox(h),intersectsTriangle:h=>{h.a.applyMatrix4(s),h.b.applyMatrix4(s),h.c.applyMatrix4(s),h.needsUpdate=!0;for(let A=T*3,x=(g+T)*3;A<x;A+=3)if(z(rt,A,f,l),rt.needsUpdate=!0,h.intersectsTriangle(rt))return!0;return!1}});for(let d=T*3,h=(g+T)*3;d<h;d+=3){z(ot,d,f,l),ot.a.applyMatrix4(At),ot.b.applyMatrix4(At),ot.c.applyMatrix4(At),ot.needsUpdate=!0;for(let A=0,x=y.count;A<x;A+=3)if(z(rt,A,y,m),rt.needsUpdate=!0,ot.intersectsTriangle(rt))return!0}}else{const u=e+8,f=c[e+6];return E(u,a,zt),!!(i.intersectsBox(zt)&&pn(u,n,t,s,i)||(E(f,a,zt),i.intersectsBox(zt)&&pn(f,n,t,s,i)))}}const Rt=new K,tn=new V,gt=new V,As=new U,gs=new U,bs=new U,Ts=new U;function Bs(e,n,t,s={},i={},a=0,o=1/0){n.boundingBox||n.computeBoundingBox(),tn.set(n.boundingBox.min,n.boundingBox.max,t),tn.needsUpdate=!0;const c=e.geometry,r=c.attributes.position,p=c.index,u=n.attributes.position,f=n.index,l=$.getPrimitive(),y=$.getPrimitive();let m=As,T=gs,g=null,d=null;i&&(g=bs,d=Ts);let h=1/0,A=null,x=null;return Rt.copy(t).invert(),gt.matrix.copy(Rt),e.shapecast({boundsTraverseOrder:w=>tn.distanceToBox(w),intersectsBounds:(w,b,_)=>_<h&&_<o?(b&&(gt.min.copy(w.min),gt.max.copy(w.max),gt.needsUpdate=!0),!0):!1,intersectsRange:(w,b)=>{if(n.boundsTree)return n.boundsTree.shapecast({boundsTraverseOrder:B=>gt.distanceToBox(B),intersectsBounds:(B,M,S)=>S<h&&S<o,intersectsRange:(B,M)=>{for(let S=B,C=B+M;S<C;S++){z(y,3*S,f,u),y.a.applyMatrix4(t),y.b.applyMatrix4(t),y.c.applyMatrix4(t),y.needsUpdate=!0;for(let P=w,v=w+b;P<v;P++){z(l,3*P,p,r),l.needsUpdate=!0;const L=l.distanceToTriangle(y,m,g);if(L<h&&(T.copy(m),d&&d.copy(g),h=L,A=P,x=S),L<a)return!0}}}});{const _=yt(n);for(let B=0,M=_;B<M;B++){z(y,3*B,f,u),y.a.applyMatrix4(t),y.b.applyMatrix4(t),y.c.applyMatrix4(t),y.needsUpdate=!0;for(let S=w,C=w+b;S<C;S++){z(l,3*S,p,r),l.needsUpdate=!0;const P=l.distanceToTriangle(y,m,g);if(P<h&&(T.copy(m),d&&d.copy(g),h=P,A=S,x=B),P<a)return!0}}}}}),$.releasePrimitive(l),$.releasePrimitive(y),h===1/0?null:(s.point?s.point.copy(T):s.point=T.clone(),s.distance=h,s.faceIndex=A,i&&(i.point?i.point.copy(d):i.point=d.clone(),i.point.applyMatrix4(Rt),T.applyMatrix4(Rt),i.distance=T.sub(i.point).length(),i.faceIndex=x),s)}function Ps(e,n=null){n&&Array.isArray(n)&&(n=new Set(n));const t=e.geometry,s=t.index?t.index.array:null,i=t.attributes.position;let a,o,c,r,p=0;const u=e._roots;for(let l=0,y=u.length;l<y;l++)a=u[l],o=new Uint32Array(a),c=new Uint16Array(a),r=new Float32Array(a),f(0,p),p+=a.byteLength;function f(l,y,m=!1){const T=l*2;if(c[T+15]===Zt){const d=o[l+6],h=c[T+14];let A=1/0,x=1/0,w=1/0,b=-1/0,_=-1/0,B=-1/0;for(let M=d,S=d+h;M<S;M++){const C=3*e.resolveTriangleIndex(M);for(let P=0;P<3;P++){let v=C+P;v=s?s[v]:v;const L=i.getX(v),F=i.getY(v),I=i.getZ(v);L<A&&(A=L),L>b&&(b=L),F<x&&(x=F),F>_&&(_=F),I<w&&(w=I),I>B&&(B=I)}}return r[l+0]!==A||r[l+1]!==x||r[l+2]!==w||r[l+3]!==b||r[l+4]!==_||r[l+5]!==B?(r[l+0]=A,r[l+1]=x,r[l+2]=w,r[l+3]=b,r[l+4]=_,r[l+5]=B,!0):!1}else{const d=l+8,h=o[l+6],A=d+y,x=h+y;let w=m,b=!1,_=!1;n?w||(b=n.has(A),_=n.has(x),w=!b&&!_):(b=!0,_=!0);const B=w||b,M=w||_;let S=!1;B&&(S=f(d,y,w));let C=!1;M&&(C=f(h,y,w));const P=S||C;if(P)for(let v=0;v<3;v++){const L=d+v,F=h+v,I=r[L],dt=r[L+3],mt=r[F],ht=r[F+3];r[l+v]=I<mt?I:mt,r[l+v+3]=dt>ht?dt:ht}return P}}}const Hn=new U;function _s(e,n,t,s,i){D.setBuffer(e._roots[n]),yn(0,e,t,s,i),D.clearBuffer()}function yn(e,n,t,s,i){const{float32Array:a,uint16Array:o,uint32Array:c}=D,r=e*2;if(R(r,o)){const u=N(e,c),f=q(r,o);ps(n,t,s,u,f,i)}else{const u=k(e);tt(u,a,s,Hn)&&yn(u,n,t,s,i);const f=H(e,c);tt(f,a,s,Hn)&&yn(f,n,t,s,i)}}const Xn=new U,Ms=["x","y","z"];function Ss(e,n,t,s){D.setBuffer(e._roots[n]);const i=dn(0,e,t,s);return D.clearBuffer(),i}function dn(e,n,t,s){const{float32Array:i,uint16Array:a,uint32Array:o}=D;let c=e*2;if(R(c,a)){const p=N(e,o),u=q(c,a);return ys(n,t,s,p,u)}else{const p=se(e,o),u=Ms[p],l=s.direction[u]>=0;let y,m;l?(y=k(e),m=H(e,o)):(y=H(e,o),m=k(e));const g=tt(y,i,s,Xn)?dn(y,n,t,s):null;if(g){const A=g.point[u];if(l?A<=i[m+p]:A>=i[m+p+3])return g}const h=tt(m,i,s,Xn)?dn(m,n,t,s):null;return g&&h?g.distance<=h.distance?g:h:g||h||null}}const Nt=new Z,ct=new j,at=new j,bt=new K,jn=new V,$t=new V;function vs(e,n,t,s){D.setBuffer(e._roots[n]);const i=mn(0,e,t,s);return D.clearBuffer(),i}function mn(e,n,t,s,i=null){const{float32Array:a,uint16Array:o,uint32Array:c}=D;let r=e*2;if(i===null&&(t.boundingBox||t.computeBoundingBox(),jn.set(t.boundingBox.min,t.boundingBox.max,s),i=jn),R(r,o)){const u=n.geometry,f=u.index,l=u.attributes.position,y=t.index,m=t.attributes.position,T=N(e,c),g=q(r,o);if(bt.copy(s).invert(),t.boundsTree)return E(e,a,$t),$t.matrix.copy(bt),$t.needsUpdate=!0,t.boundsTree.shapecast({intersectsBounds:h=>$t.intersectsBox(h),intersectsTriangle:h=>{h.a.applyMatrix4(s),h.b.applyMatrix4(s),h.c.applyMatrix4(s),h.needsUpdate=!0;for(let A=T,x=g+T;A<x;A++)if(z(at,3*n.resolveTriangleIndex(A),f,l),at.needsUpdate=!0,h.intersectsTriangle(at))return!0;return!1}});for(let d=T,h=g+T;d<h;d++){const A=n.resolveTriangleIndex(d);z(ct,3*A,f,l),ct.a.applyMatrix4(bt),ct.b.applyMatrix4(bt),ct.c.applyMatrix4(bt),ct.needsUpdate=!0;for(let x=0,w=y.count;x<w;x+=3)if(z(at,x,y,m),at.needsUpdate=!0,ct.intersectsTriangle(at))return!0}}else{const u=e+8,f=c[e+6];return E(u,a,Nt),!!(i.intersectsBox(Nt)&&mn(u,n,t,s,i)||(E(f,a,Nt),i.intersectsBox(Nt)&&mn(f,n,t,s,i)))}}const qt=new K,nn=new V,Tt=new V,Cs=new U,Us=new U,Ls=new U,Fs=new U;function Ds(e,n,t,s={},i={},a=0,o=1/0){n.boundingBox||n.computeBoundingBox(),nn.set(n.boundingBox.min,n.boundingBox.max,t),nn.needsUpdate=!0;const c=e.geometry,r=c.attributes.position,p=c.index,u=n.attributes.position,f=n.index,l=$.getPrimitive(),y=$.getPrimitive();let m=Cs,T=Us,g=null,d=null;i&&(g=Ls,d=Fs);let h=1/0,A=null,x=null;return qt.copy(t).invert(),Tt.matrix.copy(qt),e.shapecast({boundsTraverseOrder:w=>nn.distanceToBox(w),intersectsBounds:(w,b,_)=>_<h&&_<o?(b&&(Tt.min.copy(w.min),Tt.max.copy(w.max),Tt.needsUpdate=!0),!0):!1,intersectsRange:(w,b)=>{if(n.boundsTree){const _=n.boundsTree;return _.shapecast({boundsTraverseOrder:B=>Tt.distanceToBox(B),intersectsBounds:(B,M,S)=>S<h&&S<o,intersectsRange:(B,M)=>{for(let S=B,C=B+M;S<C;S++){const P=_.resolveTriangleIndex(S);z(y,3*P,f,u),y.a.applyMatrix4(t),y.b.applyMatrix4(t),y.c.applyMatrix4(t),y.needsUpdate=!0;for(let v=w,L=w+b;v<L;v++){const F=e.resolveTriangleIndex(v);z(l,3*F,p,r),l.needsUpdate=!0;const I=l.distanceToTriangle(y,m,g);if(I<h&&(T.copy(m),d&&d.copy(g),h=I,A=v,x=S),I<a)return!0}}}})}else{const _=yt(n);for(let B=0,M=_;B<M;B++){z(y,3*B,f,u),y.a.applyMatrix4(t),y.b.applyMatrix4(t),y.c.applyMatrix4(t),y.needsUpdate=!0;for(let S=w,C=w+b;S<C;S++){const P=e.resolveTriangleIndex(S);z(l,3*P,p,r),l.needsUpdate=!0;const v=l.distanceToTriangle(y,m,g);if(v<h&&(T.copy(m),d&&d.copy(g),h=v,A=S,x=B),v<a)return!0}}}}}),$.releasePrimitive(l),$.releasePrimitive(y),h===1/0?null:(s.point?s.point.copy(T):s.point=T.clone(),s.distance=h,s.faceIndex=A,i&&(i.point?i.point.copy(d):i.point=d.clone(),i.point.applyMatrix4(qt),T.applyMatrix4(qt),i.distance=T.sub(i.point).length(),i.faceIndex=x),s)}function Es(){return typeof SharedArrayBuffer<"u"}const Pt=new D.constructor,jt=new D.constructor,O=new An(()=>new Z),lt=new Z,ut=new Z,en=new Z,sn=new Z;let on=!1;function Is(e,n,t,s){if(on)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");on=!0;const i=e._roots,a=n._roots;let o,c=0,r=0;const p=new K().copy(t).invert();for(let u=0,f=i.length;u<f;u++){Pt.setBuffer(i[u]),r=0;const l=O.getPrimitive();E(0,Pt.float32Array,l),l.applyMatrix4(p);for(let y=0,m=a.length;y<m&&(jt.setBuffer(a[u]),o=X(0,0,t,p,s,c,r,0,0,l),jt.clearBuffer(),r+=a[y].length,!o);y++);if(O.releasePrimitive(l),Pt.clearBuffer(),c+=i[u].length,o)break}return on=!1,o}function X(e,n,t,s,i,a=0,o=0,c=0,r=0,p=null,u=!1){let f,l;u?(f=jt,l=Pt):(f=Pt,l=jt);const y=f.float32Array,m=f.uint32Array,T=f.uint16Array,g=l.float32Array,d=l.uint32Array,h=l.uint16Array,A=e*2,x=n*2,w=R(A,T),b=R(x,h);let _=!1;if(b&&w)u?_=i(N(n,d),q(n*2,h),N(e,m),q(e*2,T),r,o+n,c,a+e):_=i(N(e,m),q(e*2,T),N(n,d),q(n*2,h),c,a+e,r,o+n);else if(b){const B=O.getPrimitive();E(n,g,B),B.applyMatrix4(t);const M=k(e),S=H(e,m);E(M,y,lt),E(S,y,ut);const C=B.intersectsBox(lt),P=B.intersectsBox(ut);_=C&&X(n,M,s,t,i,o,a,r,c+1,B,!u)||P&&X(n,S,s,t,i,o,a,r,c+1,B,!u),O.releasePrimitive(B)}else{const B=k(n),M=H(n,d);E(B,g,en),E(M,g,sn);const S=p.intersectsBox(en),C=p.intersectsBox(sn);if(S&&C)_=X(e,B,t,s,i,a,o,c,r+1,p,u)||X(e,M,t,s,i,a,o,c,r+1,p,u);else if(S)if(w)_=X(e,B,t,s,i,a,o,c,r+1,p,u);else{const P=O.getPrimitive();P.copy(en).applyMatrix4(t);const v=k(e),L=H(e,m);E(v,y,lt),E(L,y,ut);const F=P.intersectsBox(lt),I=P.intersectsBox(ut);_=F&&X(B,v,s,t,i,o,a,r,c+1,P,!u)||I&&X(B,L,s,t,i,o,a,r,c+1,P,!u),O.releasePrimitive(P)}else if(C)if(w)_=X(e,M,t,s,i,a,o,c,r+1,p,u);else{const P=O.getPrimitive();P.copy(sn).applyMatrix4(t);const v=k(e),L=H(e,m);E(v,y,lt),E(L,y,ut);const F=P.intersectsBox(lt),I=P.intersectsBox(ut);_=F&&X(M,v,s,t,i,o,a,r,c+1,P,!u)||I&&X(M,L,s,t,i,o,a,r,c+1,P,!u),O.releasePrimitive(P)}}return _}const kt=new V,Zn=new Z;class gn{static serialize(n,t={}){t=Mt({cloneBuffers:!0},t);const s=n.geometry,i=n._roots,a=n._indirectBuffer,o=s.getIndex();let c;return t.cloneBuffers?c={roots:i.map(r=>r.slice()),index:o.array.slice(),indirectBuffer:a?a.slice():null}:c={roots:i,index:o.array,indirectBuffer:a},c}static deserialize(n,t,s={}){s=Mt({setIndex:!0,indirect:!!n.indirectBuffer},s);const{index:i,roots:a,indirectBuffer:o}=n,c=new gn(t,Bn(Mt({},s),{[Jt]:!0}));if(c._roots=a,c._indirectBuffer=o||null,s.setIndex){const r=t.getIndex();if(r===null){const p=new Kn(n.index,1,!1);t.setIndex(p)}else r.array!==i&&(r.array.set(i),r.needsUpdate=!0)}return c}get indirect(){return!!this._indirectBuffer}constructor(n,t={}){if(n.isBufferGeometry){if(n.index&&n.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t=Object.assign({strategy:te,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,[Jt]:!1},t),t.useSharedArrayBuffer&&!Es())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=n,this._roots=null,this._indirectBuffer=null,t[Jt]||(Oe(this,t),!n.boundingBox&&t.setBoundingBox&&(n.boundingBox=this.getBoundingBox(new Z)));const{_indirectBuffer:s}=this;this.resolveTriangleIndex=t.indirect?i=>s[i]:i=>i}refit(n=null){return(this.indirect?Ps:fs)(this,n)}traverse(n,t=0){const s=this._roots[t],i=new Uint32Array(s),a=new Uint16Array(s);o(0);function o(c,r=0){const p=c*2,u=a[p+15]===Zt;if(u){const f=i[c+6],l=a[p+14];n(r,u,new Float32Array(s,c*4,6),f,l)}else{const f=c+Ht/4,l=i[c+6],y=i[c+7];n(r,u,new Float32Array(s,c*4,6),y)||(o(f,r+1),o(l,r+1))}}}raycast(n,t=Pn){const s=this._roots,i=this.geometry,a=[],o=t.isMaterial,c=Array.isArray(t),r=i.groups,p=o?t.side:t,u=this.indirect?_s:ms;for(let f=0,l=s.length;f<l;f++){const y=c?t[r[f].materialIndex].side:p,m=a.length;if(u(this,f,y,n,a),c){const T=r[f].materialIndex;for(let g=m,d=a.length;g<d;g++)a[g].face.materialIndex=T}}return a}raycastFirst(n,t=Pn){const s=this._roots,i=this.geometry,a=t.isMaterial,o=Array.isArray(t);let c=null;const r=i.groups,p=a?t.side:t,u=this.indirect?Ss:xs;for(let f=0,l=s.length;f<l;f++){const y=o?t[r[f].materialIndex].side:p,m=u(this,f,y,n);m!=null&&(c==null||m.distance<c.distance)&&(c=m,o&&(m.face.materialIndex=r[f].materialIndex))}return c}intersectsGeometry(n,t){let s=!1;const i=this._roots,a=this.indirect?vs:ws;for(let o=0,c=i.length;o<c&&(s=a(this,o,n,t),!s);o++);return s}shapecast(n){const t=$.getPrimitive(),s=this.indirect?ds:us;let{boundsTraverseOrder:i,intersectsBounds:a,intersectsRange:o,intersectsTriangle:c}=n;if(o&&c){const f=o;o=(l,y,m,T,g)=>f(l,y,m,T,g)?!0:s(l,y,this,c,m,T,t)}else o||(c?o=(f,l,y,m)=>s(f,l,this,c,y,m,t):o=(f,l,y)=>y);let r=!1,p=0;const u=this._roots;for(let f=0,l=u.length;f<l;f++){const y=u[f];if(r=is(this,f,a,o,i,p),r)break;p+=y.byteLength}return $.releasePrimitive(t),r}bvhcast(n,t,s){let{intersectsRanges:i,intersectsTriangles:a}=s;const o=$.getPrimitive(),c=this.geometry.index,r=this.geometry.attributes.position,p=this.indirect?m=>{const T=this.resolveTriangleIndex(m);z(o,T*3,c,r)}:m=>{z(o,m*3,c,r)},u=$.getPrimitive(),f=n.geometry.index,l=n.geometry.attributes.position,y=n.indirect?m=>{const T=n.resolveTriangleIndex(m);z(u,T*3,f,l)}:m=>{z(u,m*3,f,l)};if(a){const m=(T,g,d,h,A,x,w,b)=>{for(let _=d,B=d+h;_<B;_++){y(_),u.a.applyMatrix4(t),u.b.applyMatrix4(t),u.c.applyMatrix4(t),u.needsUpdate=!0;for(let M=T,S=T+g;M<S;M++)if(p(M),o.needsUpdate=!0,a(o,u,M,_,A,x,w,b))return!0}return!1};if(i){const T=i;i=function(g,d,h,A,x,w,b,_){return T(g,d,h,A,x,w,b,_)?!0:m(g,d,h,A,x,w,b,_)}}else i=m}return Is(this,n,t,i)}intersectsBox(n,t){return kt.set(n.min,n.max,t),kt.needsUpdate=!0,this.shapecast({intersectsBounds:s=>kt.intersectsBox(s),intersectsTriangle:s=>kt.intersectsTriangle(s)})}intersectsSphere(n){return this.shapecast({intersectsBounds:t=>n.intersectsBox(t),intersectsTriangle:t=>t.intersectsSphere(n)})}closestPointToGeometry(n,t,s={},i={},a=0,o=1/0){return(this.indirect?Ds:Bs)(this,n,t,s,i,a,o)}closestPointToPoint(n,t={},s=0,i=1/0){return os(this,n,t,s,i)}getBoundingBox(n){return n.makeEmpty(),this._roots.forEach(s=>{E(0,new Float32Array(s),Zn),n.union(Zn)}),n}}function Yn(e,n,t){return e===null||(e.point.applyMatrix4(n.matrixWorld),e.distance=e.point.distanceTo(t.ray.origin),e.object=n,e.distance<t.near||e.distance>t.far)?null:e}const rn=new pe,Wn=new K,zs=cn.prototype.raycast;function Vs(e,n){if(this.geometry.boundsTree){if(this.material===void 0)return;Wn.copy(this.matrixWorld).invert(),rn.copy(e.ray).applyMatrix4(Wn);const t=this.geometry.boundsTree;if(e.firstHitOnly===!0){const s=Yn(t.raycastFirst(rn,this.material),this,e);s&&n.push(s)}else{const s=t.raycast(rn,this.material);for(let i=0,a=s.length;i<a;i++){const o=Yn(s[i],this,e);o&&n.push(o)}}}else zs.call(this,e,n)}function Rs(e){return this.boundsTree=new gn(this,e),this.boundsTree}function Ns(){this.boundsTree=null}const ie=ye("buildingsHeatmap",()=>{const e=Xt(!1),n=Xt(0);function t(i){e.value=i}function s(i){n.value=i}return{showDiv:e,temperature:n,setShowDiv:t,setTemperature:s}}),$s=["object","rotation-x"],qs=["object"],ks=On({__name:"buildingsHeatmap",props:{model:{},opacity:{default:1}},setup(e){(()=>{Mn.prototype.computeBoundsTree=Rs,Mn.prototype.disposeBoundsTree=Ns,cn.prototype.raycast=Vs})();const t=e,s=Ee();De(s);const i=new de(s._renderer.canvas);i.needsUpdate=!0;const a=d=>new he({vertexShader:"\n		varying vec2 vUv;\n		void main() {\n			gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n			vUv = uv;\n		}\n		",fragmentShader:"\n		uniform sampler2D heightMap;\n		uniform float uOpacity;\n		varying vec2 vUv;\n		void main() {\n			gl_FragColor = vec4(texture2D(heightMap, vUv.xy).rgb, uOpacity);\n    }\n		",uniforms:{uOpacity:{value:t.opacity},heightMap:{type:"t",value:d}},depthWrite:!0,depthTest:!0,transparent:!0,side:Qn}),o=t.model.city.clone();delete o.geometry.attributes.normal,delete o.geometry.attributes.uv;const c=o.geometry.clone().applyMatrix4(o.matrix),r=t.model.land.clone();delete r.geometry.attributes.normal;const p=r.geometry.clone().applyMatrix4(r.matrix),u=Fe([c,p]);u.applyMatrix4(new K().makeRotationX(Math.PI/2)),Le(u),u.computeBoundsTree();const f=a(i),l=new cn(u,f);me(()=>{t.opacity&&(f.uniforms.uOpacity.value=t.opacity)});const y=ie(),m=d=>{if(d){const h={x:d.uv.x*s._config.width,y:(1-d.uv.y)*s._config.height};console.log("数值：",d),console.log("数值———：",Un(s,h)),y.setTemperature(Un(s,h))}},T=d=>{d&&y.$patch({showDiv:!0})},g=d=>{d&&y.setShowDiv(!1)};return(d,h)=>(hn(),xn(Gn,null,[_n("primitive",{object:_t(l),"rotation-x":-Math.PI/2,onPointerMove:m,onPointerEnter:T,onPointerLeave:g},null,40,$s),_n("primitive",{object:t.model.model.children[0].clone()},null,8,qs)],64))}});const Hs={__name:"dataDiv",setup(e){const n=ie(),t=Xt({top:0,left:0});function s(i){t.value.left=i.clientX+5+"px",t.value.top=i.clientY-20+"px"}return we(()=>{window.addEventListener("mousemove",s)}),Ae(()=>{window.removeEventListener("mousemove",s)}),(i,a)=>ge((hn(),xn("div",{class:"title",style:Be(t.value)},"温度："+Te(_t(n).temperature)+"℃ ",5)),[[be,_t(n).showDiv]])}},Xs=xe(Hs,[["__scopeId","data-v-fac3e7fd"]]),Gs=On({__name:"heatmap2",async setup(e){let n,t;const s=Xt(!1),i=([n,t]=Pe(()=>ve()),n=await n,t(),n);s.value=!0;const a=Sn({width:1,color:"#000",opacity:1,show:!0}),o=Sn({opacity:.9});return new _e({title:"参数",expanded:!0}).addBinding(o,"opacity",{label:"透明度",min:0,max:1,step:.1}),(r,p)=>(hn(),xn(Gn,null,[St(Se,{showBuildings:!1,autoRotate:!1},{ability:Me(()=>[St(ks,vn({model:_t(i)},o),null,16,["model"]),St(Ce,vn(a,{builds:_t(i).city}),null,16,["builds"])]),_:1}),St(Xs)],64))}});export{Gs as default};
