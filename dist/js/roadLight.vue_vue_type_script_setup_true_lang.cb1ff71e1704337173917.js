import{Z as k,k as _,aB as g,aQ as B,ba as C,aH as R,bu as v,a4 as x,a3 as M,o as f,c as p,D as E,E as S,V as h,J as u,aO as G,aM as J}from"./vendor.a5074f6a1704337173917.js";import{l as L}from"./utils.d99a728b1704337173917.js";const V=["position","rotation-y","scale"],O={renderOrder:3e3},Y=["args"],j=["map","side","color"],y=6e4,F=k({__name:"roadLight",props:{geoJson:{},color:{default:"#ffff00"},position:{default:[1837.0641427711184,30,-457.0929823910632]},radius:{default:2},rotationY:{default:-.3866683251512052},scale:{default:1.5083171193254858},speed:{default:1}},async setup(w){let t,a;const e=w,T=_(),r=_(),{map:o}=([t,a]=g(()=>B({map:"./plugins/digitalCity/image/line.png"})),t=await t,a(),t);o.needsUpdate=!0,o.wrapS=o.wrapT=C,o.repeat.set(1,1);const d=([t,a]=g(()=>L(e.geoJson)),t=await t,a(),t),n=[-31.258949,0,-121.465782];let m=[];for(var c=0;c<d.length;c++){const l=d[c],i=[];l.geometry.coordinates.forEach(s=>{i.push(new R((s[1]+n[0])*y,n[1],(s[0]+n[2])*y))}),m.push(new v(i))}x(()=>{e.color&&r.value&&(r.value.color=new J(e.color))});const{onLoop:b}=M();return b(({delta:l})=>{o.offset.x-=Math.random()/20*e.speed}),(l,i)=>(f(),p("TresGroup",{ref_key:"tgRef",ref:T,position:e.position,"rotation-y":e.rotationY,scale:e.scale},[(f(!0),p(E,null,S(u(m),s=>(f(),p("TresMesh",O,[h("TresTubeGeometry",{args:[s,64,e.radius,20,!1]},null,8,Y),h("TresMeshBasicMaterial",{ref_for:!0,ref_key:"tmbmRef",ref:r,map:u(o),side:u(G),transparent:!0,color:e.color},null,8,j)]))),256))],8,V))}});export{F as _};
