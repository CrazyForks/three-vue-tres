import{ao as Q,ap as F,aq as j,ar as U,as as C,at as O,au as V,$ as S,o as M,c as E,K as y,av as Z,aw as ee,ax as ae,k as I,ay as $,az as k,a2 as L,aA as T,aB as G,aC as te,aD as oe,a4 as N,ak as W,v as q,a5 as J,aE as re,aF as D,a0 as ne,an as se,a as w,D as z,a9 as ie,aa as le,a8 as ue,E as ce,ah as me,ai as pe,W as d,aG as fe,ag as de,_ as ve}from"./vendor.XGv6VLQP1710427390950.js";import{l as ge}from"./starLoading.vue_vue_type_style_index_0_scoped_8c420ead_lang.nwwEOvzq1710427390950.js";import{m as xe}from"./BufferGeometryUtils.wwsQwazN1710427390950.js";import{O as he,l as _e}from"./util.iw2eDWt01710427390950.js";import{R as we,E as Pe}from"./EffectComposer.WD76veeO1710427390950.js";import{U as ye}from"./UnrealBloomPass.2V_zOVwL1710427390950.js";var Me="varying vec2 vUv;\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  vUv = uv;\n}",Se="uniform sampler2D uTextureA;\nuniform sampler2D uTextureB;\nprecision mediump float; \nuniform float uTime;\nuniform float uScroll;\nvarying vec2 vUv;\n\nmat3 rotationMatrix3(vec3 axis, float angle) {\n  axis = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1. - c;\n\n  return mat3(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,\n              oc * axis.z * axis.x + axis.y * s,\n              oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c,\n              oc * axis.y * axis.z - axis.x * s,\n              oc * axis.z * axis.x - axis.y * s,\n              oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c);\n}\n\nvoid main() {\n  vec3 textureA = rotationMatrix3(vec3(10., 6., 3.), sin(uTime) * .1) *\n                  texture2D(uTextureA, vUv).xyz;\n  \n\n  vec3 textureB = rotationMatrix3(vec3(10., 6., 3.), sin(uTime) * .1) *\n                  texture2D(uTextureB, vUv).xyz;\n  \n\n  float t = uScroll;\n  vec3 pos = mix(textureA, textureB, t);\n\n  gl_FragColor = vec4(pos, 1.);\n}";const A=o=>{let a=o.attributes.position.count,r=Math.ceil(Math.sqrt(a)),t=Math.ceil(a/r),s=new Float32Array(r*t*4);function c(e){let m=Math.floor(e.length/3);for(let i=m-1;i>0;i--){const l=Math.floor(Math.random()*(i+1));for(let u=0;u<3;u++){let v=e[i*3+u];e[i*3+u]=e[l*3+u],e[l*3+u]=v}}return e}c(o.attributes.position.array);for(let e=0;e<a;e++){const f=o.attributes.position.array[e*3+0],m=o.attributes.position.array[e*3+1],i=o.attributes.position.array[e*3+2],l=0;s[e*4+0]=f,s[e*4+1]=m,s[e*4+2]=i,s[e*4+3]=l}let n=new Q(s,r,t,F,j);return n.needsUpdate=!0,n},be=()=>new V({uniforms:{uTextureA:{value:null},uTextureB:{value:null},uTime:{value:0},uScroll:{value:0}},vertexShader:Me,fragmentShader:Se}),Be=()=>{const o=be(),a=new U;return a.setAttribute("position",new C(new Float32Array([-1,-1,0,1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,1,0]),3)),a.setAttribute("uv",new C(new Float32Array([0,1,1,1,1,0,0,1,1,0,0,0]),2)),new O(a,o)};var Te="uniform sampler2D\n    uPositions; \nuniform float uSize;\nuniform float uPixelRatio;\nvarying vec3 vPos;\nvarying vec2 vUv;\nvoid main() {\n  vec3 pos = texture2D(uPositions, position.xy).xyz;\n\n  float customSize = uSize;\n\n  vec4 modelPosition = modelMatrix * vec4(pos, 1.0);\n  vec4 viewPosition = viewMatrix * modelPosition;\n  vec4 projectionPosition = projectionMatrix * viewPosition;\n\n  gl_Position = projectionPosition;\n  gl_PointSize = customSize * uPixelRatio;\n  gl_PointSize *= (1.0 / -viewPosition.z);\n\n  vPos = pos;\n}",ze="precision mediump float;\nvarying vec3 vPos;\nuniform vec3 uColor; \nvoid main() {\n\n  float distanceToCenter = distance(gl_PointCoord, vec2(0.5));\n  float strength = 0.05 / distanceToCenter - 0.1;\n\n  \n\n  gl_FragColor = vec4(uColor, strength * length(vPos));\n}";const Ae=["object"],Ce=S({__name:"particalMesh",props:{progress:{default:0},width:{default:256},height:{default:256}},setup(o,{expose:a}){const r=o,t=()=>new V({uniforms:{uPositions:{value:null},uSize:{value:12},uPixelRatio:{value:Math.min(window.devicePixelRatio,2)},uColor:{value:new ee("#ffaa00")}},vertexShader:Te,fragmentShader:ze,transparent:!0,depthWrite:!1,blending:ae});let c=((n,e)=>{const f=n*e;let m=new Float32Array(f*3);for(let l=0;l<f;l++){let u=l*3;m[u+0]=l%n/n,m[u+1]=l/n/e}const i=new U;return i.setAttribute("position",new C(m,3)),new Z(i,t())})(r.width,r.height);return a({particles:c}),(n,e)=>(M(),E("primitive",{object:y(c)},null,8,Ae))}}),Fe="./plugins/medical/model/brainparts.OBJ",Le=S({__name:"particalFBO",props:{progress:{default:0},width:{default:256},height:{default:256},color:{default:"#ffaa00"}},async setup(o){let a,r;const t=o,s=I(),c=new $(t.width,t.height,{minFilter:k,magFilter:k,generateMipmaps:!1,colorSpace:L,depthBuffer:!1,stencilBuffer:!1,format:F,type:j}),n=h=>{const B=[];return h.traverse(_=>{_ instanceof O&&(_.geometry.deleteAttribute("uv"),_.geometry.deleteAttribute("normal"),_.geometry.deleteAttribute("tangent"),B.push(_.geometry))}),xe(B)},e=new he,f=([a,r]=T(()=>_e(Fe,e)),a=await a,r(),a),m=n(f);m.scale(.01,.01,.01);const i=A(m),l=([a,r]=T(()=>G("https://opensource-1314935952.cos.ap-nanjing.myqcloud.com/model/eCommerce/guanYu.glb",{draco:!0,decoderPath:"./draco/"})),a=await a,r(),a).scene,u=n(l.children[0]);u.rotateX(Math.PI/2),u.translate(0,-.9,0);const v=A(u),P=([a,r]=T(()=>G("./plugins/industry4/model/modelDraco.glb",{draco:!0,decoderPath:"./draco/"})),a=await a,r(),a).scene,g=n(P.children[0]);g.rotateX(-Math.PI/2),g.rotateY(Math.PI/3),g.translate(0,0,0);const b=A(g),p=Be(),R=new te,X=new oe(-1,1,1,-1,1/Math.pow(2,53),1);R.add(p);const{onBeforeLoop:H}=N(),{camera:K,renderer:x}=W();return H(({elapsed:h})=>{x.value&&K.value&&s.value&&(x.value.setRenderTarget(c),x.value.clear(),x.value.render(R,X),x.value.setRenderTarget(null),t.progress<1/2?(p.material.uniforms.uTextureA.value=v,p.material.uniforms.uTextureB.value=i,p.material.uniforms.uScroll.value=t.progress*2):(p.material.uniforms.uTextureA.value=i,p.material.uniforms.uTextureB.value=b,p.material.uniforms.uScroll.value=(t.progress-1/2)*2),p.material.uniforms.uTime.value=h,s.value.particles.material.uniforms.uPositions.value=c.texture,s.value.particles.material.uniforms.uColor.value.setStyle(t.color))}),(h,B)=>(M(),q(Ce,{ref_key:"pMesh",ref:s,progress:h.progress},null,8,["progress"]))}}),Re=S({__name:"particalPass",props:{use:{type:Boolean,default:!0}},setup(o){const a=o,{camera:r,renderer:t,scene:s,sizes:c}=W(),n={threshold:0,strength:.472,radius:1.61};let e=null;const f=(i,l,u,v,P)=>{const g=new we(i,l),b=new ye(new re(v,P),n.strength,n.radius,n.threshold),p=new $(v,P,{generateMipmaps:!1,minFilter:D,magFilter:D,format:F,colorSpace:L,samples:0});e=new Pe(u,p),e.addPass(g),e.addPass(b)};J(()=>{c.width.value&&f(s.value,r.value,t.value,c.width.value,c.height.value)});const{onLoop:m}=N();return m(()=>{a.use?e&&e.render():t.value&&r.value&&t.value.render(s.value,r.value)}),(i,l)=>null}}),Y=o=>(me("data-v-a5a8f66a"),o=o(),pe(),o),ke=Y(()=>d("TresPerspectiveCamera",{position:[0,0,-4],fov:45,near:.1,far:1e3,"look-at":[0,0,0]},null,-1)),Ge=Y(()=>d("main",null,[d("section",null,[d("h1",null,"关羽 - GuanYu")]),d("section",null,[d("h1",{style:{"margin-left":"-11em","margin-bottom":"-10em"}},"大脑 - Brain")]),d("section",null,[d("h1",{style:{"margin-left":"11em","margin-bottom":"-10em"}},"设备 - Device")])],-1)),De=S({__name:"scrollPartical",setup(o){const a=I(0);J(()=>{console.log("jaime ~ progress:",a.value)});const r={clearColor:"#000",outputColorSpace:L,windowSize:!0,disableRender:!0,powerPreference:"high-performance",antialias:!1,alpha:!1,useLegacyLights:!1,physicallyCorrectLights:!0},t=ne({pass:!0,color:"#ffaa00"}),s=new se({title:"参数",expanded:!0});return s.addBinding(t,"pass",{label:"后处理"}),s.addBinding(t,"color",{label:"颜色"}),(c,n)=>(M(),E(ce,null,[w(y(ge),{styleNum:4}),w(y(ue),ie(le(r)),{default:z(()=>[ke,w(Re,{use:t.pass},null,8,["use"]),w(y(fe),{modelValue:a.value,"onUpdate:modelValue":n[0]||(n[0]=e=>a.value=e),distance:10,"smooth-scroll":.1,"html-scroll":""},{default:z(()=>[(M(),q(de,null,{default:z(()=>[w(Le,{progress:a.value,color:t.color},null,8,["progress","color"])]),_:1}))]),_:1},8,["modelValue"])]),_:1},16),Ge],64))}}),$e=ve(De,[["__scopeId","data-v-a5a8f66a"]]);export{$e as default};
