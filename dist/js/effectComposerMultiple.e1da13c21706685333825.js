import{aR as L,a_ as y,a$ as I,b0 as M,aS as _,b1 as V,aX as S,Z as D,k as h,a4 as w,ar as Q,a3 as B,o as C,c as H,V as t,D as W,v as G,C as k,J as P,a7 as Y,a as F,aa as X}from"./vendor.7da8be181706685333825.js";import{P as z,F as O,R as $,E as g,S as R}from"./EffectComposer.f39088b61706685333825.js";import{U as j}from"./UnrealBloomPass.18e211271706685333825.js";import{F as q}from"./FilmPass.60872b0d1706685333825.js";const J={name:"AfterimageShader",uniforms:{damp:{value:.96},tOld:{value:null},tNew:{value:null}},vertexShader:"\n\n		varying vec2 vUv;\n\n		void main() {\n\n			vUv = uv;\n			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n		}",fragmentShader:"\n\n		uniform float damp;\n\n		uniform sampler2D tOld;\n		uniform sampler2D tNew;\n\n		varying vec2 vUv;\n\n		vec4 when_gt( vec4 x, float y ) {\n\n			return max( sign( x - y ), 0.0 );\n\n		}\n\n		void main() {\n\n			vec4 texelOld = texture2D( tOld, vUv );\n			vec4 texelNew = texture2D( tNew, vUv );\n\n			texelOld *= damp * when_gt( texelOld, 0.1 );\n\n			gl_FragColor = max(texelNew, texelOld);\n\n		}"};class K extends z{constructor(e=.96){super(),this.shader=J,this.uniforms=L.clone(this.shader.uniforms),this.uniforms.damp.value=e,this.textureComp=new y(window.innerWidth,window.innerHeight,{magFilter:I,type:M}),this.textureOld=new y(window.innerWidth,window.innerHeight,{magFilter:I,type:M}),this.compFsMaterial=new _({uniforms:this.uniforms,vertexShader:this.shader.vertexShader,fragmentShader:this.shader.fragmentShader}),this.compFsQuad=new O(this.compFsMaterial),this.copyFsMaterial=new V,this.copyFsQuad=new O(this.copyFsMaterial)}render(e,a,n){this.uniforms.tOld.value=this.textureOld.texture,this.uniforms.tNew.value=n.texture,e.setRenderTarget(this.textureComp),this.compFsQuad.render(e),this.copyFsQuad.material.map=this.textureComp.texture,this.renderToScreen?(e.setRenderTarget(null),this.copyFsQuad.render(e)):(e.setRenderTarget(a),this.clear&&e.clear(),this.copyFsQuad.render(e));const u=this.textureOld;this.textureOld=this.textureComp,this.textureComp=u}setSize(e,a){this.textureComp.setSize(e,a),this.textureOld.setSize(e,a)}dispose(){this.textureComp.dispose(),this.textureOld.dispose(),this.compFsMaterial.dispose(),this.copyFsMaterial.dispose(),this.compFsQuad.dispose(),this.copyFsQuad.dispose()}}const Z={name:"FXAAShader",uniforms:{tDiffuse:{value:null},resolution:{value:new S(1/1024,1/512)}},vertexShader:"\n\n		varying vec2 vUv;\n\n		void main() {\n\n			vUv = uv;\n			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n		}",fragmentShader:"\n		precision highp float;\n\n		uniform sampler2D tDiffuse;\n\n		uniform vec2 resolution;\n\n		varying vec2 vUv;\n\n		// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)\n\n		//----------------------------------------------------------------------------------\n		// File:        es3-keplerFXAAassetsshaders/FXAA_DefaultES.frag\n		// SDK Version: v3.00\n		// Email:       gameworks@nvidia.com\n		// Site:        http://developer.nvidia.com/\n		//\n		// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.\n		//\n		// Redistribution and use in source and binary forms, with or without\n		// modification, are permitted provided that the following conditions\n		// are met:\n		//  * Redistributions of source code must retain the above copyright\n		//    notice, this list of conditions and the following disclaimer.\n		//  * Redistributions in binary form must reproduce the above copyright\n		//    notice, this list of conditions and the following disclaimer in the\n		//    documentation and/or other materials provided with the distribution.\n		//  * Neither the name of NVIDIA CORPORATION nor the names of its\n		//    contributors may be used to endorse or promote products derived\n		//    from this software without specific prior written permission.\n		//\n		// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ''AS IS'' AND ANY\n		// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n		// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n		// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n		// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n		// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n		// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n		// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n		// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n		// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n		// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n		//\n		//----------------------------------------------------------------------------------\n\n		#ifndef FXAA_DISCARD\n			//\n			// Only valid for PC OpenGL currently.\n			// Probably will not work when FXAA_GREEN_AS_LUMA = 1.\n			//\n			// 1 = Use discard on pixels which don't need AA.\n			//     For APIs which enable concurrent TEX+ROP from same surface.\n			// 0 = Return unchanged color on pixels which don't need AA.\n			//\n			#define FXAA_DISCARD 0\n		#endif\n\n		/*--------------------------------------------------------------------------*/\n		#define FxaaTexTop(t, p) texture2D(t, p, -100.0)\n		#define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), -100.0)\n		/*--------------------------------------------------------------------------*/\n\n		#define NUM_SAMPLES 5\n\n		// assumes colors have premultipliedAlpha, so that the calculated color contrast is scaled by alpha\n		float contrast( vec4 a, vec4 b ) {\n			vec4 diff = abs( a - b );\n			return max( max( max( diff.r, diff.g ), diff.b ), diff.a );\n		}\n\n		/*============================================================================\n\n									FXAA3 QUALITY - PC\n\n		============================================================================*/\n\n		/*--------------------------------------------------------------------------*/\n		vec4 FxaaPixelShader(\n			vec2 posM,\n			sampler2D tex,\n			vec2 fxaaQualityRcpFrame,\n			float fxaaQualityEdgeThreshold,\n			float fxaaQualityinvEdgeThreshold\n		) {\n			vec4 rgbaM = FxaaTexTop(tex, posM);\n			vec4 rgbaS = FxaaTexOff(tex, posM, vec2( 0.0, 1.0), fxaaQualityRcpFrame.xy);\n			vec4 rgbaE = FxaaTexOff(tex, posM, vec2( 1.0, 0.0), fxaaQualityRcpFrame.xy);\n			vec4 rgbaN = FxaaTexOff(tex, posM, vec2( 0.0,-1.0), fxaaQualityRcpFrame.xy);\n			vec4 rgbaW = FxaaTexOff(tex, posM, vec2(-1.0, 0.0), fxaaQualityRcpFrame.xy);\n			// . S .\n			// W M E\n			// . N .\n\n			bool earlyExit = max( max( max(\n					contrast( rgbaM, rgbaN ),\n					contrast( rgbaM, rgbaS ) ),\n					contrast( rgbaM, rgbaE ) ),\n					contrast( rgbaM, rgbaW ) )\n					< fxaaQualityEdgeThreshold;\n			// . 0 .\n			// 0 0 0\n			// . 0 .\n\n			#if (FXAA_DISCARD == 1)\n				if(earlyExit) FxaaDiscard;\n			#else\n				if(earlyExit) return rgbaM;\n			#endif\n\n			float contrastN = contrast( rgbaM, rgbaN );\n			float contrastS = contrast( rgbaM, rgbaS );\n			float contrastE = contrast( rgbaM, rgbaE );\n			float contrastW = contrast( rgbaM, rgbaW );\n\n			float relativeVContrast = ( contrastN + contrastS ) - ( contrastE + contrastW );\n			relativeVContrast *= fxaaQualityinvEdgeThreshold;\n\n			bool horzSpan = relativeVContrast > 0.;\n			// . 1 .\n			// 0 0 0\n			// . 1 .\n\n			// 45 deg edge detection and corners of objects, aka V/H contrast is too similar\n			if( abs( relativeVContrast ) < .3 ) {\n				// locate the edge\n				vec2 dirToEdge;\n				dirToEdge.x = contrastE > contrastW ? 1. : -1.;\n				dirToEdge.y = contrastS > contrastN ? 1. : -1.;\n				// . 2 .      . 1 .\n				// 1 0 2  ~=  0 0 1\n				// . 1 .      . 0 .\n\n				// tap 2 pixels and see which ones are \"outside\" the edge, to\n				// determine if the edge is vertical or horizontal\n\n				vec4 rgbaAlongH = FxaaTexOff(tex, posM, vec2( dirToEdge.x, -dirToEdge.y ), fxaaQualityRcpFrame.xy);\n				float matchAlongH = contrast( rgbaM, rgbaAlongH );\n				// . 1 .\n				// 0 0 1\n				// . 0 H\n\n				vec4 rgbaAlongV = FxaaTexOff(tex, posM, vec2( -dirToEdge.x, dirToEdge.y ), fxaaQualityRcpFrame.xy);\n				float matchAlongV = contrast( rgbaM, rgbaAlongV );\n				// V 1 .\n				// 0 0 1\n				// . 0 .\n\n				relativeVContrast = matchAlongV - matchAlongH;\n				relativeVContrast *= fxaaQualityinvEdgeThreshold;\n\n				if( abs( relativeVContrast ) < .3 ) { // 45 deg edge\n					// 1 1 .\n					// 0 0 1\n					// . 0 1\n\n					// do a simple blur\n					return mix(\n						rgbaM,\n						(rgbaN + rgbaS + rgbaE + rgbaW) * .25,\n						.4\n					);\n				}\n\n				horzSpan = relativeVContrast > 0.;\n			}\n\n			if(!horzSpan) rgbaN = rgbaW;\n			if(!horzSpan) rgbaS = rgbaE;\n			// . 0 .      1\n			// 1 0 1  ->  0\n			// . 0 .      1\n\n			bool pairN = contrast( rgbaM, rgbaN ) > contrast( rgbaM, rgbaS );\n			if(!pairN) rgbaN = rgbaS;\n\n			vec2 offNP;\n			offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n			offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n\n			bool doneN = false;\n			bool doneP = false;\n\n			float nDist = 0.;\n			float pDist = 0.;\n\n			vec2 posN = posM;\n			vec2 posP = posM;\n\n			int iterationsUsed = 0;\n			int iterationsUsedN = 0;\n			int iterationsUsedP = 0;\n			for( int i = 0; i < NUM_SAMPLES; i++ ) {\n				iterationsUsed = i;\n\n				float increment = float(i + 1);\n\n				if(!doneN) {\n					nDist += increment;\n					posN = posM + offNP * nDist;\n					vec4 rgbaEndN = FxaaTexTop(tex, posN.xy);\n					doneN = contrast( rgbaEndN, rgbaM ) > contrast( rgbaEndN, rgbaN );\n					iterationsUsedN = i;\n				}\n\n				if(!doneP) {\n					pDist += increment;\n					posP = posM - offNP * pDist;\n					vec4 rgbaEndP = FxaaTexTop(tex, posP.xy);\n					doneP = contrast( rgbaEndP, rgbaM ) > contrast( rgbaEndP, rgbaN );\n					iterationsUsedP = i;\n				}\n\n				if(doneN || doneP) break;\n			}\n\n\n			if ( !doneP && !doneN ) return rgbaM; // failed to find end of edge\n\n			float dist = min(\n				doneN ? float( iterationsUsedN ) / float( NUM_SAMPLES - 1 ) : 1.,\n				doneP ? float( iterationsUsedP ) / float( NUM_SAMPLES - 1 ) : 1.\n			);\n\n			// hacky way of reduces blurriness of mostly diagonal edges\n			// but reduces AA quality\n			dist = pow(dist, .5);\n\n			dist = 1. - dist;\n\n			return mix(\n				rgbaM,\n				rgbaN,\n				dist * .5\n			);\n		}\n\n		void main() {\n			const float edgeDetectionQuality = .2;\n			const float invEdgeDetectionQuality = 1. / edgeDetectionQuality;\n\n			gl_FragColor = FxaaPixelShader(\n				vUv,\n				tDiffuse,\n				resolution,\n				edgeDetectionQuality, // [0,1] contrast needed, otherwise early discard\n				invEdgeDetectionQuality\n			);\n\n		}\n	"},ee=t("TresBoxGeometry",{args:[1,1,1]},null,-1),te=t("TresMeshNormalMaterial",null,null,-1),ae=[ee,te],re=t("TresBoxGeometry",{args:[1,1,1]},null,-1),se=t("TresMeshNormalMaterial",null,null,-1),oe=[re,se],ie=t("TresBoxGeometry",{args:[1,1,1]},null,-1),ne=t("TresMeshNormalMaterial",null,null,-1),le=[ie,ne],de=t("TresSphereGeometry",{args:[.8,32,16]},null,-1),ce=t("TresMeshNormalMaterial",null,null,-1),fe=[de,ce],ue=D({__name:"ecLayerMultiple",setup(b){const e=h(),a=h(),n=h(),u=h();w(()=>{e.value&&e.value.layers.set(0),a.value&&a.value.layers.set(1),n.value&&n.value.layers.set(2),u.value&&u.value.layers.set(3)});const{camera:o,renderer:l,scene:N,sizes:A}=Q(),x={strength:.572,radius:.51,threshold:0};let m=null,i=null;((r,s,p,T,E)=>{m=new $(r,s),i=new g(p),i.renderToScreen=!1,i.addPass(m);const v=new j(new S(T,E),x.strength,x.radius,x.threshold);i.addPass(v)})(N.value,o.value,l.value,A.width.value,A.height.value);let d=null;(r=>{d=new g(r),d.renderToScreen=!1,d.addPass(m);const s=new q;d.addPass(s)})(l.value);let c=null;(r=>{c=new g(r),c.renderToScreen=!1,c.addPass(m);const s=new K;c.addPass(s)})(l.value);let f=null;(r=>{f=new g(r),f.addPass(m);const s=new _({uniforms:{baseTexture:{value:null},bloomTexture:{value:i.renderTarget2.texture},filmTexture:{value:d.renderTarget2.texture},glitchTexture:{value:c.renderTarget2.texture}},vertexShader:"\n            varying vec2 vUv;\n            void main() {\n                vUv = uv;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n            }\n        ",fragmentShader:"\n            uniform sampler2D baseTexture;\n            uniform sampler2D bloomTexture;\n						uniform sampler2D filmTexture;\n						uniform sampler2D glitchTexture;\n            varying vec2 vUv;\n            void main() {\n                gl_FragColor = ( \n									vec4( 1.0 ) * texture2D( baseTexture, vUv )  + \n									vec4( 1.0 ) * texture2D( bloomTexture, vUv ) + \n									vec4( 1.0 ) * texture2D( filmTexture, vUv ) + \n									vec4( 1.0 ) * texture2D( glitchTexture, vUv ) \n								);\n            }\n        ",defines:{}}),p=new R(s,"baseTexture");p.needsSwap=!0,f.addPass(p);const{width:T,height:E}=r.getDrawingBufferSize(new S),v=new R(Z);v.uniforms.resolution.value.set(1/T,1/E),f.addPass(v)})(l.value);const{onLoop:U}=B();return U(()=>{i&&f&&o.value&&(l.value.clear(),o.value.layers.set(1),i.render(),o.value.layers.set(2),d.render(),o.value.layers.set(3),c.render(),l.value.clearDepth(),o.value.layers.set(0),f.render(N.value,o.value))}),(r,s)=>(C(),H(W,null,[t("TresMesh",{ref_key:"normalBox",ref:e,position:[3,2,1]},ae,512),t("TresMesh",{ref_key:"shineBox",ref:a,position:[0,2,-4]},oe,512),t("TresMesh",{ref_key:"filmBox",ref:n,position:[1,2,3]},le,512),t("TresMesh",{ref_key:"glitchSphere",ref:u,position:[-3,2,0]},fe,512)],64))}}),me=t("TresPerspectiveCamera",{position:[10,10,10]},null,-1),he=t("TresAmbientLight",{intensity:1},null,-1),pe=t("TresGridHelper",{args:[10,10]},null,-1),Ae=D({__name:"effectComposerMultiple",setup(b){const e=h();return w(()=>{if(e.value){let a=e.value.context.renderer.value;a.autoClear=!1}}),(a,n)=>(C(),G(P(Y),{disableRender:"","window-size":"",ref_key:"tcRef",ref:e},{default:k(()=>[me,he,F(P(X)),pe,F(ue)]),_:1},512))}});export{Ae as default};
