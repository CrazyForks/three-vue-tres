import{aH as T,aM as C,bY as oe,bZ as se,bp as X,aJ as E,bo as w,bX as B,bx as N,bL as V,al as ne,aU as k,bM as M,aX as F,Z as D,a4 as O,o as R,c as G,J as q,k as I,aB as ie,aQ as ae,aF as W,ai as Z,aN as re,a3 as Q,V as U,a8 as K,a9 as ee,aT as le,an as L}from"./vendor.bb7c097e1703747450293.js";import{m as te}from"./BufferGeometryUtils.1568a45e1703747450293.js";const ce=/^[og]\s*(.+)?/,ue=/^mtllib /,fe=/^usemtl /,me=/^usemap /,H=/\s+/,J=new T,A=new T,Y=new T,$=new T,x=new T,S=new C;function pe(){const _={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(o,t){if(this.object&&this.object.fromDeclaration===!1){this.object.name=o,this.object.fromDeclaration=t!==!1;return}const s=this.object&&typeof this.object.currentMaterial=="function"?this.object.currentMaterial():void 0;if(this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0),this.object={name:o||"",fromDeclaration:t!==!1,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(e,n){const l=this._finalize(!1);l&&(l.inherited||l.groupCount<=0)&&this.materials.splice(l.index,1);const c={index:this.materials.length,name:e||"",mtllib:Array.isArray(n)&&n.length>0?n[n.length-1]:"",smooth:l!==void 0?l.smooth:this.smooth,groupStart:l!==void 0?l.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(b){const a={index:typeof b=="number"?b:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return a.clone=this.clone.bind(a),a}};return this.materials.push(c),c},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(e){const n=this.currentMaterial();if(n&&n.groupEnd===-1&&(n.groupEnd=this.geometry.vertices.length/3,n.groupCount=n.groupEnd-n.groupStart,n.inherited=!1),e&&this.materials.length>1)for(let l=this.materials.length-1;l>=0;l--)this.materials[l].groupCount<=0&&this.materials.splice(l,1);return e&&this.materials.length===0&&this.materials.push({name:"",smooth:this.smooth}),n}},s&&s.name&&typeof s.clone=="function"){const e=s.clone(0);e.inherited=!0,this.object.materials.push(e)}this.objects.push(this.object)},finalize:function(){this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0)},parseVertexIndex:function(o,t){const s=parseInt(o,10);return(s>=0?s-1:s+t/3)*3},parseNormalIndex:function(o,t){const s=parseInt(o,10);return(s>=0?s-1:s+t/3)*3},parseUVIndex:function(o,t){const s=parseInt(o,10);return(s>=0?s-1:s+t/2)*2},addVertex:function(o,t,s){const e=this.vertices,n=this.object.geometry.vertices;n.push(e[o+0],e[o+1],e[o+2]),n.push(e[t+0],e[t+1],e[t+2]),n.push(e[s+0],e[s+1],e[s+2])},addVertexPoint:function(o){const t=this.vertices;this.object.geometry.vertices.push(t[o+0],t[o+1],t[o+2])},addVertexLine:function(o){const t=this.vertices;this.object.geometry.vertices.push(t[o+0],t[o+1],t[o+2])},addNormal:function(o,t,s){const e=this.normals,n=this.object.geometry.normals;n.push(e[o+0],e[o+1],e[o+2]),n.push(e[t+0],e[t+1],e[t+2]),n.push(e[s+0],e[s+1],e[s+2])},addFaceNormal:function(o,t,s){const e=this.vertices,n=this.object.geometry.normals;J.fromArray(e,o),A.fromArray(e,t),Y.fromArray(e,s),x.subVectors(Y,A),$.subVectors(J,A),x.cross($),x.normalize(),n.push(x.x,x.y,x.z),n.push(x.x,x.y,x.z),n.push(x.x,x.y,x.z)},addColor:function(o,t,s){const e=this.colors,n=this.object.geometry.colors;e[o]!==void 0&&n.push(e[o+0],e[o+1],e[o+2]),e[t]!==void 0&&n.push(e[t+0],e[t+1],e[t+2]),e[s]!==void 0&&n.push(e[s+0],e[s+1],e[s+2])},addUV:function(o,t,s){const e=this.uvs,n=this.object.geometry.uvs;n.push(e[o+0],e[o+1]),n.push(e[t+0],e[t+1]),n.push(e[s+0],e[s+1])},addDefaultUV:function(){const o=this.object.geometry.uvs;o.push(0,0),o.push(0,0),o.push(0,0)},addUVLine:function(o){const t=this.uvs;this.object.geometry.uvs.push(t[o+0],t[o+1])},addFace:function(o,t,s,e,n,l,c,b,a){const r=this.vertices.length;let i=this.parseVertexIndex(o,r),u=this.parseVertexIndex(t,r),f=this.parseVertexIndex(s,r);if(this.addVertex(i,u,f),this.addColor(i,u,f),c!==void 0&&c!==""){const g=this.normals.length;i=this.parseNormalIndex(c,g),u=this.parseNormalIndex(b,g),f=this.parseNormalIndex(a,g),this.addNormal(i,u,f)}else this.addFaceNormal(i,u,f);if(e!==void 0&&e!==""){const g=this.uvs.length;i=this.parseUVIndex(e,g),u=this.parseUVIndex(n,g),f=this.parseUVIndex(l,g),this.addUV(i,u,f),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(o){this.object.geometry.type="Points";const t=this.vertices.length;for(let s=0,e=o.length;s<e;s++){const n=this.parseVertexIndex(o[s],t);this.addVertexPoint(n),this.addColor(n)}},addLineGeometry:function(o,t){this.object.geometry.type="Line";const s=this.vertices.length,e=this.uvs.length;for(let n=0,l=o.length;n<l;n++)this.addVertexLine(this.parseVertexIndex(o[n],s));for(let n=0,l=t.length;n<l;n++)this.addUVLine(this.parseUVIndex(t[n],e))}};return _.startObject("",!1),_}class we extends oe{constructor(o){super(o),this.materials=null}load(o,t,s,e){const n=this,l=new se(this.manager);l.setPath(this.path),l.setRequestHeader(this.requestHeader),l.setWithCredentials(this.withCredentials),l.load(o,function(c){try{t(n.parse(c))}catch(b){e?e(b):console.error(b),n.manager.itemError(o)}},s,e)}setMaterials(o){return this.materials=o,this}parse(o){const t=new pe;o.indexOf("\r\n")!==-1&&(o=o.replace(/\r\n/g,"\n")),o.indexOf("\\\n")!==-1&&(o=o.replace(/\\\n/g,""));const s=o.split("\n");let e=[];for(let c=0,b=s.length;c<b;c++){const a=s[c].trimStart();if(a.length===0)continue;const r=a.charAt(0);if(r!=="#")if(r==="v"){const i=a.split(H);switch(i[0]){case"v":t.vertices.push(parseFloat(i[1]),parseFloat(i[2]),parseFloat(i[3])),i.length>=7?(S.setRGB(parseFloat(i[4]),parseFloat(i[5]),parseFloat(i[6])).convertSRGBToLinear(),t.colors.push(S.r,S.g,S.b)):t.colors.push(void 0,void 0,void 0);break;case"vn":t.normals.push(parseFloat(i[1]),parseFloat(i[2]),parseFloat(i[3]));break;case"vt":t.uvs.push(parseFloat(i[1]),parseFloat(i[2]));break}}else if(r==="f"){const u=a.slice(1).trim().split(H),f=[];for(let h=0,d=u.length;h<d;h++){const m=u[h];if(m.length>0){const v=m.split("/");f.push(v)}}const g=f[0];for(let h=1,d=f.length-1;h<d;h++){const m=f[h],v=f[h+1];t.addFace(g[0],m[0],v[0],g[1],m[1],v[1],g[2],m[2],v[2])}}else if(r==="l"){const i=a.substring(1).trim().split(" ");let u=[];const f=[];if(a.indexOf("/")===-1)u=i;else for(let g=0,h=i.length;g<h;g++){const d=i[g].split("/");d[0]!==""&&u.push(d[0]),d[1]!==""&&f.push(d[1])}t.addLineGeometry(u,f)}else if(r==="p"){const u=a.slice(1).trim().split(" ");t.addPointGeometry(u)}else if((e=ce.exec(a))!==null){const i=(" "+e[0].slice(1).trim()).slice(1);t.startObject(i)}else if(fe.test(a))t.object.startMaterial(a.substring(7).trim(),t.materialLibraries);else if(ue.test(a))t.materialLibraries.push(a.substring(7).trim());else if(me.test(a))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if(r==="s"){if(e=a.split(" "),e.length>1){const u=e[1].trim().toLowerCase();t.object.smooth=u!=="0"&&u!=="off"}else t.object.smooth=!0;const i=t.object.currentMaterial();i&&(i.smooth=t.object.smooth)}else{if(a==="\0")continue;console.warn('THREE.OBJLoader: Unexpected line: "'+a+'"')}}t.finalize();const n=new X;if(n.materialLibraries=[].concat(t.materialLibraries),!(t.objects.length===1&&t.objects[0].geometry.vertices.length===0)===!0)for(let c=0,b=t.objects.length;c<b;c++){const a=t.objects[c],r=a.geometry,i=a.materials,u=r.type==="Line",f=r.type==="Points";let g=!1;if(r.vertices.length===0)continue;const h=new E;h.setAttribute("position",new w(r.vertices,3)),r.normals.length>0&&h.setAttribute("normal",new w(r.normals,3)),r.colors.length>0&&(g=!0,h.setAttribute("color",new w(r.colors,3))),r.hasUVIndices===!0&&h.setAttribute("uv",new w(r.uvs,2));const d=[];for(let v=0,P=i.length;v<P;v++){const y=i[v],z=y.name+"_"+y.smooth+"_"+g;let p=t.materials[z];if(this.materials!==null){if(p=this.materials.create(y.name),u&&p&&!(p instanceof B)){const j=new B;N.prototype.copy.call(j,p),j.color.copy(p.color),p=j}else if(f&&p&&!(p instanceof V)){const j=new V({size:10,sizeAttenuation:!1});N.prototype.copy.call(j,p),j.color.copy(p.color),j.map=p.map,p=j}}p===void 0&&(u?p=new B:f?p=new V({size:1,sizeAttenuation:!1}):p=new ne,p.name=y.name,p.flatShading=!y.smooth,p.vertexColors=g,t.materials[z]=p),d.push(p)}let m;if(d.length>1){for(let v=0,P=i.length;v<P;v++){const y=i[v];h.addGroup(y.groupStart,y.groupCount,v)}u?m=new k(h,d):f?m=new M(h,d):m=new F(h,d)}else u?m=new k(h,d[0]):f?m=new M(h,d[0]):m=new F(h,d[0]);m.name=a.name,n.add(m)}else if(t.vertices.length>0){const c=new V({size:1,sizeAttenuation:!1}),b=new E;b.setAttribute("position",new w(t.vertices,3)),t.colors.length>0&&t.colors[0]!==void 0&&(b.setAttribute("color",new w(t.colors,3)),c.vertexColors=!0);const a=new M(b,c);n.add(a)}return n}}const je=(_,o)=>new Promise((t,s)=>{o.setCrossOrigin("Anonymous"),o.load(_,e=>{t(e)},e=>{console.log("".concat(e.loaded/e.total*100,"% loaded"))},e=>{console.error(e),s(e)})}),he=["object"],Pe=D({__name:"cloudPoints",props:{model:{},color:{default:"#FFF"},opacity:{default:1}},setup(_){const o=_,t=new X;return o.model.traverse(s=>{if(s instanceof F){const e=s.geometry.clone();s.geometry.dispose(),s.material.dispose();const n=new V({color:o.color});n.opacity=o.opacity,n.transparent=!0;const l=new M(e,n);t.add(l)}}),O(()=>{o.color&&t.traverse(s=>{s instanceof M&&(s.material.color=new C(o.color))}),o.opacity&&t.traverse(s=>{s instanceof M&&(s.material.opacity=o.opacity)})}),(s,e)=>(R(),G("primitive",{object:q(t)},null,8,he))}}),de="uniform float c;\nuniform float p;\nuniform float uTime;\nvarying float intensity;\nvarying vec2 vUv;\nvoid main(){\n    vUv=uv;\n    vec3 vNormal=normalize(normalMatrix*normal);\n    intensity=pow(c-abs(dot(vNormal,vec3(0,0,1))),p);\n    gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.);\n}",ge="uniform vec3 glowColor;\nuniform sampler2D lightningTexture;\nvarying float intensity;\nvarying vec2 vUv;\nuniform float offsetY;\nuniform float uTime;\nuniform float uOpacity;\n\nvoid main(){\n  vec2 uv=vUv;\n  uv.y+=offsetY;\n  vec3 glow=glowColor*intensity;\n  vec3 color=vec3(step(.1,uv.y)-step(.2,uv.y))-vec3(texture2D(lightningTexture,uv));\n  float alpha=clamp(cos(uTime*3.),.5,1.);\n  gl_FragColor=vec4(glow+color,alpha*uOpacity);\n}",be=U("TresBufferGeometry",null,null,-1),ze=D({__name:"xRayEffect",props:{model:{},color:{default:"#84ccff"},opacity:{default:1}},async setup(_){let o,t;const s=_,e=I(),n=[];s.model.traverse(r=>{r instanceof F&&(r.geometry.verticesNeedUpdate=!0,n.push(r.geometry))});const l=([o,t]=ie(()=>ae({map:"./plugins/medical/image/brainXRayLight.png"})),o=await o,t(),o),c={uniforms:{c:{type:"f",value:1.11},p:{type:"f",value:1},glowColor:{type:"c",value:new C(s.color)},lightningTexture:{type:"t",value:l.map},offsetY:{type:"f",value:.1},uTime:{type:"f",value:0},uOpacity:{type:"f",value:s.opacity}},vertexShader:de,fragmentShader:ge,side:W,blending:Z,depthWrite:!1};c.uniforms.offsetY.value=Math.sin(5);const{camera:b}=re(),{onLoop:a}=Q();return a(({delta:r})=>{b.value.position&&e.value&&(c.uniforms.uTime.value+=r)}),O(()=>{e.value&&(e.value.geometry.dispose(),e.value.geometry=te(n)),s.color&&(c.uniforms.glowColor.value=new C(s.color)),s.opacity&&(c.uniforms.uOpacity.value=s.opacity)}),(r,i)=>(R(),G("TresMesh",{ref_key:"TresMeshRef",ref:e},[be,U("TresShaderMaterial",K(ee(c)),null,16)],512))}}),ve="uniform float p;\nuniform float uTime;\nuniform float uSlowTime;\nuniform float uBubblesUp;\nvarying float intensity;\nattribute vec2 aDelayDuration;\nattribute float size;\nattribute vec4 bubbles;\nvarying float alpha;\n\nfloat easeExpoInOut(float p){\n    return((p*=2.)<1.)?.5*pow(2.,10.*(p-1.)):.5*(2.-pow(2.,-10.*(p-1.)));\n}\n\nvoid main()\n{\n    intensity=.9;\n    vec4 mvPosition=modelViewMatrix*vec4(position,1.);\n    gl_PointSize=size*(300./-mvPosition.z);\n    float m=mod(size,sin(uSlowTime*.12+size));\n    \n    alpha=step(.5,abs(m));\n    if(m>.5&&m<.7){\n        gl_PointSize=.9*size;\n    }\n    if(m>.8){\n        gl_PointSize=.9*size;\n    }\n    \n    gl_Position=projectionMatrix*mvPosition;\n    \n    if(bubbles.w>0.&&bubbles.w<2.&&bubbles.x!=0.&&bubbles.y!=0.){\n        gl_PointSize=size+15.;\n        alpha=clamp(abs(sin(uTime-bubbles.y)),.3,1.);\n        \n        float tProgress=smoothstep(0.,aDelayDuration.x,uBubblesUp);\n        vec3 tranlated=mix(position,bubbles.xyz,tProgress);\n        vec4 bPosition=modelViewMatrix*vec4(tranlated,1.);\n        \n        gl_PointSize=uBubblesUp*gl_PointSize;\n        gl_Position+=projectionMatrix*bPosition;\n        alpha=5.;\n    }\n    \n    if(bubbles.w==2.){\n        alpha=clamp(abs(sin(uTime-bubbles.y)),.3,.6);\n        gl_PointSize=size+60.;\n        \n        gl_PointSize=uBubblesUp*gl_PointSize;\n        float normalized=clamp(uBubblesUp,0.,2.)*2.;\n        vec3 tranlated=mix(position,bubbles.xyz,normalized);\n        vec4 bPosition=modelViewMatrix*vec4(tranlated,1.);\n        gl_Position+=projectionMatrix*bPosition;\n    }\n    if(bubbles.w==3.){\n        alpha=clamp(abs(sin(uTime-bubbles.y)),.3,1.);\n        gl_PointSize=size+90.;\n        \n        gl_PointSize=uBubblesUp*gl_PointSize;\n        float normalized=clamp(uBubblesUp,0.,2.)*2.;\n        vec3 tranlated=mix(position,bubbles.xyz,normalized);\n        vec4 bPosition=modelViewMatrix*vec4(tranlated,1.);\n        gl_Position+=projectionMatrix*bPosition;\n    }\n}",ye="uniform vec3 glowColor;\nvarying float intensity;\nvarying float alpha;\nuniform float uOpacity;\nvoid main()\n{\n    float distanceToCenter=distance(gl_PointCoord,vec2(.5));\n    float pct=1.-smoothstep(0.,.5,distanceToCenter);\n    vec3 color=vec3(1.)*gl_FragColor.rgb;\n    vec3 glow=glowColor*intensity;\n    gl_FragColor=vec4(glow,clamp(alpha,0.,1.));\n    gl_FragColor=vec4(glow,pct*gl_FragColor.a);\n    gl_FragColor=vec4(gl_FragColor.rgb,gl_FragColor.a*uOpacity);\n    // gl_FragColor=vec4(1.,1.,0.,1.);\n}",Me=D({__name:"bubblesEffect",props:{model:{},color:{default:"#FFF"},opacity:{default:1}},setup(_){const o=_,t=["afective","semantic","episodic","process","amigdala","brainstem","bridge","cerebellum","analitic"],s={};o.model.traverse(a=>{a instanceof F&&t.map(r=>{if(a.name.includes(r)){if(s[r]){const i=[s[r],a.geometry];return s[r]=te(i),s}return s[r]=a.geometry}return[]})});const e=I(),n=()=>{const r=[],i=[],u=[],f=[],d=[];for(let m=0;m<2e4-t.length*3;m+=1){const v=L.randInt(0,t.length-1),P=t[v],y=s[P].attributes.position.array[m*3+0]||0,z=s[P].attributes.position.array[m*3+1]||0,p=s[P].attributes.position.array[m*3+2]||0;if(i.push(y,z,p),r[m]=L.randFloat(10,20),m%100===0){const j=L.randInt(100,250)+z;d.push(y,j,p,1)}else d.push(y,z,p,0);f[m*2+0]=L.randFloat(.5,1.5),f[m*2+1]=2.5}e.value.setAttribute("aDelayDuration",new w(f,2)),e.value.setAttribute("bubbles",new w(d,4)),e.value.setAttribute("position",new w(i,3)),e.value.setAttribute("color",new w(u,3)),e.value.setAttribute("size",new w(r,1)),e.value.computeBoundingSphere()},l=new le({uniforms:{glowColor:{type:"c",value:new C(o.color)},uTime:{type:"f",value:0},uSlowTime:{type:"f",value:0},uBubblesUp:{type:"f",value:1},uOpacity:{type:"f",value:o.opacity}},vertexShader:ve,fragmentShader:ye,blending:Z,side:W,depthTest:!1,vertexColors:!1,transparent:!0});O(()=>{e.value&&n()});const c=I(),{onLoop:b}=Q();return b(({delta:a})=>{c.value&&(c.value.material.uniforms.uTime.value+=1/20,c.value.material.uniforms.uSlowTime.value+=1/400),o.color&&(l.uniforms.glowColor.value=new C(o.color)),o.opacity&&(l.uniforms.uOpacity.value=o.opacity)}),(a,r)=>(R(),G("TresPoints",{ref_key:"TresMeshRef",ref:c},[U("TresBufferGeometry",{ref_key:"BufferGeometryRef",ref:e},null,512),U("TresShaderMaterial",K(ee(q(l))),null,16)],512))}});export{we as O,Pe as _,ze as a,Me as b,je as l};
