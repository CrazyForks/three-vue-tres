var Xn=Object.defineProperty,jn=Object.defineProperties;var Wn=Object.getOwnPropertyDescriptors;var dn=Object.getOwnPropertySymbols;var Yn=Object.prototype.hasOwnProperty,Zn=Object.prototype.propertyIsEnumerable;var mn=(e,n,t)=>n in e?Xn(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t,_t=(e,n)=>{for(var t in n||(n={}))Yn.call(n,t)&&mn(e,t,n[t]);if(dn)for(var t of dn(n))Zn.call(n,t)&&mn(e,t,n[t]);return e},xn=(e,n)=>jn(e,Wn(n));import{a_ as fn,aI as L,aT as nt,aH as Rn,by as Z,aY as Pt,bv as Kn,bf as O,bq as W,b0 as Jn,aJ as Vn,a$ as hn,aV as Nn,bB as Qn,bC as Gn,aZ as wn,b2 as On,al as te}from"./vendor.80b0f38b1705573255009.js";import{W as ne}from"./Water2.0ddbed661705573255009.js";const qn=0,ee=1,se=2,An=2,jt=1.25,Tn=1,$t=6*4+4+4,Ht=65535,ie=Math.pow(2,-24),Wt=Symbol("SKIP_GENERATION");function re(e){return e.index?e.index.count:e.attributes.position.count}function yt(e){return re(e)/3}function oe(e,n=ArrayBuffer){return e>65535?new Uint32Array(new n(4*e)):new Uint16Array(new n(2*e))}function ce(e,n){if(!e.index){const t=e.attributes.position.count,s=n.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=oe(t,s);e.setIndex(new fn(i,1));for(let a=0;a<t;a++)i[a]=a}}function $n(e){const n=yt(e),t=e.drawRange,s=t.start/3,i=(t.start+t.count)/3,a=Math.max(0,s),r=Math.min(n,i)-a;return[{offset:Math.floor(a),count:Math.floor(r)}]}function kn(e){if(!e.groups||!e.groups.length)return $n(e);const n=[],t=new Set,s=e.drawRange,i=s.start/3,a=(s.start+s.count)/3;for(const o of e.groups){const c=o.start/3,p=(o.start+o.count)/3;t.add(Math.max(i,c)),t.add(Math.min(a,p))}const r=Array.from(t.values()).sort((o,c)=>o-c);for(let o=0;o<r.length-1;o++){const c=r[o],p=r[o+1];n.push({offset:Math.floor(c),count:Math.floor(p-c)})}return n}function ae(e){if(e.groups.length===0)return!1;const n=yt(e),t=kn(e).sort((a,r)=>a.offset-r.offset),s=t[t.length-1];s.count=Math.min(n-s.offset,s.count);let i=0;return t.forEach(({count:a})=>i+=a),n!==i}function D(e,n,t){return t.min.x=n[e],t.min.y=n[e+1],t.min.z=n[e+2],t.max.x=n[e+3],t.max.y=n[e+4],t.max.z=n[e+5],t}function le(e){e[0]=e[1]=e[2]=1/0,e[3]=e[4]=e[5]=-1/0}function bn(e){let n=-1,t=-1/0;for(let s=0;s<3;s++){const i=e[s+3]-e[s];i>t&&(t=i,n=s)}return n}function Bn(e,n){n.set(e)}function Pn(e,n,t){let s,i;for(let a=0;a<3;a++){const r=a+3;s=e[a],i=n[a],t[a]=s<i?s:i,s=e[r],i=n[r],t[r]=s>i?s:i}}function Mt(e,n,t){for(let s=0;s<3;s++){const i=n[e+2*s],a=n[e+2*s+1],r=i-a,o=i+a;r<t[s]&&(t[s]=r),o>t[s+3]&&(t[s+3]=o)}}function ht(e){const n=e[3]-e[0],t=e[4]-e[1],s=e[5]-e[2];return 2*(n*t+t*s+s*n)}function Yt(e,n,t,s,i=null){let a=1/0,r=1/0,o=1/0,c=-1/0,p=-1/0,f=-1/0,u=1/0,l=1/0,y=1/0,m=-1/0,B=-1/0,T=-1/0;const d=i!==null;for(let h=n*6,A=(n+t)*6;h<A;h+=6){const x=e[h+0],w=e[h+1],b=x-w,_=x+w;b<a&&(a=b),_>c&&(c=_),d&&x<u&&(u=x),d&&x>m&&(m=x);const P=e[h+2],M=e[h+3],S=P-M,F=P+M;S<r&&(r=S),F>p&&(p=F),d&&P<l&&(l=P),d&&P>B&&(B=P);const g=e[h+4],C=e[h+5],U=g-C,v=g+C;U<o&&(o=U),v>f&&(f=v),d&&g<y&&(y=g),d&&g>T&&(T=g)}s[0]=a,s[1]=r,s[2]=o,s[3]=c,s[4]=p,s[5]=f,d&&(i[0]=u,i[1]=l,i[2]=y,i[3]=m,i[4]=B,i[5]=T)}function fe(e,n,t,s){let i=1/0,a=1/0,r=1/0,o=-1/0,c=-1/0,p=-1/0;for(let f=n*6,u=(n+t)*6;f<u;f+=6){const l=e[f+0];l<i&&(i=l),l>o&&(o=l);const y=e[f+2];y<a&&(a=y),y>c&&(c=y);const m=e[f+4];m<r&&(r=m),m>p&&(p=m)}s[0]=i,s[1]=a,s[2]=r,s[3]=o,s[4]=c,s[5]=p}function ue(e,n){le(n);const t=e.attributes.position,s=e.index?e.index.array:null,i=yt(e),a=new Float32Array(i*6),r=t.normalized,o=t.array,c=t.offset||0;let p=3;t.isInterleavedBufferAttribute&&(p=t.data.stride);const f=["getX","getY","getZ"];for(let u=0;u<i;u++){const l=u*3,y=u*6;let m=l+0,B=l+1,T=l+2;s&&(m=s[m],B=s[B],T=s[T]),r||(m=m*p+c,B=B*p+c,T=T*p+c);for(let d=0;d<3;d++){let h,A,x;r?(h=t[f[d]](m),A=t[f[d]](B),x=t[f[d]](T)):(h=o[m+d],A=o[B+d],x=o[T+d]);let w=h;A<w&&(w=A),x<w&&(w=x);let b=h;A>b&&(b=A),x>b&&(b=x);const _=(b-w)/2,P=d*2;a[y+P+0]=w+_,a[y+P+1]=_+(Math.abs(w)+_)*ie,w<n[d]&&(n[d]=w),b>n[d+3]&&(n[d+3]=b)}}return a}const Y=32,pe=(e,n)=>e.candidate-n.candidate,J=new Array(Y).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),St=new Float32Array(6);function ye(e,n,t,s,i,a){let r=-1,o=0;if(a===qn)r=bn(n),r!==-1&&(o=(n[r]+n[r+3])/2);else if(a===ee)r=bn(e),r!==-1&&(o=de(t,s,i,r));else if(a===se){const c=ht(e);let p=jt*i;const f=s*6,u=(s+i)*6;for(let l=0;l<3;l++){const y=n[l],T=(n[l+3]-y)/Y;if(i<Y/4){const d=[...J];d.length=i;let h=0;for(let x=f;x<u;x+=6,h++){const w=d[h];w.candidate=t[x+2*l],w.count=0;const{bounds:b,leftCacheBounds:_,rightCacheBounds:P}=w;for(let M=0;M<3;M++)P[M]=1/0,P[M+3]=-1/0,_[M]=1/0,_[M+3]=-1/0,b[M]=1/0,b[M+3]=-1/0;Mt(x,t,b)}d.sort(pe);let A=i;for(let x=0;x<A;x++){const w=d[x];for(;x+1<A&&d[x+1].candidate===w.candidate;)d.splice(x+1,1),A--}for(let x=f;x<u;x+=6){const w=t[x+2*l];for(let b=0;b<A;b++){const _=d[b];w>=_.candidate?Mt(x,t,_.rightCacheBounds):(Mt(x,t,_.leftCacheBounds),_.count++)}}for(let x=0;x<A;x++){const w=d[x],b=w.count,_=i-w.count,P=w.leftCacheBounds,M=w.rightCacheBounds;let S=0;b!==0&&(S=ht(P)/c);let F=0;_!==0&&(F=ht(M)/c);const g=Tn+jt*(S*b+F*_);g<p&&(r=l,p=g,o=w.candidate)}}else{for(let A=0;A<Y;A++){const x=J[A];x.count=0,x.candidate=y+T+A*T;const w=x.bounds;for(let b=0;b<3;b++)w[b]=1/0,w[b+3]=-1/0}for(let A=f;A<u;A+=6){let b=~~((t[A+2*l]-y)/T);b>=Y&&(b=Y-1);const _=J[b];_.count++,Mt(A,t,_.bounds)}const d=J[Y-1];Bn(d.bounds,d.rightCacheBounds);for(let A=Y-2;A>=0;A--){const x=J[A],w=J[A+1];Pn(x.bounds,w.rightCacheBounds,x.rightCacheBounds)}let h=0;for(let A=0;A<Y-1;A++){const x=J[A],w=x.count,b=x.bounds,P=J[A+1].rightCacheBounds;w!==0&&(h===0?Bn(b,St):Pn(b,St,St)),h+=w;let M=0,S=0;h!==0&&(M=ht(St)/c);const F=i-h;F!==0&&(S=ht(P)/c);const g=Tn+jt*(M*h+S*F);g<p&&(r=l,p=g,o=x.candidate)}}}}else console.warn("MeshBVH: Invalid build strategy value ".concat(a," used."));return{axis:r,pos:o}}function de(e,n,t,s){let i=0;for(let a=n,r=n+t;a<r;a++)i+=e[a*6+s*2];return i/t}class Ct{constructor(){}}function me(e,n,t,s,i,a){let r=s,o=s+i-1;const c=a.pos,p=a.axis*2;for(;;){for(;r<=o&&t[r*6+p]<c;)r++;for(;r<=o&&t[o*6+p]>=c;)o--;if(r<o){for(let f=0;f<3;f++){let u=n[r*3+f];n[r*3+f]=n[o*3+f],n[o*3+f]=u}for(let f=0;f<6;f++){let u=t[r*6+f];t[r*6+f]=t[o*6+f],t[o*6+f]=u}r++,o--}else return r}}function xe(e,n,t,s,i,a){let r=s,o=s+i-1;const c=a.pos,p=a.axis*2;for(;;){for(;r<=o&&t[r*6+p]<c;)r++;for(;r<=o&&t[o*6+p]>=c;)o--;if(r<o){let f=e[r];e[r]=e[o],e[o]=f;for(let u=0;u<6;u++){let l=t[r*6+u];t[r*6+u]=t[o*6+u],t[o*6+u]=l}r++,o--}else return r}}function he(e,n){const t=(e.index?e.index.count:e.attributes.position.count)/3,s=t>2**16,i=s?4:2,a=n?new SharedArrayBuffer(t*i):new ArrayBuffer(t*i),r=s?new Uint32Array(a):new Uint16Array(a);for(let o=0,c=r.length;o<c;o++)r[o]=o;return r}function we(e,n){const t=e.geometry,s=t.index?t.index.array:null,i=n.maxDepth,a=n.verbose,r=n.maxLeafTris,o=n.strategy,c=n.onProgress,p=yt(t),f=e._indirectBuffer;let u=!1;const l=new Float32Array(6),y=new Float32Array(6),m=ue(t,l),B=n.indirect?xe:me,T=[],d=n.indirect?$n(t):kn(t);if(d.length===1){const x=d[0],w=new Ct;w.boundingData=l,fe(m,x.offset,x.count,y),A(w,x.offset,x.count,y),T.push(w)}else for(let x of d){const w=new Ct;w.boundingData=new Float32Array(6),Yt(m,x.offset,x.count,w.boundingData,y),A(w,x.offset,x.count,y),T.push(w)}return T;function h(x){c&&c(x/p)}function A(x,w,b,_=null,P=0){if(!u&&P>=i&&(u=!0,a&&(console.warn("MeshBVH: Max depth of ".concat(i," reached when generating BVH. Consider increasing maxDepth.")),console.warn(t))),b<=r||P>=i)return h(w+b),x.offset=w,x.count=b,x;const M=ye(x.boundingData,_,m,w,b,o);if(M.axis===-1)return h(w+b),x.offset=w,x.count=b,x;const S=B(f,s,m,w,b,M);if(S===w||S===w+b)h(w+b),x.offset=w,x.count=b;else{x.splitAxis=M.axis;const F=new Ct,g=w,C=S-w;x.left=F,F.boundingData=new Float32Array(6),Yt(m,g,C,F.boundingData,y),A(F,g,C,y,P+1);const U=new Ct,v=S,E=b-C;x.right=U,U.boundingData=new Float32Array(6),Yt(m,v,E,U.boundingData,y),A(U,v,E,y,P+1)}return x}}function Ae(e,n){const t=e.geometry;n.indirect&&(e._indirectBuffer=he(t,n.useSharedArrayBuffer),ae(t)&&!n.verbose&&console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),e._indirectBuffer||ce(t,n);const s=we(e,n);let i,a,r;const o=[],c=n.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let u=0;u<s.length;u++){const l=s[u];let y=p(l);const m=new c($t*y);i=new Float32Array(m),a=new Uint32Array(m),r=new Uint16Array(m),f(0,l),o.push(m)}e._roots=o;return;function p(u){return u.count?1:1+p(u.left)+p(u.right)}function f(u,l){const y=u/4,m=u/2,B=!!l.count,T=l.boundingData;for(let d=0;d<6;d++)i[y+d]=T[d];if(B){const d=l.offset,h=l.count;return a[y+6]=d,r[m+14]=h,r[m+15]=Ht,u+$t}else{const d=l.left,h=l.right,A=l.splitAxis;let x;if(x=f(u+$t,d),x/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return a[y+6]=x/4,x=f(x,h),a[y+7]=A,x}}}class K{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(n,t){let s=1/0,i=-1/0;for(let a=0,r=n.length;a<r;a++){const c=n[a][t];s=c<s?c:s,i=c>i?c:i}this.min=s,this.max=i}setFromPoints(n,t){let s=1/0,i=-1/0;for(let a=0,r=t.length;a<r;a++){const o=t[a],c=n.dot(o);s=c<s?c:s,i=c>i?c:i}this.min=s,this.max=i}isSeparated(n){return this.min>n.max||n.min>this.max}}K.prototype.setFromBox=function(){const e=new L;return function(t,s){const i=s.min,a=s.max;let r=1/0,o=-1/0;for(let c=0;c<=1;c++)for(let p=0;p<=1;p++)for(let f=0;f<=1;f++){e.x=i.x*c+a.x*(1-c),e.y=i.y*p+a.y*(1-p),e.z=i.z*f+a.z*(1-f);const u=t.dot(e);r=Math.min(u,r),o=Math.max(u,o)}this.min=r,this.max=o}}();const Te=function(){const e=new L,n=new L,t=new L;return function(i,a,r){const o=i.start,c=e,p=a.start,f=n;t.subVectors(o,p),e.subVectors(i.end,i.start),n.subVectors(a.end,a.start);const u=t.dot(f),l=f.dot(c),y=f.dot(f),m=t.dot(c),T=c.dot(c)*y-l*l;let d,h;T!==0?d=(u*l-m*y)/T:d=0,h=(u+d*l)/y,r.x=d,r.y=h}}(),un=function(){const e=new nt,n=new L,t=new L;return function(i,a,r,o){Te(i,a,e);let c=e.x,p=e.y;if(c>=0&&c<=1&&p>=0&&p<=1){i.at(c,r),a.at(p,o);return}else if(c>=0&&c<=1){p<0?a.at(0,o):a.at(1,o),i.closestPointToPoint(o,!0,r);return}else if(p>=0&&p<=1){c<0?i.at(0,r):i.at(1,r),a.closestPointToPoint(r,!0,o);return}else{let f;c<0?f=i.start:f=i.end;let u;p<0?u=a.start:u=a.end;const l=n,y=t;if(i.closestPointToPoint(u,!0,n),a.closestPointToPoint(f,!0,t),l.distanceToSquared(u)<=y.distanceToSquared(f)){r.copy(l),o.copy(u);return}else{r.copy(f),o.copy(y);return}}}}(),be=function(){const e=new L,n=new L,t=new Rn,s=new Z;return function(a,r){const{radius:o,center:c}=a,{a:p,b:f,c:u}=r;if(s.start=p,s.end=f,s.closestPointToPoint(c,!0,e).distanceTo(c)<=o||(s.start=p,s.end=u,s.closestPointToPoint(c,!0,e).distanceTo(c)<=o)||(s.start=f,s.end=u,s.closestPointToPoint(c,!0,e).distanceTo(c)<=o))return!0;const B=r.getPlane(t);if(Math.abs(B.distanceToPoint(c))<=o){const d=B.projectPoint(c,n);if(r.containsPoint(d))return!0}return!1}}(),Be=1e-15;function Zt(e){return Math.abs(e)<Be}class j extends Pt{constructor(...n){super(...n),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new L),this.satBounds=new Array(4).fill().map(()=>new K),this.points=[this.a,this.b,this.c],this.sphere=new Kn,this.plane=new Rn,this.needsUpdate=!0}intersectsSphere(n){return be(n,this)}update(){const n=this.a,t=this.b,s=this.c,i=this.points,a=this.satAxes,r=this.satBounds,o=a[0],c=r[0];this.getNormal(o),c.setFromPoints(o,i);const p=a[1],f=r[1];p.subVectors(n,t),f.setFromPoints(p,i);const u=a[2],l=r[2];u.subVectors(t,s),l.setFromPoints(u,i);const y=a[3],m=r[3];y.subVectors(s,n),m.setFromPoints(y,i),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(o,n),this.needsUpdate=!1}}j.prototype.closestPointToSegment=function(){const e=new L,n=new L,t=new Z;return function(i,a=null,r=null){const{start:o,end:c}=i,p=this.points;let f,u=1/0;for(let l=0;l<3;l++){const y=(l+1)%3;t.start.copy(p[l]),t.end.copy(p[y]),un(t,i,e,n),f=e.distanceToSquared(n),f<u&&(u=f,a&&a.copy(e),r&&r.copy(n))}return this.closestPointToPoint(o,e),f=o.distanceToSquared(e),f<u&&(u=f,a&&a.copy(e),r&&r.copy(o)),this.closestPointToPoint(c,e),f=c.distanceToSquared(e),f<u&&(u=f,a&&a.copy(e),r&&r.copy(c)),Math.sqrt(u)}}();j.prototype.intersectsTriangle=function(){const e=new j,n=new Array(3),t=new Array(3),s=new K,i=new K,a=new L,r=new L,o=new L,c=new L,p=new L,f=new Z,u=new Z,l=new Z,y=new L;function m(B,T,d){const h=B.points;let A=0,x=-1;for(let w=0;w<3;w++){const{start:b,end:_}=f;b.copy(h[w]),_.copy(h[(w+1)%3]),f.delta(r);const P=Zt(T.distanceToPoint(b));if(Zt(T.normal.dot(r))&&P){d.copy(f),A=2;break}const M=T.intersectLine(f,y);if(!M&&P&&y.copy(b),(M||P)&&!Zt(y.distanceTo(_))){if(A<=1)(A===1?d.start:d.end).copy(y),P&&(x=A);else if(A>=2){(x===1?d.start:d.end).copy(y),A=2;break}if(A++,A===2&&x===-1)break}}return A}return function(T,d=null,h=!1){this.needsUpdate&&this.update(),T.isExtendedTriangle?T.needsUpdate&&T.update():(e.copy(T),e.update(),T=e);const A=this.plane,x=T.plane;if(Math.abs(A.normal.dot(x.normal))>1-1e-10){const w=this.satBounds,b=this.satAxes;t[0]=T.a,t[1]=T.b,t[2]=T.c;for(let M=0;M<4;M++){const S=w[M],F=b[M];if(s.setFromPoints(F,t),S.isSeparated(s))return!1}const _=T.satBounds,P=T.satAxes;n[0]=this.a,n[1]=this.b,n[2]=this.c;for(let M=0;M<4;M++){const S=_[M],F=P[M];if(s.setFromPoints(F,n),S.isSeparated(s))return!1}for(let M=0;M<4;M++){const S=b[M];for(let F=0;F<4;F++){const g=P[F];if(a.crossVectors(S,g),s.setFromPoints(a,n),i.setFromPoints(a,t),s.isSeparated(i))return!1}}return d&&(h||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),d.start.set(0,0,0),d.end.set(0,0,0)),!0}else{const w=m(this,x,u);if(w===1&&T.containsPoint(u.end))return d&&(d.start.copy(u.end),d.end.copy(u.end)),!0;if(w!==2)return!1;const b=m(T,A,l);if(b===1&&this.containsPoint(l.end))return d&&(d.start.copy(l.end),d.end.copy(l.end)),!0;if(b!==2)return!1;if(u.delta(o),l.delta(c),o.dot(c)<0){let C=l.start;l.start=l.end,l.end=C}const _=u.start.dot(o),P=u.end.dot(o),M=l.start.dot(o),S=l.end.dot(o),F=P<M,g=_<S;return _!==S&&M!==P&&F===g?!1:(d&&(p.subVectors(u.start,l.start),p.dot(o)>0?d.start.copy(u.start):d.start.copy(l.start),p.subVectors(u.end,l.end),p.dot(o)<0?d.end.copy(u.end):d.end.copy(l.end)),!0)}}}();j.prototype.distanceToPoint=function(){const e=new L;return function(t){return this.closestPointToPoint(t,e),t.distanceTo(e)}}();j.prototype.distanceToTriangle=function(){const e=new L,n=new L,t=["a","b","c"],s=new Z,i=new Z;return function(r,o=null,c=null){const p=o||c?s:null;if(this.intersectsTriangle(r,p))return(o||c)&&(o&&p.getCenter(o),c&&p.getCenter(c)),0;let f=1/0;for(let u=0;u<3;u++){let l;const y=t[u],m=r[y];this.closestPointToPoint(m,e),l=m.distanceToSquared(e),l<f&&(f=l,o&&o.copy(e),c&&c.copy(m));const B=this[y];r.closestPointToPoint(B,e),l=B.distanceToSquared(e),l<f&&(f=l,o&&o.copy(B),c&&c.copy(e))}for(let u=0;u<3;u++){const l=t[u],y=t[(u+1)%3];s.set(this[l],this[y]);for(let m=0;m<3;m++){const B=t[m],T=t[(m+1)%3];i.set(r[B],r[T]),un(s,i,e,n);const d=e.distanceToSquared(n);d<f&&(f=d,o&&o.copy(e),c&&c.copy(n))}}return Math.sqrt(f)}}();class R{constructor(n,t,s){this.isOrientedBox=!0,this.min=new L,this.max=new L,this.matrix=new O,this.invMatrix=new O,this.points=new Array(8).fill().map(()=>new L),this.satAxes=new Array(3).fill().map(()=>new L),this.satBounds=new Array(3).fill().map(()=>new K),this.alignedSatBounds=new Array(3).fill().map(()=>new K),this.needsUpdate=!1,n&&this.min.copy(n),t&&this.max.copy(t),s&&this.matrix.copy(s)}set(n,t,s){this.min.copy(n),this.max.copy(t),this.matrix.copy(s),this.needsUpdate=!0}copy(n){this.min.copy(n.min),this.max.copy(n.max),this.matrix.copy(n.matrix),this.needsUpdate=!0}}R.prototype.update=function(){return function(){const n=this.matrix,t=this.min,s=this.max,i=this.points;for(let p=0;p<=1;p++)for(let f=0;f<=1;f++)for(let u=0;u<=1;u++){const l=1*p|2*f|4*u,y=i[l];y.x=p?s.x:t.x,y.y=f?s.y:t.y,y.z=u?s.z:t.z,y.applyMatrix4(n)}const a=this.satBounds,r=this.satAxes,o=i[0];for(let p=0;p<3;p++){const f=r[p],u=a[p],l=1<<p,y=i[l];f.subVectors(o,y),u.setFromPoints(f,i)}const c=this.alignedSatBounds;c[0].setFromPointsField(i,"x"),c[1].setFromPointsField(i,"y"),c[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();R.prototype.intersectsBox=function(){const e=new K;return function(t){this.needsUpdate&&this.update();const s=t.min,i=t.max,a=this.satBounds,r=this.satAxes,o=this.alignedSatBounds;if(e.min=s.x,e.max=i.x,o[0].isSeparated(e)||(e.min=s.y,e.max=i.y,o[1].isSeparated(e))||(e.min=s.z,e.max=i.z,o[2].isSeparated(e)))return!1;for(let c=0;c<3;c++){const p=r[c],f=a[c];if(e.setFromBox(p,t),f.isSeparated(e))return!1}return!0}}();R.prototype.intersectsTriangle=function(){const e=new j,n=new Array(3),t=new K,s=new K,i=new L;return function(r){this.needsUpdate&&this.update(),r.isExtendedTriangle?r.needsUpdate&&r.update():(e.copy(r),e.update(),r=e);const o=this.satBounds,c=this.satAxes;n[0]=r.a,n[1]=r.b,n[2]=r.c;for(let l=0;l<3;l++){const y=o[l],m=c[l];if(t.setFromPoints(m,n),y.isSeparated(t))return!1}const p=r.satBounds,f=r.satAxes,u=this.points;for(let l=0;l<3;l++){const y=p[l],m=f[l];if(t.setFromPoints(m,u),y.isSeparated(t))return!1}for(let l=0;l<3;l++){const y=c[l];for(let m=0;m<4;m++){const B=f[m];if(i.crossVectors(y,B),t.setFromPoints(i,n),s.setFromPoints(i,u),t.isSeparated(s))return!1}}return!0}}();R.prototype.closestPointToPoint=function(){return function(n,t){return this.needsUpdate&&this.update(),t.copy(n).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),t}}();R.prototype.distanceToPoint=function(){const e=new L;return function(t){return this.closestPointToPoint(t,e),t.distanceTo(e)}}();R.prototype.distanceToBox=function(){const e=["x","y","z"],n=new Array(12).fill().map(()=>new Z),t=new Array(12).fill().map(()=>new Z),s=new L,i=new L;return function(r,o=0,c=null,p=null){if(this.needsUpdate&&this.update(),this.intersectsBox(r))return(c||p)&&(r.getCenter(i),this.closestPointToPoint(i,s),r.closestPointToPoint(s,i),c&&c.copy(s),p&&p.copy(i)),0;const f=o*o,u=r.min,l=r.max,y=this.points;let m=1/0;for(let T=0;T<8;T++){const d=y[T];i.copy(d).clamp(u,l);const h=d.distanceToSquared(i);if(h<m&&(m=h,c&&c.copy(d),p&&p.copy(i),h<f))return Math.sqrt(h)}let B=0;for(let T=0;T<3;T++)for(let d=0;d<=1;d++)for(let h=0;h<=1;h++){const A=(T+1)%3,x=(T+2)%3,w=d<<A|h<<x,b=1<<T|d<<A|h<<x,_=y[w],P=y[b];n[B].set(_,P);const S=e[T],F=e[A],g=e[x],C=t[B],U=C.start,v=C.end;U[S]=u[S],U[F]=d?u[F]:l[F],U[g]=h?u[g]:l[F],v[S]=l[S],v[F]=d?u[F]:l[F],v[g]=h?u[g]:l[F],B++}for(let T=0;T<=1;T++)for(let d=0;d<=1;d++)for(let h=0;h<=1;h++){i.x=T?l.x:u.x,i.y=d?l.y:u.y,i.z=h?l.z:u.z,this.closestPointToPoint(i,s);const A=i.distanceToSquared(s);if(A<m&&(m=A,c&&c.copy(s),p&&p.copy(i),A<f))return Math.sqrt(A)}for(let T=0;T<12;T++){const d=n[T];for(let h=0;h<12;h++){const A=t[h];un(d,A,s,i);const x=s.distanceToSquared(i);if(x<m&&(m=x,c&&c.copy(s),p&&p.copy(i),x<f))return Math.sqrt(x)}}return Math.sqrt(m)}}();class pn{constructor(n){this._getNewPrimitive=n,this._primitives=[]}getPrimitive(){const n=this._primitives;return n.length===0?this._getNewPrimitive():n.pop()}releasePrimitive(n){this._primitives.push(n)}}class Pe extends pn{constructor(){super(()=>new j)}}const q=new Pe;function V(e,n){return n[e+15]===65535}function N(e,n){return n[e+6]}function $(e,n){return n[e+14]}function k(e){return e+8}function H(e,n){return n[e+6]}function Hn(e,n){return n[e+7]}class ge{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const n=[];let t=null;this.setBuffer=s=>{t&&n.push(t),t=s,this.float32Array=new Float32Array(s),this.uint16Array=new Uint16Array(s),this.uint32Array=new Uint32Array(s)},this.clearBuffer=()=>{t=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,n.length!==0&&this.setBuffer(n.pop())}}}const z=new ge;let G,pt;const et=[],Ft=new pn(()=>new W);function _e(e,n,t,s,i,a){G=Ft.getPrimitive(),pt=Ft.getPrimitive(),et.push(G,pt),z.setBuffer(e._roots[n]);const r=en(0,e.geometry,t,s,i,a);z.clearBuffer(),Ft.releasePrimitive(G),Ft.releasePrimitive(pt),et.pop(),et.pop();const o=et.length;return o>0&&(pt=et[o-1],G=et[o-2]),r}function en(e,n,t,s,i=null,a=0,r=0){const{float32Array:o,uint16Array:c,uint32Array:p}=z;let f=e*2;if(V(f,c)){const l=N(e,p),y=$(f,c);return D(e,o,G),s(l,y,!1,r,a+e,G)}else{let S=function(g){const{uint16Array:C,uint32Array:U}=z;let v=g*2;for(;!V(v,C);)g=k(g),v=g*2;return N(g,U)},F=function(g){const{uint16Array:C,uint32Array:U}=z;let v=g*2;for(;!V(v,C);)g=H(g,U),v=g*2;return N(g,U)+$(v,C)};const l=k(e),y=H(e,p);let m=l,B=y,T,d,h,A;if(i&&(h=G,A=pt,D(m,o,h),D(B,o,A),T=i(h),d=i(A),d<T)){m=y,B=l;const g=T;T=d,d=g,h=A}h||(h=G,D(m,o,h));const x=V(m*2,c),w=t(h,x,T,r+1,a+m);let b;if(w===An){const g=S(m),U=F(m)-g;b=s(g,U,!0,r+1,a+m,h)}else b=w&&en(m,n,t,s,i,a,r+1);if(b)return!0;A=pt,D(B,o,A);const _=V(B*2,c),P=t(A,_,d,r+1,a+B);let M;if(P===An){const g=S(B),U=F(B)-g;M=s(g,U,!0,r+1,a+B,A)}else M=P&&en(B,n,t,s,i,a,r+1);return!!M}}const wt=new L,Kt=new L;function Me(e,n,t={},s=0,i=1/0){const a=s*s,r=i*i;let o=1/0,c=null;if(e.shapecast({boundsTraverseOrder:f=>(wt.copy(n).clamp(f.min,f.max),wt.distanceToSquared(n)),intersectsBounds:(f,u,l)=>l<o&&l<r,intersectsTriangle:(f,u)=>{f.closestPointToPoint(n,wt);const l=n.distanceToSquared(wt);return l<o&&(Kt.copy(wt),o=l,c=u),l<a}}),o===1/0)return null;const p=Math.sqrt(o);return t.point?t.point.copy(Kt):t.point=Kt.clone(),t.distance=p,t.faceIndex=c,t}const st=new L,it=new L,rt=new L,Lt=new nt,Ut=new nt,vt=new nt,gn=new L,_n=new L,Mn=new L,zt=new L;function Se(e,n,t,s,i,a){let r;return a===Jn?r=e.intersectTriangle(s,t,n,!0,i):r=e.intersectTriangle(n,t,s,a!==Vn,i),r===null?null:{distance:e.origin.distanceTo(i),point:i.clone()}}function Ce(e,n,t,s,i,a,r,o,c){st.fromBufferAttribute(n,a),it.fromBufferAttribute(n,r),rt.fromBufferAttribute(n,o);const p=Se(e,st,it,rt,zt,c);if(p){s&&(Lt.fromBufferAttribute(s,a),Ut.fromBufferAttribute(s,r),vt.fromBufferAttribute(s,o),p.uv=Pt.getInterpolation(zt,st,it,rt,Lt,Ut,vt,new nt)),i&&(Lt.fromBufferAttribute(i,a),Ut.fromBufferAttribute(i,r),vt.fromBufferAttribute(i,o),p.uv1=Pt.getInterpolation(zt,st,it,rt,Lt,Ut,vt,new nt)),t&&(gn.fromBufferAttribute(t,a),_n.fromBufferAttribute(t,r),Mn.fromBufferAttribute(t,o),p.normal=Pt.getInterpolation(zt,st,it,rt,gn,_n,Mn,new L),p.normal.dot(e.direction)>0&&p.normal.multiplyScalar(-1));const f={a,b:r,c:o,normal:new L,materialIndex:0};Pt.getNormal(st,it,rt,f.normal),p.face=f,p.faceIndex=a}return p}function Xt(e,n,t,s,i){const a=s*3;let r=a+0,o=a+1,c=a+2;const p=e.index;e.index&&(r=p.getX(r),o=p.getX(o),c=p.getX(c));const{position:f,normal:u,uv:l,uv1:y}=e.attributes,m=Ce(t,f,u,l,y,r,o,c,n);return m?(m.faceIndex=s,i&&i.push(m),m):null}function I(e,n,t,s){const i=e.a,a=e.b,r=e.c;let o=n,c=n+1,p=n+2;t&&(o=t.getX(o),c=t.getX(c),p=t.getX(p)),i.x=s.getX(o),i.y=s.getY(o),i.z=s.getZ(o),a.x=s.getX(c),a.y=s.getY(c),a.z=s.getZ(c),r.x=s.getX(p),r.y=s.getY(p),r.z=s.getZ(p)}function Fe(e,n,t,s,i,a){const{geometry:r,_indirectBuffer:o}=e;for(let c=s,p=s+i;c<p;c++)Xt(r,n,t,c,a)}function Le(e,n,t,s,i){const{geometry:a,_indirectBuffer:r}=e;let o=1/0,c=null;for(let p=s,f=s+i;p<f;p++){let u;u=Xt(a,n,t,p),u&&u.distance<o&&(c=u,o=u.distance)}return c}function Ue(e,n,t,s,i,a,r){const{geometry:o}=t,{index:c}=o,p=o.attributes.position;for(let f=e,u=n+e;f<u;f++){let l;if(l=f,I(r,l*3,c,p),r.needsUpdate=!0,s(r,l,i,a))return!0}return!1}function ve(e,n=null){n&&Array.isArray(n)&&(n=new Set(n));const t=e.geometry,s=t.index?t.index.array:null,i=t.attributes.position;let a,r,o,c,p=0;const f=e._roots;for(let l=0,y=f.length;l<y;l++)a=f[l],r=new Uint32Array(a),o=new Uint16Array(a),c=new Float32Array(a),u(0,p),p+=a.byteLength;function u(l,y,m=!1){const B=l*2;if(o[B+15]===Ht){const d=r[l+6],h=o[B+14];let A=1/0,x=1/0,w=1/0,b=-1/0,_=-1/0,P=-1/0;for(let M=3*d,S=3*(d+h);M<S;M++){let F=s[M];const g=i.getX(F),C=i.getY(F),U=i.getZ(F);g<A&&(A=g),g>b&&(b=g),C<x&&(x=C),C>_&&(_=C),U<w&&(w=U),U>P&&(P=U)}return c[l+0]!==A||c[l+1]!==x||c[l+2]!==w||c[l+3]!==b||c[l+4]!==_||c[l+5]!==P?(c[l+0]=A,c[l+1]=x,c[l+2]=w,c[l+3]=b,c[l+4]=_,c[l+5]=P,!0):!1}else{const d=l+8,h=r[l+6],A=d+y,x=h+y;let w=m,b=!1,_=!1;n?w||(b=n.has(A),_=n.has(x),w=!b&&!_):(b=!0,_=!0);const P=w||b,M=w||_;let S=!1;P&&(S=u(d,y,w));let F=!1;M&&(F=u(h,y,w));const g=S||F;if(g)for(let C=0;C<3;C++){const U=d+C,v=h+C,E=c[U],dt=c[U+3],mt=c[v],xt=c[v+3];c[l+C]=E<mt?E:mt,c[l+C+3]=dt>xt?dt:xt}return g}}}const Sn=new W;function tt(e,n,t,s){return D(e,n,Sn),t.intersectBox(Sn,s)}function ze(e,n,t,s,i,a){const{geometry:r,_indirectBuffer:o}=e;for(let c=s,p=s+i;c<p;c++){let f=o?o[c]:c;Xt(r,n,t,f,a)}}function De(e,n,t,s,i){const{geometry:a,_indirectBuffer:r}=e;let o=1/0,c=null;for(let p=s,f=s+i;p<f;p++){let u;u=Xt(a,n,t,r?r[p]:p),u&&u.distance<o&&(c=u,o=u.distance)}return c}function Ee(e,n,t,s,i,a,r){const{geometry:o}=t,{index:c}=o,p=o.attributes.position;for(let f=e,u=n+e;f<u;f++){let l;if(l=t.resolveTriangleIndex(f),I(r,l*3,c,p),r.needsUpdate=!0,s(r,l,i,a))return!0}return!1}const Cn=new L;function Ie(e,n,t,s,i){z.setBuffer(e._roots[n]),sn(0,e,t,s,i),z.clearBuffer()}function sn(e,n,t,s,i){const{float32Array:a,uint16Array:r,uint32Array:o}=z,c=e*2;if(V(c,r)){const f=N(e,o),u=$(c,r);Fe(n,t,s,f,u,i)}else{const f=k(e);tt(f,a,s,Cn)&&sn(f,n,t,s,i);const u=H(e,o);tt(u,a,s,Cn)&&sn(u,n,t,s,i)}}const Fn=new L,Re=["x","y","z"];function Ve(e,n,t,s){z.setBuffer(e._roots[n]);const i=rn(0,e,t,s);return z.clearBuffer(),i}function rn(e,n,t,s){const{float32Array:i,uint16Array:a,uint32Array:r}=z;let o=e*2;if(V(o,a)){const p=N(e,r),f=$(o,a);return Le(n,t,s,p,f)}else{const p=Hn(e,r),f=Re[p],l=s.direction[f]>=0;let y,m;l?(y=k(e),m=H(e,r)):(y=H(e,r),m=k(e));const T=tt(y,i,s,Fn)?rn(y,n,t,s):null;if(T){const A=T.point[f];if(l?A<=i[m+p]:A>=i[m+p+3])return T}const h=tt(m,i,s,Fn)?rn(m,n,t,s):null;return T&&h?T.distance<=h.distance?T:h:T||h||null}}const Dt=new W,ot=new j,ct=new j,At=new O,Ln=new R,Et=new R;function Ne(e,n,t,s){z.setBuffer(e._roots[n]);const i=on(0,e,t,s);return z.clearBuffer(),i}function on(e,n,t,s,i=null){const{float32Array:a,uint16Array:r,uint32Array:o}=z;let c=e*2;if(i===null&&(t.boundingBox||t.computeBoundingBox(),Ln.set(t.boundingBox.min,t.boundingBox.max,s),i=Ln),V(c,r)){const f=n.geometry,u=f.index,l=f.attributes.position,y=t.index,m=t.attributes.position,B=N(e,o),T=$(c,r);if(At.copy(s).invert(),t.boundsTree)return D(e,a,Et),Et.matrix.copy(At),Et.needsUpdate=!0,t.boundsTree.shapecast({intersectsBounds:h=>Et.intersectsBox(h),intersectsTriangle:h=>{h.a.applyMatrix4(s),h.b.applyMatrix4(s),h.c.applyMatrix4(s),h.needsUpdate=!0;for(let A=B*3,x=(T+B)*3;A<x;A+=3)if(I(ct,A,u,l),ct.needsUpdate=!0,h.intersectsTriangle(ct))return!0;return!1}});for(let d=B*3,h=(T+B)*3;d<h;d+=3){I(ot,d,u,l),ot.a.applyMatrix4(At),ot.b.applyMatrix4(At),ot.c.applyMatrix4(At),ot.needsUpdate=!0;for(let A=0,x=y.count;A<x;A+=3)if(I(ct,A,y,m),ct.needsUpdate=!0,ot.intersectsTriangle(ct))return!0}}else{const f=e+8,u=o[e+6];return D(f,a,Dt),!!(i.intersectsBox(Dt)&&on(f,n,t,s,i)||(D(u,a,Dt),i.intersectsBox(Dt)&&on(u,n,t,s,i)))}}const It=new O,Jt=new R,Tt=new R,qe=new L,$e=new L,ke=new L,He=new L;function Xe(e,n,t,s={},i={},a=0,r=1/0){n.boundingBox||n.computeBoundingBox(),Jt.set(n.boundingBox.min,n.boundingBox.max,t),Jt.needsUpdate=!0;const o=e.geometry,c=o.attributes.position,p=o.index,f=n.attributes.position,u=n.index,l=q.getPrimitive(),y=q.getPrimitive();let m=qe,B=$e,T=null,d=null;i&&(T=ke,d=He);let h=1/0,A=null,x=null;return It.copy(t).invert(),Tt.matrix.copy(It),e.shapecast({boundsTraverseOrder:w=>Jt.distanceToBox(w),intersectsBounds:(w,b,_)=>_<h&&_<r?(b&&(Tt.min.copy(w.min),Tt.max.copy(w.max),Tt.needsUpdate=!0),!0):!1,intersectsRange:(w,b)=>{if(n.boundsTree)return n.boundsTree.shapecast({boundsTraverseOrder:P=>Tt.distanceToBox(P),intersectsBounds:(P,M,S)=>S<h&&S<r,intersectsRange:(P,M)=>{for(let S=P,F=P+M;S<F;S++){I(y,3*S,u,f),y.a.applyMatrix4(t),y.b.applyMatrix4(t),y.c.applyMatrix4(t),y.needsUpdate=!0;for(let g=w,C=w+b;g<C;g++){I(l,3*g,p,c),l.needsUpdate=!0;const U=l.distanceToTriangle(y,m,T);if(U<h&&(B.copy(m),d&&d.copy(T),h=U,A=g,x=S),U<a)return!0}}}});{const _=yt(n);for(let P=0,M=_;P<M;P++){I(y,3*P,u,f),y.a.applyMatrix4(t),y.b.applyMatrix4(t),y.c.applyMatrix4(t),y.needsUpdate=!0;for(let S=w,F=w+b;S<F;S++){I(l,3*S,p,c),l.needsUpdate=!0;const g=l.distanceToTriangle(y,m,T);if(g<h&&(B.copy(m),d&&d.copy(T),h=g,A=S,x=P),g<a)return!0}}}}}),q.releasePrimitive(l),q.releasePrimitive(y),h===1/0?null:(s.point?s.point.copy(B):s.point=B.clone(),s.distance=h,s.faceIndex=A,i&&(i.point?i.point.copy(d):i.point=d.clone(),i.point.applyMatrix4(It),B.applyMatrix4(It),i.distance=B.sub(i.point).length(),i.faceIndex=x),s)}function je(e,n=null){n&&Array.isArray(n)&&(n=new Set(n));const t=e.geometry,s=t.index?t.index.array:null,i=t.attributes.position;let a,r,o,c,p=0;const f=e._roots;for(let l=0,y=f.length;l<y;l++)a=f[l],r=new Uint32Array(a),o=new Uint16Array(a),c=new Float32Array(a),u(0,p),p+=a.byteLength;function u(l,y,m=!1){const B=l*2;if(o[B+15]===Ht){const d=r[l+6],h=o[B+14];let A=1/0,x=1/0,w=1/0,b=-1/0,_=-1/0,P=-1/0;for(let M=d,S=d+h;M<S;M++){const F=3*e.resolveTriangleIndex(M);for(let g=0;g<3;g++){let C=F+g;C=s?s[C]:C;const U=i.getX(C),v=i.getY(C),E=i.getZ(C);U<A&&(A=U),U>b&&(b=U),v<x&&(x=v),v>_&&(_=v),E<w&&(w=E),E>P&&(P=E)}}return c[l+0]!==A||c[l+1]!==x||c[l+2]!==w||c[l+3]!==b||c[l+4]!==_||c[l+5]!==P?(c[l+0]=A,c[l+1]=x,c[l+2]=w,c[l+3]=b,c[l+4]=_,c[l+5]=P,!0):!1}else{const d=l+8,h=r[l+6],A=d+y,x=h+y;let w=m,b=!1,_=!1;n?w||(b=n.has(A),_=n.has(x),w=!b&&!_):(b=!0,_=!0);const P=w||b,M=w||_;let S=!1;P&&(S=u(d,y,w));let F=!1;M&&(F=u(h,y,w));const g=S||F;if(g)for(let C=0;C<3;C++){const U=d+C,v=h+C,E=c[U],dt=c[U+3],mt=c[v],xt=c[v+3];c[l+C]=E<mt?E:mt,c[l+C+3]=dt>xt?dt:xt}return g}}}const Un=new L;function We(e,n,t,s,i){z.setBuffer(e._roots[n]),cn(0,e,t,s,i),z.clearBuffer()}function cn(e,n,t,s,i){const{float32Array:a,uint16Array:r,uint32Array:o}=z,c=e*2;if(V(c,r)){const f=N(e,o),u=$(c,r);ze(n,t,s,f,u,i)}else{const f=k(e);tt(f,a,s,Un)&&cn(f,n,t,s,i);const u=H(e,o);tt(u,a,s,Un)&&cn(u,n,t,s,i)}}const vn=new L,Ye=["x","y","z"];function Ze(e,n,t,s){z.setBuffer(e._roots[n]);const i=an(0,e,t,s);return z.clearBuffer(),i}function an(e,n,t,s){const{float32Array:i,uint16Array:a,uint32Array:r}=z;let o=e*2;if(V(o,a)){const p=N(e,r),f=$(o,a);return De(n,t,s,p,f)}else{const p=Hn(e,r),f=Ye[p],l=s.direction[f]>=0;let y,m;l?(y=k(e),m=H(e,r)):(y=H(e,r),m=k(e));const T=tt(y,i,s,vn)?an(y,n,t,s):null;if(T){const A=T.point[f];if(l?A<=i[m+p]:A>=i[m+p+3])return T}const h=tt(m,i,s,vn)?an(m,n,t,s):null;return T&&h?T.distance<=h.distance?T:h:T||h||null}}const Rt=new W,at=new j,lt=new j,bt=new O,zn=new R,Vt=new R;function Ke(e,n,t,s){z.setBuffer(e._roots[n]);const i=ln(0,e,t,s);return z.clearBuffer(),i}function ln(e,n,t,s,i=null){const{float32Array:a,uint16Array:r,uint32Array:o}=z;let c=e*2;if(i===null&&(t.boundingBox||t.computeBoundingBox(),zn.set(t.boundingBox.min,t.boundingBox.max,s),i=zn),V(c,r)){const f=n.geometry,u=f.index,l=f.attributes.position,y=t.index,m=t.attributes.position,B=N(e,o),T=$(c,r);if(bt.copy(s).invert(),t.boundsTree)return D(e,a,Vt),Vt.matrix.copy(bt),Vt.needsUpdate=!0,t.boundsTree.shapecast({intersectsBounds:h=>Vt.intersectsBox(h),intersectsTriangle:h=>{h.a.applyMatrix4(s),h.b.applyMatrix4(s),h.c.applyMatrix4(s),h.needsUpdate=!0;for(let A=B,x=T+B;A<x;A++)if(I(lt,3*n.resolveTriangleIndex(A),u,l),lt.needsUpdate=!0,h.intersectsTriangle(lt))return!0;return!1}});for(let d=B,h=T+B;d<h;d++){const A=n.resolveTriangleIndex(d);I(at,3*A,u,l),at.a.applyMatrix4(bt),at.b.applyMatrix4(bt),at.c.applyMatrix4(bt),at.needsUpdate=!0;for(let x=0,w=y.count;x<w;x+=3)if(I(lt,x,y,m),lt.needsUpdate=!0,at.intersectsTriangle(lt))return!0}}else{const f=e+8,u=o[e+6];return D(f,a,Rt),!!(i.intersectsBox(Rt)&&ln(f,n,t,s,i)||(D(u,a,Rt),i.intersectsBox(Rt)&&ln(u,n,t,s,i)))}}const Nt=new O,Qt=new R,Bt=new R,Je=new L,Qe=new L,Ge=new L,Oe=new L;function ts(e,n,t,s={},i={},a=0,r=1/0){n.boundingBox||n.computeBoundingBox(),Qt.set(n.boundingBox.min,n.boundingBox.max,t),Qt.needsUpdate=!0;const o=e.geometry,c=o.attributes.position,p=o.index,f=n.attributes.position,u=n.index,l=q.getPrimitive(),y=q.getPrimitive();let m=Je,B=Qe,T=null,d=null;i&&(T=Ge,d=Oe);let h=1/0,A=null,x=null;return Nt.copy(t).invert(),Bt.matrix.copy(Nt),e.shapecast({boundsTraverseOrder:w=>Qt.distanceToBox(w),intersectsBounds:(w,b,_)=>_<h&&_<r?(b&&(Bt.min.copy(w.min),Bt.max.copy(w.max),Bt.needsUpdate=!0),!0):!1,intersectsRange:(w,b)=>{if(n.boundsTree){const _=n.boundsTree;return _.shapecast({boundsTraverseOrder:P=>Bt.distanceToBox(P),intersectsBounds:(P,M,S)=>S<h&&S<r,intersectsRange:(P,M)=>{for(let S=P,F=P+M;S<F;S++){const g=_.resolveTriangleIndex(S);I(y,3*g,u,f),y.a.applyMatrix4(t),y.b.applyMatrix4(t),y.c.applyMatrix4(t),y.needsUpdate=!0;for(let C=w,U=w+b;C<U;C++){const v=e.resolveTriangleIndex(C);I(l,3*v,p,c),l.needsUpdate=!0;const E=l.distanceToTriangle(y,m,T);if(E<h&&(B.copy(m),d&&d.copy(T),h=E,A=C,x=S),E<a)return!0}}}})}else{const _=yt(n);for(let P=0,M=_;P<M;P++){I(y,3*P,u,f),y.a.applyMatrix4(t),y.b.applyMatrix4(t),y.c.applyMatrix4(t),y.needsUpdate=!0;for(let S=w,F=w+b;S<F;S++){const g=e.resolveTriangleIndex(S);I(l,3*g,p,c),l.needsUpdate=!0;const C=l.distanceToTriangle(y,m,T);if(C<h&&(B.copy(m),d&&d.copy(T),h=C,A=S,x=P),C<a)return!0}}}}}),q.releasePrimitive(l),q.releasePrimitive(y),h===1/0?null:(s.point?s.point.copy(B):s.point=B.clone(),s.distance=h,s.faceIndex=A,i&&(i.point?i.point.copy(d):i.point=d.clone(),i.point.applyMatrix4(Nt),B.applyMatrix4(Nt),i.distance=B.sub(i.point).length(),i.faceIndex=x),s)}function ns(){return typeof SharedArrayBuffer<"u"}const gt=new z.constructor,kt=new z.constructor,Q=new pn(()=>new W),ft=new W,ut=new W,Gt=new W,Ot=new W;let tn=!1;function es(e,n,t,s){if(tn)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");tn=!0;const i=e._roots,a=n._roots;let r,o=0,c=0;const p=new O().copy(t).invert();for(let f=0,u=i.length;f<u;f++){gt.setBuffer(i[f]),c=0;const l=Q.getPrimitive();D(0,gt.float32Array,l),l.applyMatrix4(p);for(let y=0,m=a.length;y<m&&(kt.setBuffer(a[f]),r=X(0,0,t,p,s,o,c,0,0,l),kt.clearBuffer(),c+=a[y].length,!r);y++);if(Q.releasePrimitive(l),gt.clearBuffer(),o+=i[f].length,r)break}return tn=!1,r}function X(e,n,t,s,i,a=0,r=0,o=0,c=0,p=null,f=!1){let u,l;f?(u=kt,l=gt):(u=gt,l=kt);const y=u.float32Array,m=u.uint32Array,B=u.uint16Array,T=l.float32Array,d=l.uint32Array,h=l.uint16Array,A=e*2,x=n*2,w=V(A,B),b=V(x,h);let _=!1;if(b&&w)f?_=i(N(n,d),$(n*2,h),N(e,m),$(e*2,B),c,r+n,o,a+e):_=i(N(e,m),$(e*2,B),N(n,d),$(n*2,h),o,a+e,c,r+n);else if(b){const P=Q.getPrimitive();D(n,T,P),P.applyMatrix4(t);const M=k(e),S=H(e,m);D(M,y,ft),D(S,y,ut);const F=P.intersectsBox(ft),g=P.intersectsBox(ut);_=F&&X(n,M,s,t,i,r,a,c,o+1,P,!f)||g&&X(n,S,s,t,i,r,a,c,o+1,P,!f),Q.releasePrimitive(P)}else{const P=k(n),M=H(n,d);D(P,T,Gt),D(M,T,Ot);const S=p.intersectsBox(Gt),F=p.intersectsBox(Ot);if(S&&F)_=X(e,P,t,s,i,a,r,o,c+1,p,f)||X(e,M,t,s,i,a,r,o,c+1,p,f);else if(S)if(w)_=X(e,P,t,s,i,a,r,o,c+1,p,f);else{const g=Q.getPrimitive();g.copy(Gt).applyMatrix4(t);const C=k(e),U=H(e,m);D(C,y,ft),D(U,y,ut);const v=g.intersectsBox(ft),E=g.intersectsBox(ut);_=v&&X(P,C,s,t,i,r,a,c,o+1,g,!f)||E&&X(P,U,s,t,i,r,a,c,o+1,g,!f),Q.releasePrimitive(g)}else if(F)if(w)_=X(e,M,t,s,i,a,r,o,c+1,p,f);else{const g=Q.getPrimitive();g.copy(Ot).applyMatrix4(t);const C=k(e),U=H(e,m);D(C,y,ft),D(U,y,ut);const v=g.intersectsBox(ft),E=g.intersectsBox(ut);_=v&&X(M,C,s,t,i,r,a,c,o+1,g,!f)||E&&X(M,U,s,t,i,r,a,c,o+1,g,!f),Q.releasePrimitive(g)}}return _}const qt=new R,Dn=new W;class yn{static serialize(n,t={}){t=_t({cloneBuffers:!0},t);const s=n.geometry,i=n._roots,a=n._indirectBuffer,r=s.getIndex();let o;return t.cloneBuffers?o={roots:i.map(c=>c.slice()),index:r.array.slice(),indirectBuffer:a?a.slice():null}:o={roots:i,index:r.array,indirectBuffer:a},o}static deserialize(n,t,s={}){s=_t({setIndex:!0,indirect:!!n.indirectBuffer},s);const{index:i,roots:a,indirectBuffer:r}=n,o=new yn(t,xn(_t({},s),{[Wt]:!0}));if(o._roots=a,o._indirectBuffer=r||null,s.setIndex){const c=t.getIndex();if(c===null){const p=new fn(n.index,1,!1);t.setIndex(p)}else c.array!==i&&(c.array.set(i),c.needsUpdate=!0)}return o}get indirect(){return!!this._indirectBuffer}constructor(n,t={}){if(n.isBufferGeometry){if(n.index&&n.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t=Object.assign({strategy:qn,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,[Wt]:!1},t),t.useSharedArrayBuffer&&!ns())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=n,this._roots=null,this._indirectBuffer=null,t[Wt]||(Ae(this,t),!n.boundingBox&&t.setBoundingBox&&(n.boundingBox=this.getBoundingBox(new W)));const{_indirectBuffer:s}=this;this.resolveTriangleIndex=t.indirect?i=>s[i]:i=>i}refit(n=null){return(this.indirect?je:ve)(this,n)}traverse(n,t=0){const s=this._roots[t],i=new Uint32Array(s),a=new Uint16Array(s);r(0);function r(o,c=0){const p=o*2,f=a[p+15]===Ht;if(f){const u=i[o+6],l=a[p+14];n(c,f,new Float32Array(s,o*4,6),u,l)}else{const u=o+$t/4,l=i[o+6],y=i[o+7];n(c,f,new Float32Array(s,o*4,6),y)||(r(u,c+1),r(l,c+1))}}}raycast(n,t=hn){const s=this._roots,i=this.geometry,a=[],r=t.isMaterial,o=Array.isArray(t),c=i.groups,p=r?t.side:t,f=this.indirect?We:Ie;for(let u=0,l=s.length;u<l;u++){const y=o?t[c[u].materialIndex].side:p,m=a.length;if(f(this,u,y,n,a),o){const B=c[u].materialIndex;for(let T=m,d=a.length;T<d;T++)a[T].face.materialIndex=B}}return a}raycastFirst(n,t=hn){const s=this._roots,i=this.geometry,a=t.isMaterial,r=Array.isArray(t);let o=null;const c=i.groups,p=a?t.side:t,f=this.indirect?Ze:Ve;for(let u=0,l=s.length;u<l;u++){const y=r?t[c[u].materialIndex].side:p,m=f(this,u,y,n);m!=null&&(o==null||m.distance<o.distance)&&(o=m,r&&(m.face.materialIndex=c[u].materialIndex))}return o}intersectsGeometry(n,t){let s=!1;const i=this._roots,a=this.indirect?Ke:Ne;for(let r=0,o=i.length;r<o&&(s=a(this,r,n,t),!s);r++);return s}shapecast(n){const t=q.getPrimitive(),s=this.indirect?Ee:Ue;let{boundsTraverseOrder:i,intersectsBounds:a,intersectsRange:r,intersectsTriangle:o}=n;if(r&&o){const u=r;r=(l,y,m,B,T)=>u(l,y,m,B,T)?!0:s(l,y,this,o,m,B,t)}else r||(o?r=(u,l,y,m)=>s(u,l,this,o,y,m,t):r=(u,l,y)=>y);let c=!1,p=0;const f=this._roots;for(let u=0,l=f.length;u<l;u++){const y=f[u];if(c=_e(this,u,a,r,i,p),c)break;p+=y.byteLength}return q.releasePrimitive(t),c}bvhcast(n,t,s){let{intersectsRanges:i,intersectsTriangles:a}=s;const r=q.getPrimitive(),o=this.geometry.index,c=this.geometry.attributes.position,p=this.indirect?m=>{const B=this.resolveTriangleIndex(m);I(r,B*3,o,c)}:m=>{I(r,m*3,o,c)},f=q.getPrimitive(),u=n.geometry.index,l=n.geometry.attributes.position,y=n.indirect?m=>{const B=n.resolveTriangleIndex(m);I(f,B*3,u,l)}:m=>{I(f,m*3,u,l)};if(a){const m=(B,T,d,h,A,x,w,b)=>{for(let _=d,P=d+h;_<P;_++){y(_),f.a.applyMatrix4(t),f.b.applyMatrix4(t),f.c.applyMatrix4(t),f.needsUpdate=!0;for(let M=B,S=B+T;M<S;M++)if(p(M),r.needsUpdate=!0,a(r,f,M,_,A,x,w,b))return!0}return!1};if(i){const B=i;i=function(T,d,h,A,x,w,b,_){return B(T,d,h,A,x,w,b,_)?!0:m(T,d,h,A,x,w,b,_)}}else i=m}return es(this,n,t,i)}intersectsBox(n,t){return qt.set(n.min,n.max,t),qt.needsUpdate=!0,this.shapecast({intersectsBounds:s=>qt.intersectsBox(s),intersectsTriangle:s=>qt.intersectsTriangle(s)})}intersectsSphere(n){return this.shapecast({intersectsBounds:t=>n.intersectsBox(t),intersectsTriangle:t=>t.intersectsSphere(n)})}closestPointToGeometry(n,t,s={},i={},a=0,r=1/0){return(this.indirect?ts:Xe)(this,n,t,s,i,a,r)}closestPointToPoint(n,t={},s=0,i=1/0){return Me(this,n,t,s,i)}getBoundingBox(n){return n.makeEmpty(),this._roots.forEach(s=>{D(0,new Float32Array(s),Dn),n.union(Dn)}),n}}function En(e,n,t){return e===null||(e.point.applyMatrix4(n.matrixWorld),e.distance=e.point.distanceTo(t.ray.origin),e.object=n,e.distance<t.near||e.distance>t.far)?null:e}const nn=new Qn,In=new O,ss=Nn.prototype.raycast;function is(e,n){if(this.geometry.boundsTree){if(this.material===void 0)return;In.copy(this.matrixWorld).invert(),nn.copy(e.ray).applyMatrix4(In);const t=this.geometry.boundsTree;if(e.firstHitOnly===!0){const s=En(t.raycastFirst(nn,this.material),this,e);s&&n.push(s)}else{const s=t.raycast(nn,this.material);for(let i=0,a=s.length;i<a;i++){const r=En(s[i],this,e);r&&n.push(r)}}}else ss.call(this,e,n)}function rs(e){return this.boundsTree=new yn(this,e),this.boundsTree}function os(){this.boundsTree=null}const cs=e=>{e.computeBoundingBox();const{max:n,min:t}=e.boundingBox;e.deleteAttribute("uv");const s=n.x-t.x,i=n.y-t.y,a=[];for(let o=0;o<e.attributes.position.count;o++)a.push((e.attributes.position.getX(o)-t.x)/s),a.push((e.attributes.position.getY(o)-t.y)/i);const r=new Float32Array(a);e.setAttribute("uv",new fn(r,2))},us=(e,n)=>new Promise((t,s)=>{Gn(e,{},{method:"get"}).then(i=>{n&&t(i.dataType),t(i.features)}).catch(i=>{console.err(i),s(error)})}),ps=()=>{wn.prototype.computeBoundsTree=rs,wn.prototype.disposeBoundsTree=os,Nn.prototype.raycast=is},ys=async e=>{const n=await On(["./plugins/water/images/Water_1_M_Normal.jpg","./plugins/water/images/Water_2_M_Normal.jpg"]),t=e.geometry.clone();cs(t),t.computeBoundsTree();const s=new ne(t,{color:new te("#fff"),scale:20,flowDirection:new nt(1,1),textureWidth:1024,textureHeight:1024,normalMap0:n[0],normalMap1:n[1]});return s.material.transparent=!0,s.material.depthWrite=!0,s.material.depthTest=!0,s.material.side=Vn,s.material.uniforms.config.value.w=20,s.material.uniforms.reflectivity.value=.46,s};export{is as a,rs as c,os as d,ps as i,us as l,cs as r,ys as s};
