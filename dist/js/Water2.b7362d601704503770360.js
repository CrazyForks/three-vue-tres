import{b4 as N,bd as H,aN as S,aE as E,a$ as F,be as L,bt as A,aU as j,bq as B,aF as v,b0 as P,bx as V,aW as q,by as I,bo as k,ba as O,aZ as Q}from"./vendor.7b32672f1704503770360.js";import{R as z}from"./Reflector.d82656a41704503770360.js";class y extends N{constructor(h,r={}){super(h),this.isRefractor=!0,this.type="Refractor",this.camera=new H;const l=this,_=r.color!==void 0?new S(r.color):new S(8355711),M=r.textureWidth||512,b=r.textureHeight||512,W=r.clipBias||0,m=r.shader||y.RefractorShader,D=r.multisample!==void 0?r.multisample:4,n=this.camera;n.matrixAutoUpdate=!1,n.userData.refractor=!0;const R=new E,f=new F,d=new L(M,b,{samples:D,type:A});this.material=new j({name:m.name!==void 0?m.name:"unspecified",uniforms:B.clone(m.uniforms),vertexShader:m.vertexShader,fragmentShader:m.fragmentShader,transparent:!0}),this.material.uniforms.color.value=_,this.material.uniforms.tDiffuse.value=d.texture,this.material.uniforms.textureMatrix.value=f;const C=function(){const e=new v,a=new v,t=new F,i=new v,s=new v;return function(c){return e.setFromMatrixPosition(l.matrixWorld),a.setFromMatrixPosition(c.matrixWorld),i.subVectors(e,a),t.extractRotation(l.matrixWorld),s.set(0,0,1),s.applyMatrix4(t),i.dot(s)<0}}(),w=function(){const e=new v,a=new v,t=new V,i=new v;return function(){l.matrixWorld.decompose(a,t,i),e.set(0,0,1).applyQuaternion(t).normalize(),e.negate(),R.setFromNormalAndCoplanarPoint(e,a)}}(),g=function(){const e=new E,a=new P,t=new P;return function(s){n.matrixWorld.copy(s.matrixWorld),n.matrixWorldInverse.copy(n.matrixWorld).invert(),n.projectionMatrix.copy(s.projectionMatrix),n.far=s.far,e.copy(R),e.applyMatrix4(n.matrixWorldInverse),a.set(e.normal.x,e.normal.y,e.normal.z,e.constant);const o=n.projectionMatrix;t.x=(Math.sign(a.x)+o.elements[8])/o.elements[0],t.y=(Math.sign(a.y)+o.elements[9])/o.elements[5],t.z=-1,t.w=(1+o.elements[10])/o.elements[14],a.multiplyScalar(2/a.dot(t)),o.elements[2]=a.x,o.elements[6]=a.y,o.elements[10]=a.z+1-W,o.elements[14]=a.w}}();function p(e){f.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),f.multiply(e.projectionMatrix),f.multiply(e.matrixWorldInverse),f.multiply(l.matrixWorld)}function x(e,a,t){l.visible=!1;const i=e.getRenderTarget(),s=e.xr.enabled,o=e.shadowMap.autoUpdate;e.xr.enabled=!1,e.shadowMap.autoUpdate=!1,e.setRenderTarget(d),e.autoClear===!1&&e.clear(),e.render(a,n),e.xr.enabled=s,e.shadowMap.autoUpdate=o,e.setRenderTarget(i);const c=t.viewport;c!==void 0&&e.state.viewport(c),l.visible=!0}this.onBeforeRender=function(e,a,t){t.userData.refractor!==!0&&C(t)&&(w(),p(t),g(t),x(e,a,t))},this.getRenderTarget=function(){return d},this.dispose=function(){d.dispose(),l.material.dispose()}}}y.RefractorShader={name:"RefractorShader",uniforms:{color:{value:null},tDiffuse:{value:null},textureMatrix:{value:null}},vertexShader:"\n\n		uniform mat4 textureMatrix;\n\n		varying vec4 vUv;\n\n		void main() {\n\n			vUv = textureMatrix * vec4( position, 1.0 );\n			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n		}",fragmentShader:"\n\n		uniform vec3 color;\n		uniform sampler2D tDiffuse;\n\n		varying vec4 vUv;\n\n		float blendOverlay( float base, float blend ) {\n\n			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n		}\n\n		vec3 blendOverlay( vec3 base, vec3 blend ) {\n\n			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n		}\n\n		void main() {\n\n			vec4 base = texture2DProj( tDiffuse, vUv );\n			gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n			#include <tonemapping_fragment>\n			#include <colorspace_fragment>\n\n		}"};class T extends N{constructor(h,r={}){super(h),this.isWater=!0,this.type="Water";const l=this,_=r.color!==void 0?new S(r.color):new S(16777215),M=r.textureWidth||512,b=r.textureHeight||512,W=r.clipBias||0,m=r.flowDirection||new q(1,0),D=r.flowSpeed||.03,n=r.reflectivity||.02,R=r.scale||1,f=r.shader||T.WaterShader,d=new I,C=r.flowMap||void 0,w=r.normalMap0||d.load("textures/water/Water_1_M_Normal.jpg"),g=r.normalMap1||d.load("textures/water/Water_2_M_Normal.jpg"),p=.15,x=p*.5,e=new F,a=new Q;if(z===void 0){console.error("THREE.Water: Required component Reflector not found.");return}if(y===void 0){console.error("THREE.Water: Required component Refractor not found.");return}const t=new z(h,{textureWidth:M,textureHeight:b,clipBias:W}),i=new y(h,{textureWidth:M,textureHeight:b,clipBias:W});t.matrixAutoUpdate=!1,i.matrixAutoUpdate=!1,this.material=new j({name:f.name,uniforms:B.merge([k.fog,f.uniforms]),vertexShader:f.vertexShader,fragmentShader:f.fragmentShader,transparent:!0,fog:!0}),C!==void 0?(this.material.defines.USE_FLOWMAP="",this.material.uniforms.tFlowMap={type:"t",value:C}):this.material.uniforms.flowDirection={type:"v2",value:m},w.wrapS=w.wrapT=O,g.wrapS=g.wrapT=O,this.material.uniforms.tReflectionMap.value=t.getRenderTarget().texture,this.material.uniforms.tRefractionMap.value=i.getRenderTarget().texture,this.material.uniforms.tNormalMap0.value=w,this.material.uniforms.tNormalMap1.value=g,this.material.uniforms.color.value=_,this.material.uniforms.reflectivity.value=n,this.material.uniforms.textureMatrix.value=e,this.material.uniforms.config.value.x=0,this.material.uniforms.config.value.y=x,this.material.uniforms.config.value.z=x,this.material.uniforms.config.value.w=R;function s(c){e.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),e.multiply(c.projectionMatrix),e.multiply(c.matrixWorldInverse),e.multiply(l.matrixWorld)}function o(){const c=a.getDelta(),u=l.material.uniforms.config;u.value.x+=D*c,u.value.y=u.value.x+x,u.value.x>=p?(u.value.x=0,u.value.y=x):u.value.y>=p&&(u.value.y=u.value.y-p)}this.onBeforeRender=function(c,u,U){s(U),o(),l.visible=!1,t.matrixWorld.copy(l.matrixWorld),i.matrixWorld.copy(l.matrixWorld),t.onBeforeRender(c,u,U),i.onBeforeRender(c,u,U),l.visible=!0}}}T.WaterShader={name:"WaterShader",uniforms:{color:{type:"c",value:null},reflectivity:{type:"f",value:0},tReflectionMap:{type:"t",value:null},tRefractionMap:{type:"t",value:null},tNormalMap0:{type:"t",value:null},tNormalMap1:{type:"t",value:null},textureMatrix:{type:"m4",value:null},config:{type:"v4",value:new P}},vertexShader:"\n\n		#include <common>\n		#include <fog_pars_vertex>\n		#include <logdepthbuf_pars_vertex>\n\n		uniform mat4 textureMatrix;\n\n		varying vec4 vCoord;\n		varying vec2 vUv;\n		varying vec3 vToEye;\n\n		void main() {\n\n			vUv = uv;\n			vCoord = textureMatrix * vec4( position, 1.0 );\n\n			vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n			vToEye = cameraPosition - worldPosition.xyz;\n\n			vec4 mvPosition =  viewMatrix * worldPosition; // used in fog_vertex\n			gl_Position = projectionMatrix * mvPosition;\n\n			#include <logdepthbuf_vertex>\n			#include <fog_vertex>\n\n		}",fragmentShader:"\n\n		#include <common>\n		#include <fog_pars_fragment>\n		#include <logdepthbuf_pars_fragment>\n\n		uniform sampler2D tReflectionMap;\n		uniform sampler2D tRefractionMap;\n		uniform sampler2D tNormalMap0;\n		uniform sampler2D tNormalMap1;\n\n		#ifdef USE_FLOWMAP\n			uniform sampler2D tFlowMap;\n		#else\n			uniform vec2 flowDirection;\n		#endif\n\n		uniform vec3 color;\n		uniform float reflectivity;\n		uniform vec4 config;\n\n		varying vec4 vCoord;\n		varying vec2 vUv;\n		varying vec3 vToEye;\n\n		void main() {\n\n			#include <logdepthbuf_fragment>\n\n			float flowMapOffset0 = config.x;\n			float flowMapOffset1 = config.y;\n			float halfCycle = config.z;\n			float scale = config.w;\n\n			vec3 toEye = normalize( vToEye );\n\n			// determine flow direction\n			vec2 flow;\n			#ifdef USE_FLOWMAP\n				flow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;\n			#else\n				flow = flowDirection;\n			#endif\n			flow.x *= - 1.0;\n\n			// sample normal maps (distort uvs with flowdata)\n			vec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );\n			vec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );\n\n			// linear interpolate to get the final normal color\n			float flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;\n			vec4 normalColor = mix( normalColor0, normalColor1, flowLerp );\n\n			// calculate normal vector\n			vec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\n\n			// calculate the fresnel term to blend reflection and refraction maps\n			float theta = max( dot( toEye, normal ), 0.0 );\n			float reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );\n\n			// calculate final uv coords\n			vec3 coord = vCoord.xyz / vCoord.w;\n			vec2 uv = coord.xy + coord.z * normal.xz * 0.05;\n\n			vec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );\n			vec4 refractColor = texture2D( tRefractionMap, uv );\n\n			// multiply water color with the mix of both textures\n			gl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );\n\n			#include <tonemapping_fragment>\n			#include <colorspace_fragment>\n			#include <fog_fragment>\n\n		}"};export{T as W};
