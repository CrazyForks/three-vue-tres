import{aH as T,aM as V,bV as ne,bW as oe,bK as W,aJ as E,bl as w,bU as B,br as N,bE as C,al as se,aU as k,bF as M,aX as F,Z as D,a4 as O,o as R,c as G,J as q,k as I,aA as ie,aQ as ae,aF as X,ai as K,aN as re,a3 as Q,V as U,a8 as Z,a9 as ee,aT as le,an as L}from"./vendor.d0ca5cc01703251890586.js";import{m as te}from"./BufferGeometryUtils.01f9f3001703251890586.js";const ce=/^[og]\s*(.+)?/,ue=/^mtllib /,fe=/^usemtl /,me=/^usemap /,H=/\s+/,J=new T,A=new T,Y=new T,$=new T,_=new T,S=new V;function pe(){const x={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(n,t){if(this.object&&this.object.fromDeclaration===!1){this.object.name=n,this.object.fromDeclaration=t!==!1;return}const o=this.object&&typeof this.object.currentMaterial=="function"?this.object.currentMaterial():void 0;if(this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0),this.object={name:n||"",fromDeclaration:t!==!1,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(e,s){const l=this._finalize(!1);l&&(l.inherited||l.groupCount<=0)&&this.materials.splice(l.index,1);const c={index:this.materials.length,name:e||"",mtllib:Array.isArray(s)&&s.length>0?s[s.length-1]:"",smooth:l!==void 0?l.smooth:this.smooth,groupStart:l!==void 0?l.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(b){const a={index:typeof b=="number"?b:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return a.clone=this.clone.bind(a),a}};return this.materials.push(c),c},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(e){const s=this.currentMaterial();if(s&&s.groupEnd===-1&&(s.groupEnd=this.geometry.vertices.length/3,s.groupCount=s.groupEnd-s.groupStart,s.inherited=!1),e&&this.materials.length>1)for(let l=this.materials.length-1;l>=0;l--)this.materials[l].groupCount<=0&&this.materials.splice(l,1);return e&&this.materials.length===0&&this.materials.push({name:"",smooth:this.smooth}),s}},o&&o.name&&typeof o.clone=="function"){const e=o.clone(0);e.inherited=!0,this.object.materials.push(e)}this.objects.push(this.object)},finalize:function(){this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0)},parseVertexIndex:function(n,t){const o=parseInt(n,10);return(o>=0?o-1:o+t/3)*3},parseNormalIndex:function(n,t){const o=parseInt(n,10);return(o>=0?o-1:o+t/3)*3},parseUVIndex:function(n,t){const o=parseInt(n,10);return(o>=0?o-1:o+t/2)*2},addVertex:function(n,t,o){const e=this.vertices,s=this.object.geometry.vertices;s.push(e[n+0],e[n+1],e[n+2]),s.push(e[t+0],e[t+1],e[t+2]),s.push(e[o+0],e[o+1],e[o+2])},addVertexPoint:function(n){const t=this.vertices;this.object.geometry.vertices.push(t[n+0],t[n+1],t[n+2])},addVertexLine:function(n){const t=this.vertices;this.object.geometry.vertices.push(t[n+0],t[n+1],t[n+2])},addNormal:function(n,t,o){const e=this.normals,s=this.object.geometry.normals;s.push(e[n+0],e[n+1],e[n+2]),s.push(e[t+0],e[t+1],e[t+2]),s.push(e[o+0],e[o+1],e[o+2])},addFaceNormal:function(n,t,o){const e=this.vertices,s=this.object.geometry.normals;J.fromArray(e,n),A.fromArray(e,t),Y.fromArray(e,o),_.subVectors(Y,A),$.subVectors(J,A),_.cross($),_.normalize(),s.push(_.x,_.y,_.z),s.push(_.x,_.y,_.z),s.push(_.x,_.y,_.z)},addColor:function(n,t,o){const e=this.colors,s=this.object.geometry.colors;e[n]!==void 0&&s.push(e[n+0],e[n+1],e[n+2]),e[t]!==void 0&&s.push(e[t+0],e[t+1],e[t+2]),e[o]!==void 0&&s.push(e[o+0],e[o+1],e[o+2])},addUV:function(n,t,o){const e=this.uvs,s=this.object.geometry.uvs;s.push(e[n+0],e[n+1]),s.push(e[t+0],e[t+1]),s.push(e[o+0],e[o+1])},addDefaultUV:function(){const n=this.object.geometry.uvs;n.push(0,0),n.push(0,0),n.push(0,0)},addUVLine:function(n){const t=this.uvs;this.object.geometry.uvs.push(t[n+0],t[n+1])},addFace:function(n,t,o,e,s,l,c,b,a){const r=this.vertices.length;let i=this.parseVertexIndex(n,r),u=this.parseVertexIndex(t,r),f=this.parseVertexIndex(o,r);if(this.addVertex(i,u,f),this.addColor(i,u,f),c!==void 0&&c!==""){const g=this.normals.length;i=this.parseNormalIndex(c,g),u=this.parseNormalIndex(b,g),f=this.parseNormalIndex(a,g),this.addNormal(i,u,f)}else this.addFaceNormal(i,u,f);if(e!==void 0&&e!==""){const g=this.uvs.length;i=this.parseUVIndex(e,g),u=this.parseUVIndex(s,g),f=this.parseUVIndex(l,g),this.addUV(i,u,f),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(n){this.object.geometry.type="Points";const t=this.vertices.length;for(let o=0,e=n.length;o<e;o++){const s=this.parseVertexIndex(n[o],t);this.addVertexPoint(s),this.addColor(s)}},addLineGeometry:function(n,t){this.object.geometry.type="Line";const o=this.vertices.length,e=this.uvs.length;for(let s=0,l=n.length;s<l;s++)this.addVertexLine(this.parseVertexIndex(n[s],o));for(let s=0,l=t.length;s<l;s++)this.addUVLine(this.parseUVIndex(t[s],e))}};return x.startObject("",!1),x}class we extends ne{constructor(n){super(n),this.materials=null}load(n,t,o,e){const s=this,l=new oe(this.manager);l.setPath(this.path),l.setRequestHeader(this.requestHeader),l.setWithCredentials(this.withCredentials),l.load(n,function(c){try{t(s.parse(c))}catch(b){e?e(b):console.error(b),s.manager.itemError(n)}},o,e)}setMaterials(n){return this.materials=n,this}parse(n){const t=new pe;n.indexOf("\r\n")!==-1&&(n=n.replace(/\r\n/g,"\n")),n.indexOf("\\\n")!==-1&&(n=n.replace(/\\\n/g,""));const o=n.split("\n");let e=[];for(let c=0,b=o.length;c<b;c++){const a=o[c].trimStart();if(a.length===0)continue;const r=a.charAt(0);if(r!=="#")if(r==="v"){const i=a.split(H);switch(i[0]){case"v":t.vertices.push(parseFloat(i[1]),parseFloat(i[2]),parseFloat(i[3])),i.length>=7?(S.setRGB(parseFloat(i[4]),parseFloat(i[5]),parseFloat(i[6])).convertSRGBToLinear(),t.colors.push(S.r,S.g,S.b)):t.colors.push(void 0,void 0,void 0);break;case"vn":t.normals.push(parseFloat(i[1]),parseFloat(i[2]),parseFloat(i[3]));break;case"vt":t.uvs.push(parseFloat(i[1]),parseFloat(i[2]));break}}else if(r==="f"){const u=a.slice(1).trim().split(H),f=[];for(let h=0,d=u.length;h<d;h++){const m=u[h];if(m.length>0){const v=m.split("/");f.push(v)}}const g=f[0];for(let h=1,d=f.length-1;h<d;h++){const m=f[h],v=f[h+1];t.addFace(g[0],m[0],v[0],g[1],m[1],v[1],g[2],m[2],v[2])}}else if(r==="l"){const i=a.substring(1).trim().split(" ");let u=[];const f=[];if(a.indexOf("/")===-1)u=i;else for(let g=0,h=i.length;g<h;g++){const d=i[g].split("/");d[0]!==""&&u.push(d[0]),d[1]!==""&&f.push(d[1])}t.addLineGeometry(u,f)}else if(r==="p"){const u=a.slice(1).trim().split(" ");t.addPointGeometry(u)}else if((e=ce.exec(a))!==null){const i=(" "+e[0].slice(1).trim()).slice(1);t.startObject(i)}else if(fe.test(a))t.object.startMaterial(a.substring(7).trim(),t.materialLibraries);else if(ue.test(a))t.materialLibraries.push(a.substring(7).trim());else if(me.test(a))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if(r==="s"){if(e=a.split(" "),e.length>1){const u=e[1].trim().toLowerCase();t.object.smooth=u!=="0"&&u!=="off"}else t.object.smooth=!0;const i=t.object.currentMaterial();i&&(i.smooth=t.object.smooth)}else{if(a==="\0")continue;console.warn('THREE.OBJLoader: Unexpected line: "'+a+'"')}}t.finalize();const s=new W;if(s.materialLibraries=[].concat(t.materialLibraries),!(t.objects.length===1&&t.objects[0].geometry.vertices.length===0)===!0)for(let c=0,b=t.objects.length;c<b;c++){const a=t.objects[c],r=a.geometry,i=a.materials,u=r.type==="Line",f=r.type==="Points";let g=!1;if(r.vertices.length===0)continue;const h=new E;h.setAttribute("position",new w(r.vertices,3)),r.normals.length>0&&h.setAttribute("normal",new w(r.normals,3)),r.colors.length>0&&(g=!0,h.setAttribute("color",new w(r.colors,3))),r.hasUVIndices===!0&&h.setAttribute("uv",new w(r.uvs,2));const d=[];for(let v=0,P=i.length;v<P;v++){const y=i[v],z=y.name+"_"+y.smooth+"_"+g;let p=t.materials[z];if(this.materials!==null){if(p=this.materials.create(y.name),u&&p&&!(p instanceof B)){const j=new B;N.prototype.copy.call(j,p),j.color.copy(p.color),p=j}else if(f&&p&&!(p instanceof C)){const j=new C({size:10,sizeAttenuation:!1});N.prototype.copy.call(j,p),j.color.copy(p.color),j.map=p.map,p=j}}p===void 0&&(u?p=new B:f?p=new C({size:1,sizeAttenuation:!1}):p=new se,p.name=y.name,p.flatShading=!y.smooth,p.vertexColors=g,t.materials[z]=p),d.push(p)}let m;if(d.length>1){for(let v=0,P=i.length;v<P;v++){const y=i[v];h.addGroup(y.groupStart,y.groupCount,v)}u?m=new k(h,d):f?m=new M(h,d):m=new F(h,d)}else u?m=new k(h,d[0]):f?m=new M(h,d[0]):m=new F(h,d[0]);m.name=a.name,s.add(m)}else if(t.vertices.length>0){const c=new C({size:1,sizeAttenuation:!1}),b=new E;b.setAttribute("position",new w(t.vertices,3)),t.colors.length>0&&t.colors[0]!==void 0&&(b.setAttribute("color",new w(t.colors,3)),c.vertexColors=!0);const a=new M(b,c);s.add(a)}return s}}const je=(x,n)=>new Promise((t,o)=>{n.setCrossOrigin("Anonymous"),n.load(x,e=>{t(e)},e=>{console.log("".concat(e.loaded/e.total*100,"% loaded"))},e=>{console.error(e),o(e)})}),he=["object"],Pe=D({__name:"cloudPoints",props:{model:{},color:{default:"#FFF"},opacity:{default:1}},setup(x){const n=x,t=new W;return n.model.traverse(o=>{if(o instanceof F){const e=o.geometry.clone();o.geometry.dispose(),o.material.dispose();const s=new C({color:n.color});s.opacity=n.opacity,s.transparent=!0;const l=new M(e,s);t.add(l)}}),O(()=>{n.color&&t.traverse(o=>{o instanceof M&&(o.material.color=new V(n.color))}),n.opacity&&t.traverse(o=>{o instanceof M&&(o.material.opacity=n.opacity)})}),(o,e)=>(R(),G("primitive",{object:q(t)},null,8,he))}}),de="uniform float c;\nuniform float p;\nuniform float uTime;\nvarying float intensity;\nvarying vec2 vUv;\nvoid main(){\n    vUv=uv;\n    vec3 vNormal=normalize(normalMatrix*normal);\n    intensity=pow(c-abs(dot(vNormal,vec3(0,0,1))),p);\n    gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.);\n}",ge="uniform vec3 glowColor;\nuniform sampler2D lightningTexture;\nvarying float intensity;\nvarying vec2 vUv;\nuniform float offsetY;\nuniform float uTime;\nuniform float uOpacity;\n\nvoid main(){\n  vec2 uv=vUv;\n  uv.y+=offsetY;\n  vec3 glow=glowColor*intensity;\n  vec3 color=vec3(step(.1,uv.y)-step(.2,uv.y))-vec3(texture2D(lightningTexture,uv));\n  float alpha=clamp(cos(uTime*3.),.5,1.);\n  gl_FragColor=vec4(glow+color,alpha*uOpacity);\n}",be=U("TresBufferGeometry",null,null,-1),ze=D({__name:"xRayEffect",props:{model:{},color:{default:"#84ccff"},opacity:{default:1}},async setup(x){let n,t;const o=x,e=I(),s=[];o.model.traverse(r=>{r instanceof F&&(r.geometry.verticesNeedUpdate=!0,s.push(r.geometry))});const l=([n,t]=ie(()=>ae({map:"./plugins/medical/image/brainXRayLight.png"})),n=await n,t(),n),c={uniforms:{c:{type:"f",value:1.11},p:{type:"f",value:1},glowColor:{type:"c",value:new V(o.color)},lightningTexture:{type:"t",value:l.map},offsetY:{type:"f",value:.1},uTime:{type:"f",value:0},uOpacity:{type:"f",value:o.opacity}},vertexShader:de,fragmentShader:ge,side:X,blending:K,depthWrite:!1};c.uniforms.offsetY.value=Math.sin(5);const{camera:b}=re(),{onLoop:a}=Q();return a(({delta:r})=>{b.value.position&&e.value&&(c.uniforms.uTime.value+=r)}),O(()=>{e.value&&(e.value.geometry.dispose(),e.value.geometry=te(s)),o.color&&(c.uniforms.glowColor.value=new V(o.color)),o.opacity&&(c.uniforms.uOpacity.value=o.opacity)}),(r,i)=>(R(),G("TresMesh",{ref_key:"TresMeshRef",ref:e},[be,U("TresShaderMaterial",Z(ee(c)),null,16)],512))}}),ve="uniform float p;\nuniform float uTime;\nuniform float uSlowTime;\nuniform float uBubblesUp;\nvarying float intensity;\nattribute vec2 aDelayDuration;\nattribute float size;\nattribute vec4 bubbles;\nvarying float alpha;\n\nfloat easeExpoInOut(float p){\n    return((p*=2.)<1.)?.5*pow(2.,10.*(p-1.)):.5*(2.-pow(2.,-10.*(p-1.)));\n}\n\nvoid main()\n{\n    intensity=.9;\n    vec4 mvPosition=modelViewMatrix*vec4(position,1.);\n    gl_PointSize=size*(300./-mvPosition.z);\n    float m=mod(size,sin(uSlowTime*.12+size));\n    \n    alpha=step(.5,abs(m));\n    if(m>.5&&m<.7){\n        gl_PointSize=.9*size;\n    }\n    if(m>.8){\n        gl_PointSize=.9*size;\n    }\n    \n    gl_Position=projectionMatrix*mvPosition;\n    \n    if(bubbles.w>0.&&bubbles.w<2.&&bubbles.x!=0.&&bubbles.y!=0.){\n        gl_PointSize=size+15.;\n        alpha=clamp(abs(sin(uTime-bubbles.y)),.3,1.);\n        \n        float tProgress=smoothstep(0.,aDelayDuration.x,uBubblesUp);\n        vec3 tranlated=mix(position,bubbles.xyz,tProgress);\n        vec4 bPosition=modelViewMatrix*vec4(tranlated,1.);\n        \n        gl_PointSize=uBubblesUp*gl_PointSize;\n        gl_Position+=projectionMatrix*bPosition;\n        alpha=5.;\n    }\n    \n    if(bubbles.w==2.){\n        alpha=clamp(abs(sin(uTime-bubbles.y)),.3,.6);\n        gl_PointSize=size+60.;\n        \n        gl_PointSize=uBubblesUp*gl_PointSize;\n        float normalized=clamp(uBubblesUp,0.,2.)*2.;\n        vec3 tranlated=mix(position,bubbles.xyz,normalized);\n        vec4 bPosition=modelViewMatrix*vec4(tranlated,1.);\n        gl_Position+=projectionMatrix*bPosition;\n    }\n    if(bubbles.w==3.){\n        alpha=clamp(abs(sin(uTime-bubbles.y)),.3,1.);\n        gl_PointSize=size+90.;\n        \n        gl_PointSize=uBubblesUp*gl_PointSize;\n        float normalized=clamp(uBubblesUp,0.,2.)*2.;\n        vec3 tranlated=mix(position,bubbles.xyz,normalized);\n        vec4 bPosition=modelViewMatrix*vec4(tranlated,1.);\n        gl_Position+=projectionMatrix*bPosition;\n    }\n}",ye="uniform vec3 glowColor;\nvarying float intensity;\nvarying float alpha;\nuniform float uOpacity;\nvoid main()\n{\n    float distanceToCenter=distance(gl_PointCoord,vec2(.5));\n    float pct=1.-smoothstep(0.,.5,distanceToCenter);\n    vec3 color=vec3(1.)*gl_FragColor.rgb;\n    vec3 glow=glowColor*intensity;\n    gl_FragColor=vec4(glow,clamp(alpha,0.,1.));\n    gl_FragColor=vec4(glow,pct*gl_FragColor.a);\n    gl_FragColor=vec4(gl_FragColor.rgb,gl_FragColor.a*uOpacity);\n    // gl_FragColor=vec4(1.,1.,0.,1.);\n}",Me=D({__name:"bubblesEffect",props:{model:{},color:{default:"#FFF"},opacity:{default:1}},setup(x){const n=x,t=["afective","semantic","episodic","process","amigdala","brainstem","bridge","cerebellum","analitic"],o={};n.model.traverse(a=>{a instanceof F&&t.map(r=>{if(a.name.includes(r)){if(o[r]){const i=[o[r],a.geometry];return o[r]=te(i),o}return o[r]=a.geometry}return[]})});const e=I(),s=()=>{const r=[],i=[],u=[],f=[],d=[];for(let m=0;m<2e4-t.length*3;m+=1){const v=L.randInt(0,t.length-1),P=t[v],y=o[P].attributes.position.array[m*3+0]||0,z=o[P].attributes.position.array[m*3+1]||0,p=o[P].attributes.position.array[m*3+2]||0;if(i.push(y,z,p),r[m]=L.randFloat(10,20),m%100===0){const j=L.randInt(100,250)+z;d.push(y,j,p,1)}else d.push(y,z,p,0);f[m*2+0]=L.randFloat(.5,1.5),f[m*2+1]=2.5}e.value.setAttribute("aDelayDuration",new w(f,2)),e.value.setAttribute("bubbles",new w(d,4)),e.value.setAttribute("position",new w(i,3)),e.value.setAttribute("color",new w(u,3)),e.value.setAttribute("size",new w(r,1)),e.value.computeBoundingSphere()},l=new le({uniforms:{glowColor:{type:"c",value:new V(n.color)},uTime:{type:"f",value:0},uSlowTime:{type:"f",value:0},uBubblesUp:{type:"f",value:1},uOpacity:{type:"f",value:n.opacity}},vertexShader:ve,fragmentShader:ye,blending:K,side:X,depthTest:!1,vertexColors:!1,transparent:!0});O(()=>{e.value&&s()});const c=I(),{onLoop:b}=Q();return b(({delta:a})=>{c.value&&(c.value.material.uniforms.uTime.value+=1/20,c.value.material.uniforms.uSlowTime.value+=1/400),n.color&&(l.uniforms.glowColor.value=new V(n.color)),n.opacity&&(l.uniforms.uOpacity.value=n.opacity)}),(a,r)=>(R(),G("TresPoints",{ref_key:"TresMeshRef",ref:c},[U("TresBufferGeometry",{ref_key:"BufferGeometryRef",ref:e},null,512),U("TresShaderMaterial",Z(ee(q(l))),null,16)],512))}});export{we as O,Pe as _,ze as a,Me as b,je as l};
