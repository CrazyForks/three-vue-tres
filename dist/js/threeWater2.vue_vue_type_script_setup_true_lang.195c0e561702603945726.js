import{aR as E,aS as H,aM as C,aT as O,aH as x,aU as F,aV as D,aW as V,aX as L,aY as z,aZ as B,a_ as X,a$ as k,b0 as Z,b1 as J,b2 as N,b3 as Y,Z as $,b4 as K,aA as ee,aF as te,a4 as ae,o as re,c as oe,J as ne,aQ as le}from"./vendor.b47b6e401702603945726.js";class U extends E{constructor(h,a={}){super(h),this.isReflector=!0,this.type="Reflector",this.camera=new H;const o=this,_=a.color!==void 0?new C(a.color):new C(8355711),m=a.textureWidth||512,R=a.textureHeight||512,S=a.clipBias||0,v=a.shader||U.ReflectorShader,P=a.multisample!==void 0?a.multisample:4,l=new O,g=new x,s=new x,y=new x,b=new F,W=new x(0,0,-1),f=new D,w=new x,M=new x,e=new D,n=new F,t=this.camera,c=new V(m,R,{samples:P,type:L}),u=new z({name:v.name!==void 0?v.name:"unspecified",uniforms:B.clone(v.uniforms),fragmentShader:v.fragmentShader,vertexShader:v.vertexShader});u.uniforms.tDiffuse.value=c.texture,u.uniforms.color.value=_,u.uniforms.textureMatrix.value=n,this.material=u,this.onBeforeRender=function(r,d,i){if(s.setFromMatrixPosition(o.matrixWorld),y.setFromMatrixPosition(i.matrixWorld),b.extractRotation(o.matrixWorld),g.set(0,0,1),g.applyMatrix4(b),w.subVectors(s,y),w.dot(g)>0)return;w.reflect(g).negate(),w.add(s),b.extractRotation(i.matrixWorld),W.set(0,0,-1),W.applyMatrix4(b),W.add(y),M.subVectors(s,W),M.reflect(g).negate(),M.add(s),t.position.copy(w),t.up.set(0,1,0),t.up.applyMatrix4(b),t.up.reflect(g),t.lookAt(M),t.far=i.far,t.updateMatrixWorld(),t.projectionMatrix.copy(i.projectionMatrix),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(t.projectionMatrix),n.multiply(t.matrixWorldInverse),n.multiply(o.matrixWorld),l.setFromNormalAndCoplanarPoint(g,s),l.applyMatrix4(t.matrixWorldInverse),f.set(l.normal.x,l.normal.y,l.normal.z,l.constant);const p=t.projectionMatrix;e.x=(Math.sign(f.x)+p.elements[8])/p.elements[0],e.y=(Math.sign(f.y)+p.elements[9])/p.elements[5],e.z=-1,e.w=(1+p.elements[10])/p.elements[14],f.multiplyScalar(2/f.dot(e)),p.elements[2]=f.x,p.elements[6]=f.y,p.elements[10]=f.z+1-S,p.elements[14]=f.w,o.visible=!1;const q=r.getRenderTarget(),G=r.xr.enabled,Q=r.shadowMap.autoUpdate;r.xr.enabled=!1,r.shadowMap.autoUpdate=!1,r.setRenderTarget(c),r.state.buffers.depth.setMask(!0),r.autoClear===!1&&r.clear(),r.render(d,t),r.xr.enabled=G,r.shadowMap.autoUpdate=Q,r.setRenderTarget(q);const A=i.viewport;A!==void 0&&r.state.viewport(A),o.visible=!0},this.getRenderTarget=function(){return c},this.dispose=function(){c.dispose(),o.material.dispose()}}}U.ReflectorShader={name:"ReflectorShader",uniforms:{color:{value:null},tDiffuse:{value:null},textureMatrix:{value:null}},vertexShader:"\n		uniform mat4 textureMatrix;\n		varying vec4 vUv;\n\n		#include <common>\n		#include <logdepthbuf_pars_vertex>\n\n		void main() {\n\n			vUv = textureMatrix * vec4( position, 1.0 );\n\n			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n			#include <logdepthbuf_vertex>\n\n		}",fragmentShader:"\n		uniform vec3 color;\n		uniform sampler2D tDiffuse;\n		varying vec4 vUv;\n\n		#include <logdepthbuf_pars_fragment>\n\n		float blendOverlay( float base, float blend ) {\n\n			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n		}\n\n		vec3 blendOverlay( vec3 base, vec3 blend ) {\n\n			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n		}\n\n		void main() {\n\n			#include <logdepthbuf_fragment>\n\n			vec4 base = texture2DProj( tDiffuse, vUv );\n			gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n			#include <tonemapping_fragment>\n			#include <colorspace_fragment>\n\n		}"};class T extends E{constructor(h,a={}){super(h),this.isRefractor=!0,this.type="Refractor",this.camera=new H;const o=this,_=a.color!==void 0?new C(a.color):new C(8355711),m=a.textureWidth||512,R=a.textureHeight||512,S=a.clipBias||0,v=a.shader||T.RefractorShader,P=a.multisample!==void 0?a.multisample:4,l=this.camera;l.matrixAutoUpdate=!1,l.userData.refractor=!0;const g=new O,s=new F,y=new V(m,R,{samples:P,type:L});this.material=new z({name:v.name!==void 0?v.name:"unspecified",uniforms:B.clone(v.uniforms),vertexShader:v.vertexShader,fragmentShader:v.fragmentShader,transparent:!0}),this.material.uniforms.color.value=_,this.material.uniforms.tDiffuse.value=y.texture,this.material.uniforms.textureMatrix.value=s;const b=function(){const e=new x,n=new x,t=new F,c=new x,u=new x;return function(d){return e.setFromMatrixPosition(o.matrixWorld),n.setFromMatrixPosition(d.matrixWorld),c.subVectors(e,n),t.extractRotation(o.matrixWorld),u.set(0,0,1),u.applyMatrix4(t),c.dot(u)<0}}(),W=function(){const e=new x,n=new x,t=new X,c=new x;return function(){o.matrixWorld.decompose(n,t,c),e.set(0,0,1).applyQuaternion(t).normalize(),e.negate(),g.setFromNormalAndCoplanarPoint(e,n)}}(),f=function(){const e=new O,n=new D,t=new D;return function(u){l.matrixWorld.copy(u.matrixWorld),l.matrixWorldInverse.copy(l.matrixWorld).invert(),l.projectionMatrix.copy(u.projectionMatrix),l.far=u.far,e.copy(g),e.applyMatrix4(l.matrixWorldInverse),n.set(e.normal.x,e.normal.y,e.normal.z,e.constant);const r=l.projectionMatrix;t.x=(Math.sign(n.x)+r.elements[8])/r.elements[0],t.y=(Math.sign(n.y)+r.elements[9])/r.elements[5],t.z=-1,t.w=(1+r.elements[10])/r.elements[14],n.multiplyScalar(2/n.dot(t)),r.elements[2]=n.x,r.elements[6]=n.y,r.elements[10]=n.z+1-S,r.elements[14]=n.w}}();function w(e){s.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),s.multiply(e.projectionMatrix),s.multiply(e.matrixWorldInverse),s.multiply(o.matrixWorld)}function M(e,n,t){o.visible=!1;const c=e.getRenderTarget(),u=e.xr.enabled,r=e.shadowMap.autoUpdate;e.xr.enabled=!1,e.shadowMap.autoUpdate=!1,e.setRenderTarget(y),e.autoClear===!1&&e.clear(),e.render(n,l),e.xr.enabled=u,e.shadowMap.autoUpdate=r,e.setRenderTarget(c);const d=t.viewport;d!==void 0&&e.state.viewport(d),o.visible=!0}this.onBeforeRender=function(e,n,t){t.userData.refractor!==!0&&b(t)&&(W(),w(t),f(t),M(e,n,t))},this.getRenderTarget=function(){return y},this.dispose=function(){y.dispose(),o.material.dispose()}}}T.RefractorShader={name:"RefractorShader",uniforms:{color:{value:null},tDiffuse:{value:null},textureMatrix:{value:null}},vertexShader:"\n\n		uniform mat4 textureMatrix;\n\n		varying vec4 vUv;\n\n		void main() {\n\n			vUv = textureMatrix * vec4( position, 1.0 );\n			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n		}",fragmentShader:"\n\n		uniform vec3 color;\n		uniform sampler2D tDiffuse;\n\n		varying vec4 vUv;\n\n		float blendOverlay( float base, float blend ) {\n\n			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n		}\n\n		vec3 blendOverlay( vec3 base, vec3 blend ) {\n\n			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n		}\n\n		void main() {\n\n			vec4 base = texture2DProj( tDiffuse, vUv );\n			gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n			#include <tonemapping_fragment>\n			#include <colorspace_fragment>\n\n		}"};class j extends E{constructor(h,a={}){super(h),this.isWater=!0,this.type="Water";const o=this,_=a.color!==void 0?new C(a.color):new C(16777215),m=a.textureWidth||512,R=a.textureHeight||512,S=a.clipBias||0,v=a.flowDirection||new k(1,0),P=a.flowSpeed||.03,l=a.reflectivity||.02,g=a.scale||1,s=a.shader||j.WaterShader,y=new Z,b=a.flowMap||void 0,W=a.normalMap0||y.load("textures/water/Water_1_M_Normal.jpg"),f=a.normalMap1||y.load("textures/water/Water_2_M_Normal.jpg"),w=.15,M=w*.5,e=new F,n=new Y;if(U===void 0){console.error("THREE.Water: Required component Reflector not found.");return}if(T===void 0){console.error("THREE.Water: Required component Refractor not found.");return}const t=new U(h,{textureWidth:m,textureHeight:R,clipBias:S}),c=new T(h,{textureWidth:m,textureHeight:R,clipBias:S});t.matrixAutoUpdate=!1,c.matrixAutoUpdate=!1,this.material=new z({name:s.name,uniforms:B.merge([J.fog,s.uniforms]),vertexShader:s.vertexShader,fragmentShader:s.fragmentShader,transparent:!0,fog:!0}),b!==void 0?(this.material.defines.USE_FLOWMAP="",this.material.uniforms.tFlowMap={type:"t",value:b}):this.material.uniforms.flowDirection={type:"v2",value:v},W.wrapS=W.wrapT=N,f.wrapS=f.wrapT=N,this.material.uniforms.tReflectionMap.value=t.getRenderTarget().texture,this.material.uniforms.tRefractionMap.value=c.getRenderTarget().texture,this.material.uniforms.tNormalMap0.value=W,this.material.uniforms.tNormalMap1.value=f,this.material.uniforms.color.value=_,this.material.uniforms.reflectivity.value=l,this.material.uniforms.textureMatrix.value=e,this.material.uniforms.config.value.x=0,this.material.uniforms.config.value.y=M,this.material.uniforms.config.value.z=M,this.material.uniforms.config.value.w=g;function u(d){e.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),e.multiply(d.projectionMatrix),e.multiply(d.matrixWorldInverse),e.multiply(o.matrixWorld)}function r(){const d=n.getDelta(),i=o.material.uniforms.config;i.value.x+=P*d,i.value.y=i.value.x+M,i.value.x>=w?(i.value.x=0,i.value.y=M):i.value.y>=w&&(i.value.y=i.value.y-w)}this.onBeforeRender=function(d,i,p){u(p),r(),o.visible=!1,t.matrixWorld.copy(o.matrixWorld),c.matrixWorld.copy(o.matrixWorld),t.onBeforeRender(d,i,p),c.onBeforeRender(d,i,p),o.visible=!0}}}j.WaterShader={name:"WaterShader",uniforms:{color:{type:"c",value:null},reflectivity:{type:"f",value:0},tReflectionMap:{type:"t",value:null},tRefractionMap:{type:"t",value:null},tNormalMap0:{type:"t",value:null},tNormalMap1:{type:"t",value:null},textureMatrix:{type:"m4",value:null},config:{type:"v4",value:new D}},vertexShader:"\n\n		#include <common>\n		#include <fog_pars_vertex>\n		#include <logdepthbuf_pars_vertex>\n\n		uniform mat4 textureMatrix;\n\n		varying vec4 vCoord;\n		varying vec2 vUv;\n		varying vec3 vToEye;\n\n		void main() {\n\n			vUv = uv;\n			vCoord = textureMatrix * vec4( position, 1.0 );\n\n			vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n			vToEye = cameraPosition - worldPosition.xyz;\n\n			vec4 mvPosition =  viewMatrix * worldPosition; // used in fog_vertex\n			gl_Position = projectionMatrix * mvPosition;\n\n			#include <logdepthbuf_vertex>\n			#include <fog_vertex>\n\n		}",fragmentShader:"\n\n		#include <common>\n		#include <fog_pars_fragment>\n		#include <logdepthbuf_pars_fragment>\n\n		uniform sampler2D tReflectionMap;\n		uniform sampler2D tRefractionMap;\n		uniform sampler2D tNormalMap0;\n		uniform sampler2D tNormalMap1;\n\n		#ifdef USE_FLOWMAP\n			uniform sampler2D tFlowMap;\n		#else\n			uniform vec2 flowDirection;\n		#endif\n\n		uniform vec3 color;\n		uniform float reflectivity;\n		uniform vec4 config;\n\n		varying vec4 vCoord;\n		varying vec2 vUv;\n		varying vec3 vToEye;\n\n		void main() {\n\n			#include <logdepthbuf_fragment>\n\n			float flowMapOffset0 = config.x;\n			float flowMapOffset1 = config.y;\n			float halfCycle = config.z;\n			float scale = config.w;\n\n			vec3 toEye = normalize( vToEye );\n\n			// determine flow direction\n			vec2 flow;\n			#ifdef USE_FLOWMAP\n				flow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;\n			#else\n				flow = flowDirection;\n			#endif\n			flow.x *= - 1.0;\n\n			// sample normal maps (distort uvs with flowdata)\n			vec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );\n			vec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );\n\n			// linear interpolate to get the final normal color\n			float flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;\n			vec4 normalColor = mix( normalColor0, normalColor1, flowLerp );\n\n			// calculate normal vector\n			vec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\n\n			// calculate the fresnel term to blend reflection and refraction maps\n			float theta = max( dot( toEye, normal ), 0.0 );\n			float reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );\n\n			// calculate final uv coords\n			vec3 coord = vCoord.xyz / vCoord.w;\n			vec2 uv = coord.xy + coord.z * normal.xz * 0.05;\n\n			vec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );\n			vec4 refractColor = texture2D( tRefractionMap, uv );\n\n			// multiply water color with the mix of both textures\n			gl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );\n\n			#include <tonemapping_fragment>\n			#include <colorspace_fragment>\n			#include <fog_fragment>\n\n		}"};const ie=["object","rotation-x"],ce=$({__name:"threeWater2",props:{waterGeometry:{default:new K(20,20)},color:{default:"#FFF"},scale:{default:1}},async setup(I){let h,a;const o=I,_=([h,a]=ee(()=>le(["./plugins/water/images/Water_1_M_Normal.jpg","./plugins/water/images/Water_2_M_Normal.jpg"])),h=await h,a(),h),m=new j(o.waterGeometry,{color:o.color,scale:o.scale,flowDirection:new k(1,1),textureWidth:1024,textureHeight:1024,normalMap0:_[0],normalMap1:_[1]});return m.material.transparent=!0,m.material.depthWrite=!0,m.material.depthTest=!0,m.material.side=te,ae(()=>{o.color&&m.material.uniforms.color.value.set(o.color),o.scale&&(m.material.uniforms.config.value.w=o.scale)}),(R,S)=>(re(),oe("primitive",{object:ne(m),"rotation-x":-Math.PI/2},null,8,ie))}});export{ce as _};
