import{aX as B,aY as L,aM as S,aZ as E,a_ as T,a$ as V,b0 as I,aT as N,b1 as z,aH as x,b2 as U,b3 as k,aV as H,b4 as q,b5 as G,b6 as j,b7 as Q,Z as X,b8 as Z,aB as J,aF as Y,a4 as $,o as K,c as ee,J as te,aQ as re}from"./vendor.08a60d9a1703747978034.js";import{R as O}from"./Reflector.a842a3971703747978034.js";class W extends B{constructor(m,t={}){super(m),this.isRefractor=!0,this.type="Refractor",this.camera=new L;const a=this,h=t.color!==void 0?new S(t.color):new S(8355711),n=t.textureWidth||512,y=t.textureHeight||512,M=t.clipBias||0,v=t.shader||W.RefractorShader,F=t.multisample!==void 0?t.multisample:4,i=this.camera;i.matrixAutoUpdate=!1,i.userData.refractor=!0;const R=new E,d=new T,p=new V(n,y,{samples:F,type:I});this.material=new N({name:v.name!==void 0?v.name:"unspecified",uniforms:z.clone(v.uniforms),vertexShader:v.vertexShader,fragmentShader:v.fragmentShader,transparent:!0}),this.material.uniforms.color.value=h,this.material.uniforms.tDiffuse.value=p.texture,this.material.uniforms.textureMatrix.value=d;const C=function(){const e=new x,o=new x,r=new T,s=new x,c=new x;return function(u){return e.setFromMatrixPosition(a.matrixWorld),o.setFromMatrixPosition(u.matrixWorld),s.subVectors(e,o),r.extractRotation(a.matrixWorld),c.set(0,0,1),c.applyMatrix4(r),s.dot(c)<0}}(),b=function(){const e=new x,o=new x,r=new k,s=new x;return function(){a.matrixWorld.decompose(o,r,s),e.set(0,0,1).applyQuaternion(r).normalize(),e.negate(),R.setFromNormalAndCoplanarPoint(e,o)}}(),_=function(){const e=new E,o=new U,r=new U;return function(c){i.matrixWorld.copy(c.matrixWorld),i.matrixWorldInverse.copy(i.matrixWorld).invert(),i.projectionMatrix.copy(c.projectionMatrix),i.far=c.far,e.copy(R),e.applyMatrix4(i.matrixWorldInverse),o.set(e.normal.x,e.normal.y,e.normal.z,e.constant);const l=i.projectionMatrix;r.x=(Math.sign(o.x)+l.elements[8])/l.elements[0],r.y=(Math.sign(o.y)+l.elements[9])/l.elements[5],r.z=-1,r.w=(1+l.elements[10])/l.elements[14],o.multiplyScalar(2/o.dot(r)),l.elements[2]=o.x,l.elements[6]=o.y,l.elements[10]=o.z+1-M,l.elements[14]=o.w}}();function w(e){d.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),d.multiply(e.projectionMatrix),d.multiply(e.matrixWorldInverse),d.multiply(a.matrixWorld)}function g(e,o,r){a.visible=!1;const s=e.getRenderTarget(),c=e.xr.enabled,l=e.shadowMap.autoUpdate;e.xr.enabled=!1,e.shadowMap.autoUpdate=!1,e.setRenderTarget(p),e.autoClear===!1&&e.clear(),e.render(o,i),e.xr.enabled=c,e.shadowMap.autoUpdate=l,e.setRenderTarget(s);const u=r.viewport;u!==void 0&&e.state.viewport(u),a.visible=!0}this.onBeforeRender=function(e,o,r){r.userData.refractor!==!0&&C(r)&&(b(),w(r),_(r),g(e,o,r))},this.getRenderTarget=function(){return p},this.dispose=function(){p.dispose(),a.material.dispose()}}}W.RefractorShader={name:"RefractorShader",uniforms:{color:{value:null},tDiffuse:{value:null},textureMatrix:{value:null}},vertexShader:"\n\n		uniform mat4 textureMatrix;\n\n		varying vec4 vUv;\n\n		void main() {\n\n			vUv = textureMatrix * vec4( position, 1.0 );\n			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n		}",fragmentShader:"\n\n		uniform vec3 color;\n		uniform sampler2D tDiffuse;\n\n		varying vec4 vUv;\n\n		float blendOverlay( float base, float blend ) {\n\n			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n		}\n\n		vec3 blendOverlay( vec3 base, vec3 blend ) {\n\n			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n		}\n\n		void main() {\n\n			vec4 base = texture2DProj( tDiffuse, vUv );\n			gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n			#include <tonemapping_fragment>\n			#include <colorspace_fragment>\n\n		}"};class D extends B{constructor(m,t={}){super(m),this.isWater=!0,this.type="Water";const a=this,h=t.color!==void 0?new S(t.color):new S(16777215),n=t.textureWidth||512,y=t.textureHeight||512,M=t.clipBias||0,v=t.flowDirection||new H(1,0),F=t.flowSpeed||.03,i=t.reflectivity||.02,R=t.scale||1,d=t.shader||D.WaterShader,p=new q,C=t.flowMap||void 0,b=t.normalMap0||p.load("textures/water/Water_1_M_Normal.jpg"),_=t.normalMap1||p.load("textures/water/Water_2_M_Normal.jpg"),w=.15,g=w*.5,e=new T,o=new Q;if(O===void 0){console.error("THREE.Water: Required component Reflector not found.");return}if(W===void 0){console.error("THREE.Water: Required component Refractor not found.");return}const r=new O(m,{textureWidth:n,textureHeight:y,clipBias:M}),s=new W(m,{textureWidth:n,textureHeight:y,clipBias:M});r.matrixAutoUpdate=!1,s.matrixAutoUpdate=!1,this.material=new N({name:d.name,uniforms:z.merge([G.fog,d.uniforms]),vertexShader:d.vertexShader,fragmentShader:d.fragmentShader,transparent:!0,fog:!0}),C!==void 0?(this.material.defines.USE_FLOWMAP="",this.material.uniforms.tFlowMap={type:"t",value:C}):this.material.uniforms.flowDirection={type:"v2",value:v},b.wrapS=b.wrapT=j,_.wrapS=_.wrapT=j,this.material.uniforms.tReflectionMap.value=r.getRenderTarget().texture,this.material.uniforms.tRefractionMap.value=s.getRenderTarget().texture,this.material.uniforms.tNormalMap0.value=b,this.material.uniforms.tNormalMap1.value=_,this.material.uniforms.color.value=h,this.material.uniforms.reflectivity.value=i,this.material.uniforms.textureMatrix.value=e,this.material.uniforms.config.value.x=0,this.material.uniforms.config.value.y=g,this.material.uniforms.config.value.z=g,this.material.uniforms.config.value.w=R;function c(u){e.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),e.multiply(u.projectionMatrix),e.multiply(u.matrixWorldInverse),e.multiply(a.matrixWorld)}function l(){const u=o.getDelta(),f=a.material.uniforms.config;f.value.x+=F*u,f.value.y=f.value.x+g,f.value.x>=w?(f.value.x=0,f.value.y=g):f.value.y>=w&&(f.value.y=f.value.y-w)}this.onBeforeRender=function(u,f,P){c(P),l(),a.visible=!1,r.matrixWorld.copy(a.matrixWorld),s.matrixWorld.copy(a.matrixWorld),r.onBeforeRender(u,f,P),s.onBeforeRender(u,f,P),a.visible=!0}}}D.WaterShader={name:"WaterShader",uniforms:{color:{type:"c",value:null},reflectivity:{type:"f",value:0},tReflectionMap:{type:"t",value:null},tRefractionMap:{type:"t",value:null},tNormalMap0:{type:"t",value:null},tNormalMap1:{type:"t",value:null},textureMatrix:{type:"m4",value:null},config:{type:"v4",value:new U}},vertexShader:"\n\n		#include <common>\n		#include <fog_pars_vertex>\n		#include <logdepthbuf_pars_vertex>\n\n		uniform mat4 textureMatrix;\n\n		varying vec4 vCoord;\n		varying vec2 vUv;\n		varying vec3 vToEye;\n\n		void main() {\n\n			vUv = uv;\n			vCoord = textureMatrix * vec4( position, 1.0 );\n\n			vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n			vToEye = cameraPosition - worldPosition.xyz;\n\n			vec4 mvPosition =  viewMatrix * worldPosition; // used in fog_vertex\n			gl_Position = projectionMatrix * mvPosition;\n\n			#include <logdepthbuf_vertex>\n			#include <fog_vertex>\n\n		}",fragmentShader:"\n\n		#include <common>\n		#include <fog_pars_fragment>\n		#include <logdepthbuf_pars_fragment>\n\n		uniform sampler2D tReflectionMap;\n		uniform sampler2D tRefractionMap;\n		uniform sampler2D tNormalMap0;\n		uniform sampler2D tNormalMap1;\n\n		#ifdef USE_FLOWMAP\n			uniform sampler2D tFlowMap;\n		#else\n			uniform vec2 flowDirection;\n		#endif\n\n		uniform vec3 color;\n		uniform float reflectivity;\n		uniform vec4 config;\n\n		varying vec4 vCoord;\n		varying vec2 vUv;\n		varying vec3 vToEye;\n\n		void main() {\n\n			#include <logdepthbuf_fragment>\n\n			float flowMapOffset0 = config.x;\n			float flowMapOffset1 = config.y;\n			float halfCycle = config.z;\n			float scale = config.w;\n\n			vec3 toEye = normalize( vToEye );\n\n			// determine flow direction\n			vec2 flow;\n			#ifdef USE_FLOWMAP\n				flow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;\n			#else\n				flow = flowDirection;\n			#endif\n			flow.x *= - 1.0;\n\n			// sample normal maps (distort uvs with flowdata)\n			vec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );\n			vec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );\n\n			// linear interpolate to get the final normal color\n			float flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;\n			vec4 normalColor = mix( normalColor0, normalColor1, flowLerp );\n\n			// calculate normal vector\n			vec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\n\n			// calculate the fresnel term to blend reflection and refraction maps\n			float theta = max( dot( toEye, normal ), 0.0 );\n			float reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );\n\n			// calculate final uv coords\n			vec3 coord = vCoord.xyz / vCoord.w;\n			vec2 uv = coord.xy + coord.z * normal.xz * 0.05;\n\n			vec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );\n			vec4 refractColor = texture2D( tRefractionMap, uv );\n\n			// multiply water color with the mix of both textures\n			gl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );\n\n			#include <tonemapping_fragment>\n			#include <colorspace_fragment>\n			#include <fog_fragment>\n\n		}"};const ae=["object","rotation-x"],ne=X({__name:"threeWater2",props:{waterGeometry:{default:new Z(20,20)},color:{default:"#FFF"},scale:{default:1}},async setup(A){let m,t;const a=A,h=([m,t]=J(()=>re(["./plugins/water/images/Water_1_M_Normal.jpg","./plugins/water/images/Water_2_M_Normal.jpg"])),m=await m,t(),m),n=new D(a.waterGeometry,{color:a.color,scale:a.scale,flowDirection:new H(1,1),textureWidth:1024,textureHeight:1024,normalMap0:h[0],normalMap1:h[1]});return n.material.transparent=!0,n.material.depthWrite=!0,n.material.depthTest=!0,n.material.side=Y,$(()=>{a.color&&n.material.uniforms.color.value.set(a.color),a.scale&&(n.material.uniforms.config.value.w=a.scale)}),(y,M)=>(K(),ee("primitive",{object:te(n),"rotation-x":-Math.PI/2},null,8,ae))}});export{ne as _};
