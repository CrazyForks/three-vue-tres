import{bZ as e,$ as p,k as c,aA as h,bj as f,bp as v,b3 as g,bo as w,aw as s,b1 as _,w as n,o as x,c as C,W as d,a9 as b,aa as S}from"./vendor.St8dZPm41710511268643.js";const $=()=>"\n       varying vec2 vUv;\n			 	".concat(e.common,"\n      	").concat(e.bsdfs,"\n      	").concat(e.shadowmap_pars_vertex,"\n       void main() {\n					").concat(e.beginnormal_vertex,"\n          ").concat(e.defaultnormal_vertex,"\n          ").concat(e.begin_vertex,"\n          ").concat(e.project_vertex,"\n          ").concat(e.worldpos_vertex,"\n          ").concat(e.shadowmap_vertex,"\n\n           gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);    \n           vUv = uv;\n       }"),T=()=>"\n	varying vec2 vUv;\n	uniform sampler2D uTexture;\n	uniform vec3 uShadowColor;\n	uniform vec3 uColor;\n	uniform float fEdge;\n	// ShaderMaterial 下的 纹理参数重复无效 要在着色器中增加\n	float repeatTime = 100.0;\n\n	float smoothsteps(float t) {\n			return t * t * (3.0 - 2.0 * t);\n	}\n\n	 ".concat(e.common,"\n	 ").concat(e.packing,"\n	 ").concat(e.bsdfs,"\n	 ").concat(e.lights_pars_begin,"\n	 ").concat(e.shadowmap_pars_fragment,"\n	 ").concat(e.shadowmask_pars_fragment,"\n\n	void main() {\n			vec4 col = texture2D(uTexture, vUv * repeatTime);\n			col.rgb = mix( uColor , col.rgb ,0.5);\n			\n			float alpha = 1.0;\n			float d = length(vUv - vec2(0.5));\n			if(d > 0.35) {\n					alpha = 1.0 - smoothsteps( clamp( (d - 0.35) / (fEdge-0.2), 0.0, 1.0) );\n			}\n\n		 vec3 addShadow = mix( uShadowColor , col.rgb ,getShadowMask());\n\n			gl_FragColor = vec4(addShadow, alpha);  \n	}"),k=["rotation-x"],M=["args"],E=p({__name:"whiteFloorMesh",props:{size:{default:[20,20]},color:{default:"#990"},shadowColor:{default:"#999"},edge:{default:.35}},async setup(u){let a,i;const o=u,m=c(),{map:l}=([a,i]=h(()=>f({map:"./plugins/floor/image/whiteFloor.jpg"})),a=await a,i(),a);l.wrapS=l.wrapT=v;const r={uniforms:g.merge([w.lights,{uTexture:{type:"t",value:l},uColor:{value:new s(o.color)},uShadowColor:{value:new s(o.shadowColor)},fEdge:{type:"f",value:o.edge}}]),side:_,vertexShader:$(),fragmentShader:T(),lights:!0,transparent:!0};return n(()=>o.edge,t=>{r.uniforms.fEdge.value=t}),n(()=>o.color,t=>{r.uniforms.uColor.value=new s(o.color)}),n(()=>o.shadowColor,t=>{r.uniforms.uShadowColor.value=new s(o.shadowColor)}),(t,y)=>(x(),C("TresMesh",{ref_key:"tmRef",ref:m,"rotation-x":-Math.PI/2},[d("TresPlaneGeometry",{args:o.size},null,8,M),d("TresShaderMaterial",b(S(r)),null,16)],8,k))}});export{E as _};
