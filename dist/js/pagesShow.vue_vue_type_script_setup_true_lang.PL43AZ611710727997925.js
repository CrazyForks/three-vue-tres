import{bK as T,$ as w,k as _,a4 as B,a5 as S,w as L,o as c,c as m,K as n,aw as f,b1 as M,bL as b,au as A,a0 as x,a1 as O,a2 as D,a3 as R,aA as G,v as N,D as E,a7 as P,a8 as W,W as C,a as v,a9 as k,aa as H,ab as F,E as I,X as g,Z as $}from"./vendor.Whz5JOL71710727997925.js";import{C as j}from"./vanilla-307d3a93.esm.oDMQ5mjs1710727997925.js";import{L as U,a as V,b as X}from"./LineSegments2.VW83iRZ61710727997925.js";const z=async()=>{const e=await T("./plugins/digitalCity/model/shanghai.FBX");let t=null,o=null,i=null;return e.traverse(a=>{a.name==="CITY_UNTRIANGULATED"&&(t=a),a.name==="LANDMASS"&&(o=a),a.name==="ROADS"&&(i=a)}),{model:e,city:t,land:o,roads:i}};var Y="varying vec4 vPosition;\nvoid main(){\n	vPosition=modelMatrix*vec4(position,1.);\n	csm_Position=position*vec3(1.);\n}",K="uniform mat4 modelMatrix;\nvarying vec4 vPosition;\nuniform vec3 uMax;\nuniform vec3 uMin;\nuniform float uOpacity;\nuniform float uBorderWidth;\nuniform vec3 uLightColor;\nuniform vec3 uColor;\nuniform float uCircleTime;\nuniform float uTime;\nuniform vec3 uTopColor;\nuniform bool uGradient;\nvec4 uMax_world;\nvec4 uMin_world;\nvoid main(){\n	\n	uMax_world=modelMatrix*vec4(uMax,1.);\n	uMin_world=modelMatrix*vec4(uMin,1.);\n	vec3 distColor=uColor;\n	float residue=uTime-floor(uTime/uCircleTime)*uCircleTime;\n	float rate=residue/uCircleTime;\n	float lightOffset=rate*(uMax_world.y-uMin_world.y);\n	\n	if(uMin_world.y+lightOffset<vPosition.y&&uMin_world.y+lightOffset+uBorderWidth>vPosition.y){\n		csm_DiffuseColor=vec4(uLightColor,uOpacity);\n	}else{\n		csm_DiffuseColor=vec4(distColor,uOpacity);\n	}\n	\n	\n	if(uGradient){\n		float rateHight=(vPosition.y-uMin_world.y)/(uMax_world.y-uMin_world.y);\n		vec3 outColor=mix(csm_DiffuseColor.xyz,uTopColor,rateHight*2.);\n		csm_DiffuseColor=vec4(outColor,uOpacity);\n	}\n}";const Z=["object"],q=w({__name:"buildingsModelCustomShader",props:{model:{},bulidingsColor:{default:"#e523ff"},landColor:{default:"#112233"},topColor:{default:"#ffff00"},opacity:{default:.9},gradient:{type:Boolean,default:!0}},setup(s){const e=s,t=_(0),o=e.model.city;o.renderOrder=1001;const i=e.model.land,a=(r,d)=>{let p;r==="cu"||r==="land"&&(p=Array.isArray(i.material)?i.material:[i.material],p.forEach(y=>{y[d].setStyle(e.landColor),y.side=M}))};(()=>{const{geometry:r}=o;r.computeBoundingBox(),r.computeBoundingSphere();const{max:d,min:p}=r.boundingBox;if(o.material.__csm)return;const y=new j({baseMaterial:o.material,vertexShader:Y,fragmentShader:K,silent:!0,uniforms:{uMax:{value:d},uMin:{value:p},uBorderWidth:{value:5},uCircleTime:{value:5},uColor:{value:new f(e.bulidingsColor)},uOpacity:{value:e.opacity},uLightColor:{value:new f("#ffffff")},uTopColor:{value:new f(e.topColor)},uTime:t,uGradient:{value:e.gradient}},depthWrite:!0,depthTest:!0,transparent:!0,side:M});o.material.dispose(),o.material=y})();const{onLoop:u}=B();u(({delta:r})=>{t.value+=r}),S(()=>{e.bulidingsColor&&o.material.uniforms.uColor.value.setStyle(e.bulidingsColor),e.landColor&&a("land","color"),e.opacity&&(o.material.uniforms.uOpacity.value=e.opacity)}),L(e,(r,d)=>{o.material.uniforms.uGradient.value=r.gradient});const h=e.model.model.clone();return(r,d)=>(c(),m("primitive",{object:n(h)},null,8,Z))}}),J=["object"],Q=w({__name:"buildingsLines",props:{builds:{},width:{default:1},color:{default:"#FFF"},opacity:{default:1},style:{default:"Wireframe"}},setup(s){const e=s;let t=null,o=null;if(e.style==="Wireframe"){const i=new b(e.builds.geometry);let l=new U().fromEdgesGeometry(i),u=new V({color:e.color,linewidth:e.width,opacity:e.opacity,transparent:!0,depthWrite:!0,depthTest:!0});u.resolution.set(window.innerWidth,window.innerHeight),t=new X(l,u),t.applyMatrix4(e.builds.matrix.clone())}else{o={transparent:!0,uniforms:{uColor:{value:new f(e.color)},uOpacity:{value:e.opacity}},vertexShader:"\n       void main() {\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }\n      ",fragmentShader:" \n        uniform vec3 uColor;\n				uniform float uOpacity;\n        void main() {\n          gl_FragColor = vec4(uColor, uOpacity);\n        }\n      "};const i=new b(e.builds.geometry),a=new A(o);t=new LineSegments(i,a),t.applyMatrix4(e.builds.matrix.clone()),t.material.linewidth=e.width,t.renderOrder=1e3}return S(()=>{e.style==="Shader"&&(e.color&&(o.uniforms.uColor.value=new f(e.color)),e.opacity&&(o.uniforms.uOpacity.value=e.opacity)),e.style==="Wireframe"&&(e.color&&(t.material.color=new f(e.color)),e.opacity&&(t.material.opacity=e.opacity)),e.width&&(t.material.linewidth=e.width)}),(i,a)=>(c(),m("primitive",{object:n(t)},null,8,J))}}),ee=C("TresAmbientLight",{color:"#ffffff"},null,-1),oe=C("TresDirectionalLight",{position:[100,100,0],intensity:.5,color:"#ffffff"},null,-1),te={key:1,args:[1e3],position:[0,19,0]},ae={key:2,args:[6e3,100],position:[0,19,0]},ne=w({__name:"pagesShow",props:{showBuildings:{type:Boolean,default:!0},autoRotate:{type:Boolean,default:!0},showAxesHelper:{type:Boolean,default:!0},showGridHelper:{type:Boolean,default:!0},disableRender:{type:Boolean,default:!1}},async setup(s){let e,t;const o=s,i=x({clearColor:"#000000",shadows:!0,alpha:!1,useLegacyLights:!0,shadowMapType:O,outputColorSpace:D,toneMapping:R,disableRender:o.disableRender}),a=x({autoRotate:o.autoRotate,enableDamping:!0});let l=null;o.showBuildings&&(l=([e,t]=G(()=>z()),e=await e,t(),e));const u=_(),h=_();return(r,d)=>(c(),N(n(W),P({ref_key:"tcRef",ref:h},i,{"window-size":""}),{default:E(()=>[C("TresPerspectiveCamera",{ref_key:"perspectiveCameraRef",ref:u,position:[600,750,-1221],fov:45,near:1,far:1e5},null,512),v(n(F),k(H(a)),null,16),ee,oe,o.showBuildings&&n(l)?(c(),m(I,{key:0},[v(q,{model:n(l)},null,8,["model"]),v(Q,{builds:n(l).city,color:"#000"},null,8,["builds"])],64)):g("",!0),$(r.$slots,"ability"),o.showAxesHelper?(c(),m("TresAxesHelper",te)):g("",!0),o.showGridHelper?(c(),m("TresGridHelper",ae)):g("",!0)]),_:3},16))}});export{ne as _,q as a,Q as b,z as l};
