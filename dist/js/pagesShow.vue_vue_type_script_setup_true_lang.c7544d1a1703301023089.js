import{bj as de,Z as H,k as I,a3 as ce,a4 as ee,w as ue,o as M,c as A,J as x,aM as E,aF as k,bc as G,aH as w,bk as fe,bl as $,bm as N,bn as C,bo as pe,bb as te,b5 as z,aV as me,bp as L,b1 as ie,aT as ne,b2 as D,a_ as he,ba as ve,aX as ye,an as ge,aS as q,$ as X,a0 as we,a1 as Se,a2 as xe,aA as _e,v as be,C as Me,a6 as Ce,a7 as Ee,V as j,a as O,a8 as Ae,a9 as Be,aa as Te,D as Ue,W as P,Y as ze}from"./vendor.e78e09731703301023089.js";import{C as Le}from"./vanilla-307d3a93.esm.c714d6781703301023089.js";const De=async()=>{const e=await de("./plugins/digitalCity/model/shanghai.FBX");let t=null,i=null;return e.traverse(n=>{n.name==="CITY_UNTRIANGULATED"&&(t=n),n.name==="LANDMASS"&&(i=n)}),{model:e,city:t,land:i}},Oe=["object"],Pe=H({__name:"buildingsModelCustomShader",props:{model:{},bulidingsColor:{default:"#e523ff"},landColor:{default:"#112233"},topColor:{default:"#ffff00"},opacity:{default:.9},gradient:{type:Boolean,default:!0}},setup(l){const e=l,t=I(0),i=e.model.city;i.renderOrder=1001;const n=e.model.land,a=(r,d)=>{let p;r==="cu"||r==="land"&&(p=Array.isArray(n.material)?n.material:[n.material],p.forEach(h=>{h[d].setStyle(e.landColor),h.side=k}))};(()=>{const{geometry:r}=i;r.computeBoundingBox(),r.computeBoundingSphere();const{max:d,min:p}=r.boundingBox;if(i.material.__csm)return;const h=new Le({baseMaterial:i.material,vertexShader:"\n		varying vec4 vPosition;\n		void main() {\n			vPosition = modelMatrix * vec4(position,1.0);\n			csm_Position = position * vec3(1.0);\n		}\n		",fragmentShader:"\n		uniform mat4 modelMatrix;\n		varying vec4 vPosition;\n		uniform vec3 uMax; \n		uniform vec3 uMin; \n		uniform float uOpacity;  \n		uniform float uBorderWidth; \n		uniform vec3 uLightColor;\n		uniform vec3 uColor;\n		uniform float uCircleTime; \n		uniform float uTime; \n		uniform vec3 uTopColor;					//顶部颜色\n		uniform bool uGradient;\n		vec4 uMax_world;\n		vec4 uMin_world;\n		void main() {\n			// 转世界坐标\n			uMax_world =  modelMatrix * vec4(uMax,1.0);\n			uMin_world =  modelMatrix * vec4(uMin,1.0);\n			vec3 distColor = uColor;\n			float residue = uTime - floor(uTime / uCircleTime) * uCircleTime;\n			float rate = residue / uCircleTime;\n			float lightOffset = rate * (uMax_world.y - uMin_world.y);\n\n			if (uMin_world.y + lightOffset < vPosition.y && uMin_world.y + lightOffset + uBorderWidth > vPosition.y) {\n				csm_DiffuseColor = vec4(uLightColor, uOpacity);\n			} else {\n				csm_DiffuseColor = vec4(distColor, uOpacity);\n			}\n\n			//根据高度计算颜色\n			if(uGradient){\n				float rateHight = (vPosition.y - uMin_world.y) / (uMax_world.y - uMin_world.y); \n				vec3 outColor = mix(csm_DiffuseColor.xyz, uTopColor, rateHight*2.0);\n				csm_DiffuseColor = vec4(outColor, uOpacity);\n			}\n    }\n		",silent:!0,uniforms:{uMax:{value:d},uMin:{value:p},uBorderWidth:{value:5},uCircleTime:{value:5},uColor:{value:new E(e.bulidingsColor)},uOpacity:{value:e.opacity},uLightColor:{value:new E("#ffffff")},uTopColor:{value:new E(e.topColor)},uTime:t,uGradient:{value:e.gradient}},depthWrite:!0,depthTest:!0,transparent:!0,side:k});i.material.dispose(),i.material=h})();const{onLoop:o}=ce();o(({delta:r})=>{t.value+=r}),ee(()=>{e.bulidingsColor&&i.material.uniforms.uColor.value.setStyle(e.bulidingsColor),e.landColor&&a("land","color"),e.opacity&&(i.material.uniforms.uOpacity.value=e.opacity)}),ue(e,(r,d)=>{i.material.uniforms.uGradient.value=r.gradient});const m=e.model.model.clone();return(r,d)=>(M(),A("primitive",{object:x(m)},null,8,Oe))}}),Y=new G,B=new w;class oe extends fe{constructor(){super(),this.isLineSegmentsGeometry=!0,this.type="LineSegmentsGeometry";const e=[-1,2,0,1,2,0,-1,1,0,1,1,0,-1,0,0,1,0,0,-1,-1,0,1,-1,0],t=[-1,2,1,2,-1,1,1,1,-1,-1,1,-1,-1,-2,1,-2],i=[0,2,1,2,3,1,2,4,3,4,5,3,4,6,5,6,7,5];this.setIndex(i),this.setAttribute("position",new $(e,3)),this.setAttribute("uv",new $(t,2))}applyMatrix4(e){const t=this.attributes.instanceStart,i=this.attributes.instanceEnd;return t!==void 0&&(t.applyMatrix4(e),i.applyMatrix4(e),t.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}setPositions(e){let t;e instanceof Float32Array?t=e:Array.isArray(e)&&(t=new Float32Array(e));const i=new N(t,6,1);return this.setAttribute("instanceStart",new C(i,3,0)),this.setAttribute("instanceEnd",new C(i,3,3)),this.computeBoundingBox(),this.computeBoundingSphere(),this}setColors(e){let t;e instanceof Float32Array?t=e:Array.isArray(e)&&(t=new Float32Array(e));const i=new N(t,6,1);return this.setAttribute("instanceColorStart",new C(i,3,0)),this.setAttribute("instanceColorEnd",new C(i,3,3)),this}fromWireframeGeometry(e){return this.setPositions(e.attributes.position.array),this}fromEdgesGeometry(e){return this.setPositions(e.attributes.position.array),this}fromMesh(e){return this.fromWireframeGeometry(new pe(e.geometry)),this}fromLineSegments(e){const t=e.geometry;return this.setPositions(t.attributes.position.array),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new G);const e=this.attributes.instanceStart,t=this.attributes.instanceEnd;e!==void 0&&t!==void 0&&(this.boundingBox.setFromBufferAttribute(e),Y.setFromBufferAttribute(t),this.boundingBox.union(Y))}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new te),this.boundingBox===null&&this.computeBoundingBox();const e=this.attributes.instanceStart,t=this.attributes.instanceEnd;if(e!==void 0&&t!==void 0){const i=this.boundingSphere.center;this.boundingBox.getCenter(i);let n=0;for(let a=0,s=e.count;a<s;a++)B.fromBufferAttribute(e,a),n=Math.max(n,i.distanceToSquared(B)),B.fromBufferAttribute(t,a),n=Math.max(n,i.distanceToSquared(B));this.boundingSphere.radius=Math.sqrt(n),isNaN(this.boundingSphere.radius)&&console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",this)}}toJSON(){}applyMatrix(e){return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."),this.applyMatrix4(e)}}z.line={worldUnits:{value:1},linewidth:{value:1},resolution:{value:new me(1,1)},dashOffset:{value:0},dashScale:{value:1},dashSize:{value:1},gapSize:{value:1}};L.line={uniforms:ie.merge([z.common,z.fog,z.line]),vertexShader:"\n		#include <common>\n		#include <color_pars_vertex>\n		#include <fog_pars_vertex>\n		#include <logdepthbuf_pars_vertex>\n		#include <clipping_planes_pars_vertex>\n\n		uniform float linewidth;\n		uniform vec2 resolution;\n\n		attribute vec3 instanceStart;\n		attribute vec3 instanceEnd;\n\n		attribute vec3 instanceColorStart;\n		attribute vec3 instanceColorEnd;\n\n		#ifdef WORLD_UNITS\n\n			varying vec4 worldPos;\n			varying vec3 worldStart;\n			varying vec3 worldEnd;\n\n			#ifdef USE_DASH\n\n				varying vec2 vUv;\n\n			#endif\n\n		#else\n\n			varying vec2 vUv;\n\n		#endif\n\n		#ifdef USE_DASH\n\n			uniform float dashScale;\n			attribute float instanceDistanceStart;\n			attribute float instanceDistanceEnd;\n			varying float vLineDistance;\n\n		#endif\n\n		void trimSegment( const in vec4 start, inout vec4 end ) {\n\n			// trim end segment so it terminates between the camera plane and the near plane\n\n			// conservative estimate of the near plane\n			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n			float nearEstimate = - 0.5 * b / a;\n\n			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n			end.xyz = mix( start.xyz, end.xyz, alpha );\n\n		}\n\n		void main() {\n\n			#ifdef USE_COLOR\n\n				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n			#endif\n\n			#ifdef USE_DASH\n\n				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n				vUv = uv;\n\n			#endif\n\n			float aspect = resolution.x / resolution.y;\n\n			// camera space\n			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n			#ifdef WORLD_UNITS\n\n				worldStart = start.xyz;\n				worldEnd = end.xyz;\n\n			#else\n\n				vUv = uv;\n\n			#endif\n\n			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n			// perhaps there is a more elegant solution -- WestLangley\n\n			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n			if ( perspective ) {\n\n				if ( start.z < 0.0 && end.z >= 0.0 ) {\n\n					trimSegment( start, end );\n\n				} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n					trimSegment( end, start );\n\n				}\n\n			}\n\n			// clip space\n			vec4 clipStart = projectionMatrix * start;\n			vec4 clipEnd = projectionMatrix * end;\n\n			// ndc space\n			vec3 ndcStart = clipStart.xyz / clipStart.w;\n			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n			// direction\n			vec2 dir = ndcEnd.xy - ndcStart.xy;\n\n			// account for clip-space aspect ratio\n			dir.x *= aspect;\n			dir = normalize( dir );\n\n			#ifdef WORLD_UNITS\n\n				vec3 worldDir = normalize( end.xyz - start.xyz );\n				vec3 tmpFwd = normalize( mix( start.xyz, end.xyz, 0.5 ) );\n				vec3 worldUp = normalize( cross( worldDir, tmpFwd ) );\n				vec3 worldFwd = cross( worldDir, worldUp );\n				worldPos = position.y < 0.5 ? start: end;\n\n				// height offset\n				float hw = linewidth * 0.5;\n				worldPos.xyz += position.x < 0.0 ? hw * worldUp : - hw * worldUp;\n\n				// don't extend the line if we're rendering dashes because we\n				// won't be rendering the endcaps\n				#ifndef USE_DASH\n\n					// cap extension\n					worldPos.xyz += position.y < 0.5 ? - hw * worldDir : hw * worldDir;\n\n					// add width to the box\n					worldPos.xyz += worldFwd * hw;\n\n					// endcaps\n					if ( position.y > 1.0 || position.y < 0.0 ) {\n\n						worldPos.xyz -= worldFwd * 2.0 * hw;\n\n					}\n\n				#endif\n\n				// project the worldpos\n				vec4 clip = projectionMatrix * worldPos;\n\n				// shift the depth of the projected points so the line\n				// segments overlap neatly\n				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n				clip.z = clipPose.z * clip.w;\n\n			#else\n\n				vec2 offset = vec2( dir.y, - dir.x );\n				// undo aspect ratio adjustment\n				dir.x /= aspect;\n				offset.x /= aspect;\n\n				// sign flip\n				if ( position.x < 0.0 ) offset *= - 1.0;\n\n				// endcaps\n				if ( position.y < 0.0 ) {\n\n					offset += - dir;\n\n				} else if ( position.y > 1.0 ) {\n\n					offset += dir;\n\n				}\n\n				// adjust for linewidth\n				offset *= linewidth;\n\n				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n				offset /= resolution.y;\n\n				// select end\n				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n				// back to clip space\n				offset *= clip.w;\n\n				clip.xy += offset;\n\n			#endif\n\n			gl_Position = clip;\n\n			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n			#include <logdepthbuf_vertex>\n			#include <clipping_planes_vertex>\n			#include <fog_vertex>\n\n		}\n		",fragmentShader:"\n		uniform vec3 diffuse;\n		uniform float opacity;\n		uniform float linewidth;\n\n		#ifdef USE_DASH\n\n			uniform float dashOffset;\n			uniform float dashSize;\n			uniform float gapSize;\n\n		#endif\n\n		varying float vLineDistance;\n\n		#ifdef WORLD_UNITS\n\n			varying vec4 worldPos;\n			varying vec3 worldStart;\n			varying vec3 worldEnd;\n\n			#ifdef USE_DASH\n\n				varying vec2 vUv;\n\n			#endif\n\n		#else\n\n			varying vec2 vUv;\n\n		#endif\n\n		#include <common>\n		#include <color_pars_fragment>\n		#include <fog_pars_fragment>\n		#include <logdepthbuf_pars_fragment>\n		#include <clipping_planes_pars_fragment>\n\n		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n			float mua;\n			float mub;\n\n			vec3 p13 = p1 - p3;\n			vec3 p43 = p4 - p3;\n\n			vec3 p21 = p2 - p1;\n\n			float d1343 = dot( p13, p43 );\n			float d4321 = dot( p43, p21 );\n			float d1321 = dot( p13, p21 );\n			float d4343 = dot( p43, p43 );\n			float d2121 = dot( p21, p21 );\n\n			float denom = d2121 * d4343 - d4321 * d4321;\n\n			float numer = d1343 * d4321 - d1321 * d4343;\n\n			mua = numer / denom;\n			mua = clamp( mua, 0.0, 1.0 );\n			mub = ( d1343 + d4321 * ( mua ) ) / d4343;\n			mub = clamp( mub, 0.0, 1.0 );\n\n			return vec2( mua, mub );\n\n		}\n\n		void main() {\n\n			#include <clipping_planes_fragment>\n\n			#ifdef USE_DASH\n\n				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n			#endif\n\n			float alpha = opacity;\n\n			#ifdef WORLD_UNITS\n\n				// Find the closest points on the view ray and the line segment\n				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n				vec3 lineDir = worldEnd - worldStart;\n				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n				vec3 p1 = worldStart + lineDir * params.x;\n				vec3 p2 = rayEnd * params.y;\n				vec3 delta = p1 - p2;\n				float len = length( delta );\n				float norm = len / linewidth;\n\n				#ifndef USE_DASH\n\n					#ifdef USE_ALPHA_TO_COVERAGE\n\n						float dnorm = fwidth( norm );\n						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n					#else\n\n						if ( norm > 0.5 ) {\n\n							discard;\n\n						}\n\n					#endif\n\n				#endif\n\n			#else\n\n				#ifdef USE_ALPHA_TO_COVERAGE\n\n					// artifacts appear on some hardware if a derivative is taken within a conditional\n					float a = vUv.x;\n					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n					float len2 = a * a + b * b;\n					float dlen = fwidth( len2 );\n\n					if ( abs( vUv.y ) > 1.0 ) {\n\n						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n					}\n\n				#else\n\n					if ( abs( vUv.y ) > 1.0 ) {\n\n						float a = vUv.x;\n						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n						float len2 = a * a + b * b;\n\n						if ( len2 > 1.0 ) discard;\n\n					}\n\n				#endif\n\n			#endif\n\n			vec4 diffuseColor = vec4( diffuse, alpha );\n\n			#include <logdepthbuf_fragment>\n			#include <color_fragment>\n\n			gl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n			#include <tonemapping_fragment>\n			#include <colorspace_fragment>\n			#include <fog_fragment>\n			#include <premultiplied_alpha_fragment>\n\n		}\n		"};class ae extends ne{constructor(e){super({type:"LineMaterial",uniforms:ie.clone(L.line.uniforms),vertexShader:L.line.vertexShader,fragmentShader:L.line.fragmentShader,clipping:!0}),this.isLineMaterial=!0,this.setValues(e)}get color(){return this.uniforms.diffuse.value}set color(e){this.uniforms.diffuse.value=e}get worldUnits(){return"WORLD_UNITS"in this.defines}set worldUnits(e){e===!0?this.defines.WORLD_UNITS="":delete this.defines.WORLD_UNITS}get linewidth(){return this.uniforms.linewidth.value}set linewidth(e){this.uniforms.linewidth&&(this.uniforms.linewidth.value=e)}get dashed(){return"USE_DASH"in this.defines}set dashed(e){e===!0!==this.dashed&&(this.needsUpdate=!0),e===!0?this.defines.USE_DASH="":delete this.defines.USE_DASH}get dashScale(){return this.uniforms.dashScale.value}set dashScale(e){this.uniforms.dashScale.value=e}get dashSize(){return this.uniforms.dashSize.value}set dashSize(e){this.uniforms.dashSize.value=e}get dashOffset(){return this.uniforms.dashOffset.value}set dashOffset(e){this.uniforms.dashOffset.value=e}get gapSize(){return this.uniforms.gapSize.value}set gapSize(e){this.uniforms.gapSize.value=e}get opacity(){return this.uniforms.opacity.value}set opacity(e){this.uniforms&&(this.uniforms.opacity.value=e)}get resolution(){return this.uniforms.resolution.value}set resolution(e){this.uniforms.resolution.value.copy(e)}get alphaToCoverage(){return"USE_ALPHA_TO_COVERAGE"in this.defines}set alphaToCoverage(e){this.defines&&(e===!0!==this.alphaToCoverage&&(this.needsUpdate=!0),e===!0?(this.defines.USE_ALPHA_TO_COVERAGE="",this.extensions.derivatives=!0):(delete this.defines.USE_ALPHA_TO_COVERAGE,this.extensions.derivatives=!1))}}const J=new w,Z=new w,c=new D,u=new D,v=new D,W=new w,R=new he,f=new ve,K=new w,T=new G,U=new te,y=new D;let g,_;function Q(l,e,t){return y.set(0,0,-e,1).applyMatrix4(l.projectionMatrix),y.multiplyScalar(1/y.w),y.x=_/t.width,y.y=_/t.height,y.applyMatrix4(l.projectionMatrixInverse),y.multiplyScalar(1/y.w),Math.abs(Math.max(y.x,y.y))}function We(l,e){const t=l.matrixWorld,i=l.geometry,n=i.attributes.instanceStart,a=i.attributes.instanceEnd,s=Math.min(i.instanceCount,n.count);for(let o=0,m=s;o<m;o++){f.start.fromBufferAttribute(n,o),f.end.fromBufferAttribute(a,o),f.applyMatrix4(t);const r=new w,d=new w;g.distanceSqToSegment(f.start,f.end,d,r),d.distanceTo(r)<_*.5&&e.push({point:d,pointOnLine:r,distance:g.origin.distanceTo(d),object:l,face:null,faceIndex:o,uv:null,uv1:null})}}function Re(l,e,t){const i=e.projectionMatrix,a=l.material.resolution,s=l.matrixWorld,o=l.geometry,m=o.attributes.instanceStart,r=o.attributes.instanceEnd,d=Math.min(o.instanceCount,m.count),p=-e.near;g.at(1,v),v.w=1,v.applyMatrix4(e.matrixWorldInverse),v.applyMatrix4(i),v.multiplyScalar(1/v.w),v.x*=a.x/2,v.y*=a.y/2,v.z=0,W.copy(v),R.multiplyMatrices(e.matrixWorldInverse,s);for(let h=0,re=d;h<re;h++){if(c.fromBufferAttribute(m,h),u.fromBufferAttribute(r,h),c.w=1,u.w=1,c.applyMatrix4(R),u.applyMatrix4(R),c.z>p&&u.z>p)continue;if(c.z>p){const b=c.z-u.z,S=(c.z-p)/b;c.lerp(u,S)}else if(u.z>p){const b=u.z-c.z,S=(u.z-p)/b;u.lerp(c,S)}c.applyMatrix4(i),u.applyMatrix4(i),c.multiplyScalar(1/c.w),u.multiplyScalar(1/u.w),c.x*=a.x/2,c.y*=a.y/2,u.x*=a.x/2,u.y*=a.y/2,f.start.copy(c),f.start.z=0,f.end.copy(u),f.end.z=0;const F=f.closestPointToPointParameter(W,!0);f.at(F,K);const V=ge.lerp(c.z,u.z,F),se=V>=-1&&V<=1,le=W.distanceTo(K)<_*.5;if(se&&le){f.start.fromBufferAttribute(m,h),f.end.fromBufferAttribute(r,h),f.start.applyMatrix4(s),f.end.applyMatrix4(s);const b=new w,S=new w;g.distanceSqToSegment(f.start,f.end,S,b),t.push({point:S,pointOnLine:b,distance:g.origin.distanceTo(S),object:l,face:null,faceIndex:h,uv:null,uv1:null})}}}class Ie extends ye{constructor(e=new oe,t=new ae({color:Math.random()*16777215})){super(e,t),this.isLineSegments2=!0,this.type="LineSegments2"}computeLineDistances(){const e=this.geometry,t=e.attributes.instanceStart,i=e.attributes.instanceEnd,n=new Float32Array(2*t.count);for(let s=0,o=0,m=t.count;s<m;s++,o+=2)J.fromBufferAttribute(t,s),Z.fromBufferAttribute(i,s),n[o]=o===0?0:n[o-1],n[o+1]=n[o]+J.distanceTo(Z);const a=new N(n,2,1);return e.setAttribute("instanceDistanceStart",new C(a,1,0)),e.setAttribute("instanceDistanceEnd",new C(a,1,1)),this}raycast(e,t){const i=this.material.worldUnits,n=e.camera;n===null&&!i&&console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');const a=e.params.Line2!==void 0&&e.params.Line2.threshold||0;g=e.ray;const s=this.matrixWorld,o=this.geometry,m=this.material;_=m.linewidth+a,o.boundingSphere===null&&o.computeBoundingSphere(),U.copy(o.boundingSphere).applyMatrix4(s);let r;if(i)r=_*.5;else{const p=Math.max(n.near,U.distanceToPoint(g.origin));r=Q(n,p,m.resolution)}if(U.radius+=r,g.intersectsSphere(U)===!1)return;o.boundingBox===null&&o.computeBoundingBox(),T.copy(o.boundingBox).applyMatrix4(s);let d;if(i)d=_*.5;else{const p=Math.max(n.near,T.distanceToPoint(g.origin));d=Q(n,p,m.resolution)}T.expandByScalar(d),g.intersectsBox(T)!==!1&&(i?We(this,t):Re(this,n,t))}}const Ne=["object"],He=H({__name:"buildingsLines",props:{builds:{},width:{default:1},color:{default:"#FFF"},opacity:{default:1},style:{default:"Wireframe"}},setup(l){const e=l;let t=null,i=null;if(e.style==="Wireframe"){const n=new q(e.builds.geometry);let s=new oe().fromEdgesGeometry(n),o=new ae({color:e.color,linewidth:e.width,opacity:e.opacity,transparent:!0,depthWrite:!0,depthTest:!0});o.resolution.set(window.innerWidth,window.innerHeight),t=new Ie(s,o),t.applyMatrix4(e.builds.matrix.clone())}else{i={transparent:!0,uniforms:{uColor:{value:new E(e.color)},uOpacity:{value:e.opacity}},vertexShader:"\n       void main() {\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }\n      ",fragmentShader:" \n        uniform vec3 uColor;\n				uniform float uOpacity;\n        void main() {\n          gl_FragColor = vec4(uColor, uOpacity);\n        }\n      "};const n=new q(e.builds.geometry),a=new ne(i);t=new LineSegments(n,a),t.applyMatrix4(e.builds.matrix.clone()),t.material.linewidth=e.width,t.renderOrder=1e3}return ee(()=>{e.style==="Shader"&&(e.color&&(i.uniforms.uColor.value=new E(e.color)),e.opacity&&(i.uniforms.uOpacity.value=e.opacity)),e.style==="Wireframe"&&(e.color&&(t.material.color=new E(e.color)),e.opacity&&(t.material.opacity=e.opacity)),e.width&&(t.material.linewidth=e.width)}),(n,a)=>(M(),A("primitive",{object:x(t)},null,8,Ne))}}),Ge=j("TresAmbientLight",{color:"#ffffff"},null,-1),je=j("TresDirectionalLight",{position:[100,100,0],intensity:.5,color:"#ffffff"},null,-1),Fe={key:1,args:[1e3],position:[0,19,0]},Ve={key:2,args:[6e3,100],position:[0,19,0]},Xe=H({__name:"pagesShow",props:{showBuildings:{type:Boolean,default:!0},autoRotate:{type:Boolean,default:!0},showAxesHelper:{type:Boolean,default:!0},showGridHelper:{type:Boolean,default:!0},disableRender:{type:Boolean,default:!1}},async setup(l){let e,t;const i=l,n=X({clearColor:"#000000",shadows:!0,alpha:!1,useLegacyLights:!0,shadowMapType:we,outputColorSpace:Se,toneMapping:xe,disableRender:i.disableRender}),a=X({autoRotate:i.autoRotate,enableDamping:!0});let s=null;i.showBuildings&&(s=([e,t]=_e(()=>De()),e=await e,t(),e));const o=I(),m=I();return(r,d)=>(M(),be(x(Ee),Ce({ref_key:"tcRef",ref:m},n,{"window-size":""}),{default:Me(()=>[j("TresPerspectiveCamera",{ref_key:"perspectiveCameraRef",ref:o,position:[600,750,-1221],fov:45,near:1,far:1e4},null,512),O(x(Te),Ae(Be(a)),null,16),Ge,je,i.showBuildings&&x(s)?(M(),A(Ue,{key:0},[O(Pe,{model:x(s)},null,8,["model"]),O(He,{builds:x(s).city,color:"#000"},null,8,["builds"])],64)):P("",!0),ze(r.$slots,"ability"),i.showAxesHelper?(M(),A("TresAxesHelper",Fe)):P("",!0),i.showGridHelper?(M(),A("TresGridHelper",Ve)):P("",!0)]),_:3},16))}});export{Xe as _,Pe as a,He as b,De as l};
