var oe=Object.defineProperty,re=Object.defineProperties;var ce=Object.getOwnPropertyDescriptors;var Tn=Object.getOwnPropertySymbols;var ae=Object.prototype.hasOwnProperty,le=Object.prototype.propertyIsEnumerable;var Bn=(e,n,t)=>n in e?oe(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t,Mt=(e,n)=>{for(var t in n||(n={}))ae.call(n,t)&&Bn(e,t,n[t]);if(Tn)for(var t of Tn(n))le.call(n,t)&&Bn(e,t,n[t]);return e},Pn=(e,n)=>re(e,ce(n));import{an as Wt,aK as hn,aH as U,aR as pt,aW as Jn,b7 as W,aI as Bt,b8 as ue,aX as K,b9 as Y,aO as fe,aF as Qn,aL as _n,aU as cn,ba as pe,bb as ye,k as Xt,Z as On,bc as de,a4 as me,o as xn,c as wn,V as Mn,J as _t,D as Gn,aJ as Sn,aT as he,_ as xe,a5 as we,ak as Ae,H as be,I as ge,t as Te,X as Be,aA as Pe,$ as vn,af as _e,a as St,C as Me,a6 as Cn}from"./vendor.a5978c271702632737896.js";import{_ as Se,l as ve,b as Ce}from"./pagesShow.vue_vue_type_script_setup_true_lang.7669fd7d1702632737896.js";import{h as Ue}from"./heatmap.f5f872751702632737896.js";import{m as Le}from"./BufferGeometryUtils.6c231dd11702632737896.js";import"./vanilla-307d3a93.esm.6857946d1702632737896.js";import"./_commonjsHelpers.725317a41702632737896.js";const Un=36,an=-10,Ln=(e,n)=>e.getValueAt(n)+an,Fe=(e,n)=>{if(!n){let t=0;for(n=[];t<1e3;)n.push({x:Wt.randInt(1,e._config.width),y:Wt.randInt(1,e._config.height),value:Wt.randInt(an,Un)}),t++}e.setData({max:Un,min:an,data:n})},De=(e=250,n=250,t=!0)=>{const s=document.createElement("heatmap-canvas");return s.style.position="absolute",t||(s.style.display="none"),s.style.top="0",s.style.left="0",document.body.appendChild(s),Ue.create({container:s,width:e,height:n,blur:".8",radius:10,gradient:{.25:"rgb(0,0,255)",.55:"rgb(0,255,0)",.85:"yellow",1:"rgb(255,0,0)"}})},Ee=e=>{e.computeBoundingBox();const{max:n,min:t}=e.boundingBox;e.deleteAttribute("uv");const s=n.x-t.x,i=n.y-t.y,a=[];for(let r=0;r<e.attributes.position.count;r++)a.push((e.attributes.position.getX(r)-t.x)/s),a.push((e.attributes.position.getY(r)-t.y)/i);const o=new Float32Array(a);e.setAttribute("uv",new hn(o,2))},te=0,Ie=1,ze=2,Fn=2,Kt=1.25,Dn=1,Ht=6*4+4+4,Yt=65535,Ve=Math.pow(2,-24),Jt=Symbol("SKIP_GENERATION");function Re(e){return e.index?e.index.count:e.attributes.position.count}function yt(e){return Re(e)/3}function Ne(e,n=ArrayBuffer){return e>65535?new Uint32Array(new n(4*e)):new Uint16Array(new n(2*e))}function $e(e,n){if(!e.index){const t=e.attributes.position.count,s=n.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=Ne(t,s);e.setIndex(new hn(i,1));for(let a=0;a<t;a++)i[a]=a}}function ne(e){const n=yt(e),t=e.drawRange,s=t.start/3,i=(t.start+t.count)/3,a=Math.max(0,s),o=Math.min(n,i)-a;return[{offset:Math.floor(a),count:Math.floor(o)}]}function ee(e){if(!e.groups||!e.groups.length)return ne(e);const n=[],t=new Set,s=e.drawRange,i=s.start/3,a=(s.start+s.count)/3;for(const r of e.groups){const c=r.start/3,p=(r.start+r.count)/3;t.add(Math.max(i,c)),t.add(Math.min(a,p))}const o=Array.from(t.values()).sort((r,c)=>r-c);for(let r=0;r<o.length-1;r++){const c=o[r],p=o[r+1];n.push({offset:Math.floor(c),count:Math.floor(p-c)})}return n}function qe(e){if(e.groups.length===0)return!1;const n=yt(e),t=ee(e).sort((a,o)=>a.offset-o.offset),s=t[t.length-1];s.count=Math.min(n-s.offset,s.count);let i=0;return t.forEach(({count:a})=>i+=a),n!==i}function E(e,n,t){return t.min.x=n[e],t.min.y=n[e+1],t.min.z=n[e+2],t.max.x=n[e+3],t.max.y=n[e+4],t.max.z=n[e+5],t}function ke(e){e[0]=e[1]=e[2]=1/0,e[3]=e[4]=e[5]=-1/0}function En(e){let n=-1,t=-1/0;for(let s=0;s<3;s++){const i=e[s+3]-e[s];i>t&&(t=i,n=s)}return n}function In(e,n){n.set(e)}function zn(e,n,t){let s,i;for(let a=0;a<3;a++){const o=a+3;s=e[a],i=n[a],t[a]=s<i?s:i,s=e[o],i=n[o],t[o]=s>i?s:i}}function vt(e,n,t){for(let s=0;s<3;s++){const i=n[e+2*s],a=n[e+2*s+1],o=i-a,r=i+a;o<t[s]&&(t[s]=o),r>t[s+3]&&(t[s+3]=r)}}function xt(e){const n=e[3]-e[0],t=e[4]-e[1],s=e[5]-e[2];return 2*(n*t+t*s+s*n)}function Qt(e,n,t,s,i=null){let a=1/0,o=1/0,r=1/0,c=-1/0,p=-1/0,u=-1/0,f=1/0,l=1/0,y=1/0,m=-1/0,T=-1/0,b=-1/0;const d=i!==null;for(let h=n*6,A=(n+t)*6;h<A;h+=6){const x=e[h+0],w=e[h+1],g=x-w,_=x+w;g<a&&(a=g),_>c&&(c=_),d&&x<f&&(f=x),d&&x>m&&(m=x);const B=e[h+2],M=e[h+3],S=B-M,C=B+M;S<o&&(o=S),C>p&&(p=C),d&&B<l&&(l=B),d&&B>T&&(T=B);const P=e[h+4],v=e[h+5],L=P-v,F=P+v;L<r&&(r=L),F>u&&(u=F),d&&P<y&&(y=P),d&&P>b&&(b=P)}s[0]=a,s[1]=o,s[2]=r,s[3]=c,s[4]=p,s[5]=u,d&&(i[0]=f,i[1]=l,i[2]=y,i[3]=m,i[4]=T,i[5]=b)}function He(e,n,t,s){let i=1/0,a=1/0,o=1/0,r=-1/0,c=-1/0,p=-1/0;for(let u=n*6,f=(n+t)*6;u<f;u+=6){const l=e[u+0];l<i&&(i=l),l>r&&(r=l);const y=e[u+2];y<a&&(a=y),y>c&&(c=y);const m=e[u+4];m<o&&(o=m),m>p&&(p=m)}s[0]=i,s[1]=a,s[2]=o,s[3]=r,s[4]=c,s[5]=p}function Xe(e,n){ke(n);const t=e.attributes.position,s=e.index?e.index.array:null,i=yt(e),a=new Float32Array(i*6),o=t.normalized,r=t.array,c=t.offset||0;let p=3;t.isInterleavedBufferAttribute&&(p=t.data.stride);const u=["getX","getY","getZ"];for(let f=0;f<i;f++){const l=f*3,y=f*6;let m=l+0,T=l+1,b=l+2;s&&(m=s[m],T=s[T],b=s[b]),o||(m=m*p+c,T=T*p+c,b=b*p+c);for(let d=0;d<3;d++){let h,A,x;o?(h=t[u[d]](m),A=t[u[d]](T),x=t[u[d]](b)):(h=r[m+d],A=r[T+d],x=r[b+d]);let w=h;A<w&&(w=A),x<w&&(w=x);let g=h;A>g&&(g=A),x>g&&(g=x);const _=(g-w)/2,B=d*2;a[y+B+0]=w+_,a[y+B+1]=_+(Math.abs(w)+_)*Ve,w<n[d]&&(n[d]=w),g>n[d+3]&&(n[d+3]=g)}}return a}const Z=32,je=(e,n)=>e.candidate-n.candidate,Q=new Array(Z).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),Ct=new Float32Array(6);function Ye(e,n,t,s,i,a){let o=-1,r=0;if(a===te)o=En(n),o!==-1&&(r=(n[o]+n[o+3])/2);else if(a===Ie)o=En(e),o!==-1&&(r=Ze(t,s,i,o));else if(a===ze){const c=xt(e);let p=Kt*i;const u=s*6,f=(s+i)*6;for(let l=0;l<3;l++){const y=n[l],b=(n[l+3]-y)/Z;if(i<Z/4){const d=[...Q];d.length=i;let h=0;for(let x=u;x<f;x+=6,h++){const w=d[h];w.candidate=t[x+2*l],w.count=0;const{bounds:g,leftCacheBounds:_,rightCacheBounds:B}=w;for(let M=0;M<3;M++)B[M]=1/0,B[M+3]=-1/0,_[M]=1/0,_[M+3]=-1/0,g[M]=1/0,g[M+3]=-1/0;vt(x,t,g)}d.sort(je);let A=i;for(let x=0;x<A;x++){const w=d[x];for(;x+1<A&&d[x+1].candidate===w.candidate;)d.splice(x+1,1),A--}for(let x=u;x<f;x+=6){const w=t[x+2*l];for(let g=0;g<A;g++){const _=d[g];w>=_.candidate?vt(x,t,_.rightCacheBounds):(vt(x,t,_.leftCacheBounds),_.count++)}}for(let x=0;x<A;x++){const w=d[x],g=w.count,_=i-w.count,B=w.leftCacheBounds,M=w.rightCacheBounds;let S=0;g!==0&&(S=xt(B)/c);let C=0;_!==0&&(C=xt(M)/c);const P=Dn+Kt*(S*g+C*_);P<p&&(o=l,p=P,r=w.candidate)}}else{for(let A=0;A<Z;A++){const x=Q[A];x.count=0,x.candidate=y+b+A*b;const w=x.bounds;for(let g=0;g<3;g++)w[g]=1/0,w[g+3]=-1/0}for(let A=u;A<f;A+=6){let g=~~((t[A+2*l]-y)/b);g>=Z&&(g=Z-1);const _=Q[g];_.count++,vt(A,t,_.bounds)}const d=Q[Z-1];In(d.bounds,d.rightCacheBounds);for(let A=Z-2;A>=0;A--){const x=Q[A],w=Q[A+1];zn(x.bounds,w.rightCacheBounds,x.rightCacheBounds)}let h=0;for(let A=0;A<Z-1;A++){const x=Q[A],w=x.count,g=x.bounds,B=Q[A+1].rightCacheBounds;w!==0&&(h===0?In(g,Ct):zn(g,Ct,Ct)),h+=w;let M=0,S=0;h!==0&&(M=xt(Ct)/c);const C=i-h;C!==0&&(S=xt(B)/c);const P=Dn+Kt*(M*h+S*C);P<p&&(o=l,p=P,r=x.candidate)}}}}else console.warn("MeshBVH: Invalid build strategy value ".concat(a," used."));return{axis:o,pos:r}}function Ze(e,n,t,s){let i=0;for(let a=n,o=n+t;a<o;a++)i+=e[a*6+s*2];return i/t}class Ut{constructor(){}}function We(e,n,t,s,i,a){let o=s,r=s+i-1;const c=a.pos,p=a.axis*2;for(;;){for(;o<=r&&t[o*6+p]<c;)o++;for(;o<=r&&t[r*6+p]>=c;)r--;if(o<r){for(let u=0;u<3;u++){let f=n[o*3+u];n[o*3+u]=n[r*3+u],n[r*3+u]=f}for(let u=0;u<6;u++){let f=t[o*6+u];t[o*6+u]=t[r*6+u],t[r*6+u]=f}o++,r--}else return o}}function Ke(e,n,t,s,i,a){let o=s,r=s+i-1;const c=a.pos,p=a.axis*2;for(;;){for(;o<=r&&t[o*6+p]<c;)o++;for(;o<=r&&t[r*6+p]>=c;)r--;if(o<r){let u=e[o];e[o]=e[r],e[r]=u;for(let f=0;f<6;f++){let l=t[o*6+f];t[o*6+f]=t[r*6+f],t[r*6+f]=l}o++,r--}else return o}}function Je(e,n){const t=(e.index?e.index.count:e.attributes.position.count)/3,s=t>2**16,i=s?4:2,a=n?new SharedArrayBuffer(t*i):new ArrayBuffer(t*i),o=s?new Uint32Array(a):new Uint16Array(a);for(let r=0,c=o.length;r<c;r++)o[r]=r;return o}function Qe(e,n){const t=e.geometry,s=t.index?t.index.array:null,i=n.maxDepth,a=n.verbose,o=n.maxLeafTris,r=n.strategy,c=n.onProgress,p=yt(t),u=e._indirectBuffer;let f=!1;const l=new Float32Array(6),y=new Float32Array(6),m=Xe(t,l),T=n.indirect?Ke:We,b=[],d=n.indirect?ne(t):ee(t);if(d.length===1){const x=d[0],w=new Ut;w.boundingData=l,He(m,x.offset,x.count,y),A(w,x.offset,x.count,y),b.push(w)}else for(let x of d){const w=new Ut;w.boundingData=new Float32Array(6),Qt(m,x.offset,x.count,w.boundingData,y),A(w,x.offset,x.count,y),b.push(w)}return b;function h(x){c&&c(x/p)}function A(x,w,g,_=null,B=0){if(!f&&B>=i&&(f=!0,a&&(console.warn("MeshBVH: Max depth of ".concat(i," reached when generating BVH. Consider increasing maxDepth.")),console.warn(t))),g<=o||B>=i)return h(w+g),x.offset=w,x.count=g,x;const M=Ye(x.boundingData,_,m,w,g,r);if(M.axis===-1)return h(w+g),x.offset=w,x.count=g,x;const S=T(u,s,m,w,g,M);if(S===w||S===w+g)h(w+g),x.offset=w,x.count=g;else{x.splitAxis=M.axis;const C=new Ut,P=w,v=S-w;x.left=C,C.boundingData=new Float32Array(6),Qt(m,P,v,C.boundingData,y),A(C,P,v,y,B+1);const L=new Ut,F=S,I=g-v;x.right=L,L.boundingData=new Float32Array(6),Qt(m,F,I,L.boundingData,y),A(L,F,I,y,B+1)}return x}}function Oe(e,n){const t=e.geometry;n.indirect&&(e._indirectBuffer=Je(t,n.useSharedArrayBuffer),qe(t)&&!n.verbose&&console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),e._indirectBuffer||$e(t,n);const s=Qe(e,n);let i,a,o;const r=[],c=n.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let f=0;f<s.length;f++){const l=s[f];let y=p(l);const m=new c(Ht*y);i=new Float32Array(m),a=new Uint32Array(m),o=new Uint16Array(m),u(0,l),r.push(m)}e._roots=r;return;function p(f){return f.count?1:1+p(f.left)+p(f.right)}function u(f,l){const y=f/4,m=f/2,T=!!l.count,b=l.boundingData;for(let d=0;d<6;d++)i[y+d]=b[d];if(T){const d=l.offset,h=l.count;return a[y+6]=d,o[m+14]=h,o[m+15]=Yt,f+Ht}else{const d=l.left,h=l.right,A=l.splitAxis;let x;if(x=u(f+Ht,d),x/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return a[y+6]=x/4,x=u(x,h),a[y+7]=A,x}}}class J{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(n,t){let s=1/0,i=-1/0;for(let a=0,o=n.length;a<o;a++){const c=n[a][t];s=c<s?c:s,i=c>i?c:i}this.min=s,this.max=i}setFromPoints(n,t){let s=1/0,i=-1/0;for(let a=0,o=t.length;a<o;a++){const r=t[a],c=n.dot(r);s=c<s?c:s,i=c>i?c:i}this.min=s,this.max=i}isSeparated(n){return this.min>n.max||n.min>this.max}}J.prototype.setFromBox=function(){const e=new U;return function(t,s){const i=s.min,a=s.max;let o=1/0,r=-1/0;for(let c=0;c<=1;c++)for(let p=0;p<=1;p++)for(let u=0;u<=1;u++){e.x=i.x*c+a.x*(1-c),e.y=i.y*p+a.y*(1-p),e.z=i.z*u+a.z*(1-u);const f=t.dot(e);o=Math.min(f,o),r=Math.max(f,r)}this.min=o,this.max=r}}();const Ge=function(){const e=new U,n=new U,t=new U;return function(i,a,o){const r=i.start,c=e,p=a.start,u=n;t.subVectors(r,p),e.subVectors(i.end,i.start),n.subVectors(a.end,a.start);const f=t.dot(u),l=u.dot(c),y=u.dot(u),m=t.dot(c),b=c.dot(c)*y-l*l;let d,h;b!==0?d=(f*l-m*y)/b:d=0,h=(f+d*l)/y,o.x=d,o.y=h}}(),An=function(){const e=new pt,n=new U,t=new U;return function(i,a,o,r){Ge(i,a,e);let c=e.x,p=e.y;if(c>=0&&c<=1&&p>=0&&p<=1){i.at(c,o),a.at(p,r);return}else if(c>=0&&c<=1){p<0?a.at(0,r):a.at(1,r),i.closestPointToPoint(r,!0,o);return}else if(p>=0&&p<=1){c<0?i.at(0,o):i.at(1,o),a.closestPointToPoint(o,!0,r);return}else{let u;c<0?u=i.start:u=i.end;let f;p<0?f=a.start:f=a.end;const l=n,y=t;if(i.closestPointToPoint(f,!0,n),a.closestPointToPoint(u,!0,t),l.distanceToSquared(f)<=y.distanceToSquared(u)){o.copy(l),r.copy(f);return}else{o.copy(u),r.copy(y);return}}}}(),ts=function(){const e=new U,n=new U,t=new Jn,s=new W;return function(a,o){const{radius:r,center:c}=a,{a:p,b:u,c:f}=o;if(s.start=p,s.end=u,s.closestPointToPoint(c,!0,e).distanceTo(c)<=r||(s.start=p,s.end=f,s.closestPointToPoint(c,!0,e).distanceTo(c)<=r)||(s.start=u,s.end=f,s.closestPointToPoint(c,!0,e).distanceTo(c)<=r))return!0;const T=o.getPlane(t);if(Math.abs(T.distanceToPoint(c))<=r){const d=T.projectPoint(c,n);if(o.containsPoint(d))return!0}return!1}}(),ns=1e-15;function Ot(e){return Math.abs(e)<ns}class j extends Bt{constructor(...n){super(...n),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new U),this.satBounds=new Array(4).fill().map(()=>new J),this.points=[this.a,this.b,this.c],this.sphere=new ue,this.plane=new Jn,this.needsUpdate=!0}intersectsSphere(n){return ts(n,this)}update(){const n=this.a,t=this.b,s=this.c,i=this.points,a=this.satAxes,o=this.satBounds,r=a[0],c=o[0];this.getNormal(r),c.setFromPoints(r,i);const p=a[1],u=o[1];p.subVectors(n,t),u.setFromPoints(p,i);const f=a[2],l=o[2];f.subVectors(t,s),l.setFromPoints(f,i);const y=a[3],m=o[3];y.subVectors(s,n),m.setFromPoints(y,i),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(r,n),this.needsUpdate=!1}}j.prototype.closestPointToSegment=function(){const e=new U,n=new U,t=new W;return function(i,a=null,o=null){const{start:r,end:c}=i,p=this.points;let u,f=1/0;for(let l=0;l<3;l++){const y=(l+1)%3;t.start.copy(p[l]),t.end.copy(p[y]),An(t,i,e,n),u=e.distanceToSquared(n),u<f&&(f=u,a&&a.copy(e),o&&o.copy(n))}return this.closestPointToPoint(r,e),u=r.distanceToSquared(e),u<f&&(f=u,a&&a.copy(e),o&&o.copy(r)),this.closestPointToPoint(c,e),u=c.distanceToSquared(e),u<f&&(f=u,a&&a.copy(e),o&&o.copy(c)),Math.sqrt(f)}}();j.prototype.intersectsTriangle=function(){const e=new j,n=new Array(3),t=new Array(3),s=new J,i=new J,a=new U,o=new U,r=new U,c=new U,p=new U,u=new W,f=new W,l=new W,y=new U;function m(T,b,d){const h=T.points;let A=0,x=-1;for(let w=0;w<3;w++){const{start:g,end:_}=u;g.copy(h[w]),_.copy(h[(w+1)%3]),u.delta(o);const B=Ot(b.distanceToPoint(g));if(Ot(b.normal.dot(o))&&B){d.copy(u),A=2;break}const M=b.intersectLine(u,y);if(!M&&B&&y.copy(g),(M||B)&&!Ot(y.distanceTo(_))){if(A<=1)(A===1?d.start:d.end).copy(y),B&&(x=A);else if(A>=2){(x===1?d.start:d.end).copy(y),A=2;break}if(A++,A===2&&x===-1)break}}return A}return function(b,d=null,h=!1){this.needsUpdate&&this.update(),b.isExtendedTriangle?b.needsUpdate&&b.update():(e.copy(b),e.update(),b=e);const A=this.plane,x=b.plane;if(Math.abs(A.normal.dot(x.normal))>1-1e-10){const w=this.satBounds,g=this.satAxes;t[0]=b.a,t[1]=b.b,t[2]=b.c;for(let M=0;M<4;M++){const S=w[M],C=g[M];if(s.setFromPoints(C,t),S.isSeparated(s))return!1}const _=b.satBounds,B=b.satAxes;n[0]=this.a,n[1]=this.b,n[2]=this.c;for(let M=0;M<4;M++){const S=_[M],C=B[M];if(s.setFromPoints(C,n),S.isSeparated(s))return!1}for(let M=0;M<4;M++){const S=g[M];for(let C=0;C<4;C++){const P=B[C];if(a.crossVectors(S,P),s.setFromPoints(a,n),i.setFromPoints(a,t),s.isSeparated(i))return!1}}return d&&(h||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),d.start.set(0,0,0),d.end.set(0,0,0)),!0}else{const w=m(this,x,f);if(w===1&&b.containsPoint(f.end))return d&&(d.start.copy(f.end),d.end.copy(f.end)),!0;if(w!==2)return!1;const g=m(b,A,l);if(g===1&&this.containsPoint(l.end))return d&&(d.start.copy(l.end),d.end.copy(l.end)),!0;if(g!==2)return!1;if(f.delta(r),l.delta(c),r.dot(c)<0){let v=l.start;l.start=l.end,l.end=v}const _=f.start.dot(r),B=f.end.dot(r),M=l.start.dot(r),S=l.end.dot(r),C=B<M,P=_<S;return _!==S&&M!==B&&C===P?!1:(d&&(p.subVectors(f.start,l.start),p.dot(r)>0?d.start.copy(f.start):d.start.copy(l.start),p.subVectors(f.end,l.end),p.dot(r)<0?d.end.copy(f.end):d.end.copy(l.end)),!0)}}}();j.prototype.distanceToPoint=function(){const e=new U;return function(t){return this.closestPointToPoint(t,e),t.distanceTo(e)}}();j.prototype.distanceToTriangle=function(){const e=new U,n=new U,t=["a","b","c"],s=new W,i=new W;return function(o,r=null,c=null){const p=r||c?s:null;if(this.intersectsTriangle(o,p))return(r||c)&&(r&&p.getCenter(r),c&&p.getCenter(c)),0;let u=1/0;for(let f=0;f<3;f++){let l;const y=t[f],m=o[y];this.closestPointToPoint(m,e),l=m.distanceToSquared(e),l<u&&(u=l,r&&r.copy(e),c&&c.copy(m));const T=this[y];o.closestPointToPoint(T,e),l=T.distanceToSquared(e),l<u&&(u=l,r&&r.copy(T),c&&c.copy(e))}for(let f=0;f<3;f++){const l=t[f],y=t[(f+1)%3];s.set(this[l],this[y]);for(let m=0;m<3;m++){const T=t[m],b=t[(m+1)%3];i.set(o[T],o[b]),An(s,i,e,n);const d=e.distanceToSquared(n);d<u&&(u=d,r&&r.copy(e),c&&c.copy(n))}}return Math.sqrt(u)}}();class V{constructor(n,t,s){this.isOrientedBox=!0,this.min=new U,this.max=new U,this.matrix=new K,this.invMatrix=new K,this.points=new Array(8).fill().map(()=>new U),this.satAxes=new Array(3).fill().map(()=>new U),this.satBounds=new Array(3).fill().map(()=>new J),this.alignedSatBounds=new Array(3).fill().map(()=>new J),this.needsUpdate=!1,n&&this.min.copy(n),t&&this.max.copy(t),s&&this.matrix.copy(s)}set(n,t,s){this.min.copy(n),this.max.copy(t),this.matrix.copy(s),this.needsUpdate=!0}copy(n){this.min.copy(n.min),this.max.copy(n.max),this.matrix.copy(n.matrix),this.needsUpdate=!0}}V.prototype.update=function(){return function(){const n=this.matrix,t=this.min,s=this.max,i=this.points;for(let p=0;p<=1;p++)for(let u=0;u<=1;u++)for(let f=0;f<=1;f++){const l=1*p|2*u|4*f,y=i[l];y.x=p?s.x:t.x,y.y=u?s.y:t.y,y.z=f?s.z:t.z,y.applyMatrix4(n)}const a=this.satBounds,o=this.satAxes,r=i[0];for(let p=0;p<3;p++){const u=o[p],f=a[p],l=1<<p,y=i[l];u.subVectors(r,y),f.setFromPoints(u,i)}const c=this.alignedSatBounds;c[0].setFromPointsField(i,"x"),c[1].setFromPointsField(i,"y"),c[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();V.prototype.intersectsBox=function(){const e=new J;return function(t){this.needsUpdate&&this.update();const s=t.min,i=t.max,a=this.satBounds,o=this.satAxes,r=this.alignedSatBounds;if(e.min=s.x,e.max=i.x,r[0].isSeparated(e)||(e.min=s.y,e.max=i.y,r[1].isSeparated(e))||(e.min=s.z,e.max=i.z,r[2].isSeparated(e)))return!1;for(let c=0;c<3;c++){const p=o[c],u=a[c];if(e.setFromBox(p,t),u.isSeparated(e))return!1}return!0}}();V.prototype.intersectsTriangle=function(){const e=new j,n=new Array(3),t=new J,s=new J,i=new U;return function(o){this.needsUpdate&&this.update(),o.isExtendedTriangle?o.needsUpdate&&o.update():(e.copy(o),e.update(),o=e);const r=this.satBounds,c=this.satAxes;n[0]=o.a,n[1]=o.b,n[2]=o.c;for(let l=0;l<3;l++){const y=r[l],m=c[l];if(t.setFromPoints(m,n),y.isSeparated(t))return!1}const p=o.satBounds,u=o.satAxes,f=this.points;for(let l=0;l<3;l++){const y=p[l],m=u[l];if(t.setFromPoints(m,f),y.isSeparated(t))return!1}for(let l=0;l<3;l++){const y=c[l];for(let m=0;m<4;m++){const T=u[m];if(i.crossVectors(y,T),t.setFromPoints(i,n),s.setFromPoints(i,f),t.isSeparated(s))return!1}}return!0}}();V.prototype.closestPointToPoint=function(){return function(n,t){return this.needsUpdate&&this.update(),t.copy(n).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),t}}();V.prototype.distanceToPoint=function(){const e=new U;return function(t){return this.closestPointToPoint(t,e),t.distanceTo(e)}}();V.prototype.distanceToBox=function(){const e=["x","y","z"],n=new Array(12).fill().map(()=>new W),t=new Array(12).fill().map(()=>new W),s=new U,i=new U;return function(o,r=0,c=null,p=null){if(this.needsUpdate&&this.update(),this.intersectsBox(o))return(c||p)&&(o.getCenter(i),this.closestPointToPoint(i,s),o.closestPointToPoint(s,i),c&&c.copy(s),p&&p.copy(i)),0;const u=r*r,f=o.min,l=o.max,y=this.points;let m=1/0;for(let b=0;b<8;b++){const d=y[b];i.copy(d).clamp(f,l);const h=d.distanceToSquared(i);if(h<m&&(m=h,c&&c.copy(d),p&&p.copy(i),h<u))return Math.sqrt(h)}let T=0;for(let b=0;b<3;b++)for(let d=0;d<=1;d++)for(let h=0;h<=1;h++){const A=(b+1)%3,x=(b+2)%3,w=d<<A|h<<x,g=1<<b|d<<A|h<<x,_=y[w],B=y[g];n[T].set(_,B);const S=e[b],C=e[A],P=e[x],v=t[T],L=v.start,F=v.end;L[S]=f[S],L[C]=d?f[C]:l[C],L[P]=h?f[P]:l[C],F[S]=l[S],F[C]=d?f[C]:l[C],F[P]=h?f[P]:l[C],T++}for(let b=0;b<=1;b++)for(let d=0;d<=1;d++)for(let h=0;h<=1;h++){i.x=b?l.x:f.x,i.y=d?l.y:f.y,i.z=h?l.z:f.z,this.closestPointToPoint(i,s);const A=i.distanceToSquared(s);if(A<m&&(m=A,c&&c.copy(s),p&&p.copy(i),A<u))return Math.sqrt(A)}for(let b=0;b<12;b++){const d=n[b];for(let h=0;h<12;h++){const A=t[h];An(d,A,s,i);const x=s.distanceToSquared(i);if(x<m&&(m=x,c&&c.copy(s),p&&p.copy(i),x<u))return Math.sqrt(x)}}return Math.sqrt(m)}}();class bn{constructor(n){this._getNewPrimitive=n,this._primitives=[]}getPrimitive(){const n=this._primitives;return n.length===0?this._getNewPrimitive():n.pop()}releasePrimitive(n){this._primitives.push(n)}}class es extends bn{constructor(){super(()=>new j)}}const $=new es;function R(e,n){return n[e+15]===65535}function N(e,n){return n[e+6]}function q(e,n){return n[e+14]}function k(e){return e+8}function H(e,n){return n[e+6]}function se(e,n){return n[e+7]}class ss{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const n=[];let t=null;this.setBuffer=s=>{t&&n.push(t),t=s,this.float32Array=new Float32Array(s),this.uint16Array=new Uint16Array(s),this.uint32Array=new Uint32Array(s)},this.clearBuffer=()=>{t=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,n.length!==0&&this.setBuffer(n.pop())}}}const D=new ss;let G,ft;const nt=[],Lt=new bn(()=>new Y);function is(e,n,t,s,i,a){G=Lt.getPrimitive(),ft=Lt.getPrimitive(),nt.push(G,ft),D.setBuffer(e._roots[n]);const o=ln(0,e.geometry,t,s,i,a);D.clearBuffer(),Lt.releasePrimitive(G),Lt.releasePrimitive(ft),nt.pop(),nt.pop();const r=nt.length;return r>0&&(ft=nt[r-1],G=nt[r-2]),o}function ln(e,n,t,s,i=null,a=0,o=0){const{float32Array:r,uint16Array:c,uint32Array:p}=D;let u=e*2;if(R(u,c)){const l=N(e,p),y=q(u,c);return E(e,r,G),s(l,y,!1,o,a+e,G)}else{let S=function(P){const{uint16Array:v,uint32Array:L}=D;let F=P*2;for(;!R(F,v);)P=k(P),F=P*2;return N(P,L)},C=function(P){const{uint16Array:v,uint32Array:L}=D;let F=P*2;for(;!R(F,v);)P=H(P,L),F=P*2;return N(P,L)+q(F,v)};const l=k(e),y=H(e,p);let m=l,T=y,b,d,h,A;if(i&&(h=G,A=ft,E(m,r,h),E(T,r,A),b=i(h),d=i(A),d<b)){m=y,T=l;const P=b;b=d,d=P,h=A}h||(h=G,E(m,r,h));const x=R(m*2,c),w=t(h,x,b,o+1,a+m);let g;if(w===Fn){const P=S(m),L=C(m)-P;g=s(P,L,!0,o+1,a+m,h)}else g=w&&ln(m,n,t,s,i,a,o+1);if(g)return!0;A=ft,E(T,r,A);const _=R(T*2,c),B=t(A,_,d,o+1,a+T);let M;if(B===Fn){const P=S(T),L=C(T)-P;M=s(P,L,!0,o+1,a+T,A)}else M=B&&ln(T,n,t,s,i,a,o+1);return!!M}}const wt=new U,Gt=new U;function os(e,n,t={},s=0,i=1/0){const a=s*s,o=i*i;let r=1/0,c=null;if(e.shapecast({boundsTraverseOrder:u=>(wt.copy(n).clamp(u.min,u.max),wt.distanceToSquared(n)),intersectsBounds:(u,f,l)=>l<r&&l<o,intersectsTriangle:(u,f)=>{u.closestPointToPoint(n,wt);const l=n.distanceToSquared(wt);return l<r&&(Gt.copy(wt),r=l,c=f),l<a}}),r===1/0)return null;const p=Math.sqrt(r);return t.point?t.point.copy(Gt):t.point=Gt.clone(),t.distance=p,t.faceIndex=c,t}const et=new U,st=new U,it=new U,Ft=new pt,Dt=new pt,Et=new pt,Vn=new U,Rn=new U,Nn=new U,It=new U;function rs(e,n,t,s,i,a){let o;return a===fe?o=e.intersectTriangle(s,t,n,!0,i):o=e.intersectTriangle(n,t,s,a!==Qn,i),o===null?null:{distance:e.origin.distanceTo(i),point:i.clone()}}function cs(e,n,t,s,i,a,o,r,c){et.fromBufferAttribute(n,a),st.fromBufferAttribute(n,o),it.fromBufferAttribute(n,r);const p=rs(e,et,st,it,It,c);if(p){s&&(Ft.fromBufferAttribute(s,a),Dt.fromBufferAttribute(s,o),Et.fromBufferAttribute(s,r),p.uv=Bt.getInterpolation(It,et,st,it,Ft,Dt,Et,new pt)),i&&(Ft.fromBufferAttribute(i,a),Dt.fromBufferAttribute(i,o),Et.fromBufferAttribute(i,r),p.uv1=Bt.getInterpolation(It,et,st,it,Ft,Dt,Et,new pt)),t&&(Vn.fromBufferAttribute(t,a),Rn.fromBufferAttribute(t,o),Nn.fromBufferAttribute(t,r),p.normal=Bt.getInterpolation(It,et,st,it,Vn,Rn,Nn,new U),p.normal.dot(e.direction)>0&&p.normal.multiplyScalar(-1));const u={a,b:o,c:r,normal:new U,materialIndex:0};Bt.getNormal(et,st,it,u.normal),p.face=u,p.faceIndex=a}return p}function Zt(e,n,t,s,i){const a=s*3;let o=a+0,r=a+1,c=a+2;const p=e.index;e.index&&(o=p.getX(o),r=p.getX(r),c=p.getX(c));const{position:u,normal:f,uv:l,uv1:y}=e.attributes,m=cs(t,u,f,l,y,o,r,c,n);return m?(m.faceIndex=s,i&&i.push(m),m):null}function z(e,n,t,s){const i=e.a,a=e.b,o=e.c;let r=n,c=n+1,p=n+2;t&&(r=t.getX(r),c=t.getX(c),p=t.getX(p)),i.x=s.getX(r),i.y=s.getY(r),i.z=s.getZ(r),a.x=s.getX(c),a.y=s.getY(c),a.z=s.getZ(c),o.x=s.getX(p),o.y=s.getY(p),o.z=s.getZ(p)}function as(e,n,t,s,i,a){const{geometry:o,_indirectBuffer:r}=e;for(let c=s,p=s+i;c<p;c++)Zt(o,n,t,c,a)}function ls(e,n,t,s,i){const{geometry:a,_indirectBuffer:o}=e;let r=1/0,c=null;for(let p=s,u=s+i;p<u;p++){let f;f=Zt(a,n,t,p),f&&f.distance<r&&(c=f,r=f.distance)}return c}function us(e,n,t,s,i,a,o){const{geometry:r}=t,{index:c}=r,p=r.attributes.position;for(let u=e,f=n+e;u<f;u++){let l;if(l=u,z(o,l*3,c,p),o.needsUpdate=!0,s(o,l,i,a))return!0}return!1}function fs(e,n=null){n&&Array.isArray(n)&&(n=new Set(n));const t=e.geometry,s=t.index?t.index.array:null,i=t.attributes.position;let a,o,r,c,p=0;const u=e._roots;for(let l=0,y=u.length;l<y;l++)a=u[l],o=new Uint32Array(a),r=new Uint16Array(a),c=new Float32Array(a),f(0,p),p+=a.byteLength;function f(l,y,m=!1){const T=l*2;if(r[T+15]===Yt){const d=o[l+6],h=r[T+14];let A=1/0,x=1/0,w=1/0,g=-1/0,_=-1/0,B=-1/0;for(let M=3*d,S=3*(d+h);M<S;M++){let C=s[M];const P=i.getX(C),v=i.getY(C),L=i.getZ(C);P<A&&(A=P),P>g&&(g=P),v<x&&(x=v),v>_&&(_=v),L<w&&(w=L),L>B&&(B=L)}return c[l+0]!==A||c[l+1]!==x||c[l+2]!==w||c[l+3]!==g||c[l+4]!==_||c[l+5]!==B?(c[l+0]=A,c[l+1]=x,c[l+2]=w,c[l+3]=g,c[l+4]=_,c[l+5]=B,!0):!1}else{const d=l+8,h=o[l+6],A=d+y,x=h+y;let w=m,g=!1,_=!1;n?w||(g=n.has(A),_=n.has(x),w=!g&&!_):(g=!0,_=!0);const B=w||g,M=w||_;let S=!1;B&&(S=f(d,y,w));let C=!1;M&&(C=f(h,y,w));const P=S||C;if(P)for(let v=0;v<3;v++){const L=d+v,F=h+v,I=c[L],dt=c[L+3],mt=c[F],ht=c[F+3];c[l+v]=I<mt?I:mt,c[l+v+3]=dt>ht?dt:ht}return P}}}const $n=new Y;function tt(e,n,t,s){return E(e,n,$n),t.intersectBox($n,s)}function ps(e,n,t,s,i,a){const{geometry:o,_indirectBuffer:r}=e;for(let c=s,p=s+i;c<p;c++){let u=r?r[c]:c;Zt(o,n,t,u,a)}}function ys(e,n,t,s,i){const{geometry:a,_indirectBuffer:o}=e;let r=1/0,c=null;for(let p=s,u=s+i;p<u;p++){let f;f=Zt(a,n,t,o?o[p]:p),f&&f.distance<r&&(c=f,r=f.distance)}return c}function ds(e,n,t,s,i,a,o){const{geometry:r}=t,{index:c}=r,p=r.attributes.position;for(let u=e,f=n+e;u<f;u++){let l;if(l=t.resolveTriangleIndex(u),z(o,l*3,c,p),o.needsUpdate=!0,s(o,l,i,a))return!0}return!1}const qn=new U;function ms(e,n,t,s,i){D.setBuffer(e._roots[n]),un(0,e,t,s,i),D.clearBuffer()}function un(e,n,t,s,i){const{float32Array:a,uint16Array:o,uint32Array:r}=D,c=e*2;if(R(c,o)){const u=N(e,r),f=q(c,o);as(n,t,s,u,f,i)}else{const u=k(e);tt(u,a,s,qn)&&un(u,n,t,s,i);const f=H(e,r);tt(f,a,s,qn)&&un(f,n,t,s,i)}}const kn=new U,hs=["x","y","z"];function xs(e,n,t,s){D.setBuffer(e._roots[n]);const i=fn(0,e,t,s);return D.clearBuffer(),i}function fn(e,n,t,s){const{float32Array:i,uint16Array:a,uint32Array:o}=D;let r=e*2;if(R(r,a)){const p=N(e,o),u=q(r,a);return ls(n,t,s,p,u)}else{const p=se(e,o),u=hs[p],l=s.direction[u]>=0;let y,m;l?(y=k(e),m=H(e,o)):(y=H(e,o),m=k(e));const b=tt(y,i,s,kn)?fn(y,n,t,s):null;if(b){const A=b.point[u];if(l?A<=i[m+p]:A>=i[m+p+3])return b}const h=tt(m,i,s,kn)?fn(m,n,t,s):null;return b&&h?b.distance<=h.distance?b:h:b||h||null}}const zt=new Y,ot=new j,rt=new j,At=new K,Hn=new V,Vt=new V;function ws(e,n,t,s){D.setBuffer(e._roots[n]);const i=pn(0,e,t,s);return D.clearBuffer(),i}function pn(e,n,t,s,i=null){const{float32Array:a,uint16Array:o,uint32Array:r}=D;let c=e*2;if(i===null&&(t.boundingBox||t.computeBoundingBox(),Hn.set(t.boundingBox.min,t.boundingBox.max,s),i=Hn),R(c,o)){const u=n.geometry,f=u.index,l=u.attributes.position,y=t.index,m=t.attributes.position,T=N(e,r),b=q(c,o);if(At.copy(s).invert(),t.boundsTree)return E(e,a,Vt),Vt.matrix.copy(At),Vt.needsUpdate=!0,t.boundsTree.shapecast({intersectsBounds:h=>Vt.intersectsBox(h),intersectsTriangle:h=>{h.a.applyMatrix4(s),h.b.applyMatrix4(s),h.c.applyMatrix4(s),h.needsUpdate=!0;for(let A=T*3,x=(b+T)*3;A<x;A+=3)if(z(rt,A,f,l),rt.needsUpdate=!0,h.intersectsTriangle(rt))return!0;return!1}});for(let d=T*3,h=(b+T)*3;d<h;d+=3){z(ot,d,f,l),ot.a.applyMatrix4(At),ot.b.applyMatrix4(At),ot.c.applyMatrix4(At),ot.needsUpdate=!0;for(let A=0,x=y.count;A<x;A+=3)if(z(rt,A,y,m),rt.needsUpdate=!0,ot.intersectsTriangle(rt))return!0}}else{const u=e+8,f=r[e+6];return E(u,a,zt),!!(i.intersectsBox(zt)&&pn(u,n,t,s,i)||(E(f,a,zt),i.intersectsBox(zt)&&pn(f,n,t,s,i)))}}const Rt=new K,tn=new V,bt=new V,As=new U,bs=new U,gs=new U,Ts=new U;function Bs(e,n,t,s={},i={},a=0,o=1/0){n.boundingBox||n.computeBoundingBox(),tn.set(n.boundingBox.min,n.boundingBox.max,t),tn.needsUpdate=!0;const r=e.geometry,c=r.attributes.position,p=r.index,u=n.attributes.position,f=n.index,l=$.getPrimitive(),y=$.getPrimitive();let m=As,T=bs,b=null,d=null;i&&(b=gs,d=Ts);let h=1/0,A=null,x=null;return Rt.copy(t).invert(),bt.matrix.copy(Rt),e.shapecast({boundsTraverseOrder:w=>tn.distanceToBox(w),intersectsBounds:(w,g,_)=>_<h&&_<o?(g&&(bt.min.copy(w.min),bt.max.copy(w.max),bt.needsUpdate=!0),!0):!1,intersectsRange:(w,g)=>{if(n.boundsTree)return n.boundsTree.shapecast({boundsTraverseOrder:B=>bt.distanceToBox(B),intersectsBounds:(B,M,S)=>S<h&&S<o,intersectsRange:(B,M)=>{for(let S=B,C=B+M;S<C;S++){z(y,3*S,f,u),y.a.applyMatrix4(t),y.b.applyMatrix4(t),y.c.applyMatrix4(t),y.needsUpdate=!0;for(let P=w,v=w+g;P<v;P++){z(l,3*P,p,c),l.needsUpdate=!0;const L=l.distanceToTriangle(y,m,b);if(L<h&&(T.copy(m),d&&d.copy(b),h=L,A=P,x=S),L<a)return!0}}}});{const _=yt(n);for(let B=0,M=_;B<M;B++){z(y,3*B,f,u),y.a.applyMatrix4(t),y.b.applyMatrix4(t),y.c.applyMatrix4(t),y.needsUpdate=!0;for(let S=w,C=w+g;S<C;S++){z(l,3*S,p,c),l.needsUpdate=!0;const P=l.distanceToTriangle(y,m,b);if(P<h&&(T.copy(m),d&&d.copy(b),h=P,A=S,x=B),P<a)return!0}}}}}),$.releasePrimitive(l),$.releasePrimitive(y),h===1/0?null:(s.point?s.point.copy(T):s.point=T.clone(),s.distance=h,s.faceIndex=A,i&&(i.point?i.point.copy(d):i.point=d.clone(),i.point.applyMatrix4(Rt),T.applyMatrix4(Rt),i.distance=T.sub(i.point).length(),i.faceIndex=x),s)}function Ps(e,n=null){n&&Array.isArray(n)&&(n=new Set(n));const t=e.geometry,s=t.index?t.index.array:null,i=t.attributes.position;let a,o,r,c,p=0;const u=e._roots;for(let l=0,y=u.length;l<y;l++)a=u[l],o=new Uint32Array(a),r=new Uint16Array(a),c=new Float32Array(a),f(0,p),p+=a.byteLength;function f(l,y,m=!1){const T=l*2;if(r[T+15]===Yt){const d=o[l+6],h=r[T+14];let A=1/0,x=1/0,w=1/0,g=-1/0,_=-1/0,B=-1/0;for(let M=d,S=d+h;M<S;M++){const C=3*e.resolveTriangleIndex(M);for(let P=0;P<3;P++){let v=C+P;v=s?s[v]:v;const L=i.getX(v),F=i.getY(v),I=i.getZ(v);L<A&&(A=L),L>g&&(g=L),F<x&&(x=F),F>_&&(_=F),I<w&&(w=I),I>B&&(B=I)}}return c[l+0]!==A||c[l+1]!==x||c[l+2]!==w||c[l+3]!==g||c[l+4]!==_||c[l+5]!==B?(c[l+0]=A,c[l+1]=x,c[l+2]=w,c[l+3]=g,c[l+4]=_,c[l+5]=B,!0):!1}else{const d=l+8,h=o[l+6],A=d+y,x=h+y;let w=m,g=!1,_=!1;n?w||(g=n.has(A),_=n.has(x),w=!g&&!_):(g=!0,_=!0);const B=w||g,M=w||_;let S=!1;B&&(S=f(d,y,w));let C=!1;M&&(C=f(h,y,w));const P=S||C;if(P)for(let v=0;v<3;v++){const L=d+v,F=h+v,I=c[L],dt=c[L+3],mt=c[F],ht=c[F+3];c[l+v]=I<mt?I:mt,c[l+v+3]=dt>ht?dt:ht}return P}}}const Xn=new U;function _s(e,n,t,s,i){D.setBuffer(e._roots[n]),yn(0,e,t,s,i),D.clearBuffer()}function yn(e,n,t,s,i){const{float32Array:a,uint16Array:o,uint32Array:r}=D,c=e*2;if(R(c,o)){const u=N(e,r),f=q(c,o);ps(n,t,s,u,f,i)}else{const u=k(e);tt(u,a,s,Xn)&&yn(u,n,t,s,i);const f=H(e,r);tt(f,a,s,Xn)&&yn(f,n,t,s,i)}}const jn=new U,Ms=["x","y","z"];function Ss(e,n,t,s){D.setBuffer(e._roots[n]);const i=dn(0,e,t,s);return D.clearBuffer(),i}function dn(e,n,t,s){const{float32Array:i,uint16Array:a,uint32Array:o}=D;let r=e*2;if(R(r,a)){const p=N(e,o),u=q(r,a);return ys(n,t,s,p,u)}else{const p=se(e,o),u=Ms[p],l=s.direction[u]>=0;let y,m;l?(y=k(e),m=H(e,o)):(y=H(e,o),m=k(e));const b=tt(y,i,s,jn)?dn(y,n,t,s):null;if(b){const A=b.point[u];if(l?A<=i[m+p]:A>=i[m+p+3])return b}const h=tt(m,i,s,jn)?dn(m,n,t,s):null;return b&&h?b.distance<=h.distance?b:h:b||h||null}}const Nt=new Y,ct=new j,at=new j,gt=new K,Yn=new V,$t=new V;function vs(e,n,t,s){D.setBuffer(e._roots[n]);const i=mn(0,e,t,s);return D.clearBuffer(),i}function mn(e,n,t,s,i=null){const{float32Array:a,uint16Array:o,uint32Array:r}=D;let c=e*2;if(i===null&&(t.boundingBox||t.computeBoundingBox(),Yn.set(t.boundingBox.min,t.boundingBox.max,s),i=Yn),R(c,o)){const u=n.geometry,f=u.index,l=u.attributes.position,y=t.index,m=t.attributes.position,T=N(e,r),b=q(c,o);if(gt.copy(s).invert(),t.boundsTree)return E(e,a,$t),$t.matrix.copy(gt),$t.needsUpdate=!0,t.boundsTree.shapecast({intersectsBounds:h=>$t.intersectsBox(h),intersectsTriangle:h=>{h.a.applyMatrix4(s),h.b.applyMatrix4(s),h.c.applyMatrix4(s),h.needsUpdate=!0;for(let A=T,x=b+T;A<x;A++)if(z(at,3*n.resolveTriangleIndex(A),f,l),at.needsUpdate=!0,h.intersectsTriangle(at))return!0;return!1}});for(let d=T,h=b+T;d<h;d++){const A=n.resolveTriangleIndex(d);z(ct,3*A,f,l),ct.a.applyMatrix4(gt),ct.b.applyMatrix4(gt),ct.c.applyMatrix4(gt),ct.needsUpdate=!0;for(let x=0,w=y.count;x<w;x+=3)if(z(at,x,y,m),at.needsUpdate=!0,ct.intersectsTriangle(at))return!0}}else{const u=e+8,f=r[e+6];return E(u,a,Nt),!!(i.intersectsBox(Nt)&&mn(u,n,t,s,i)||(E(f,a,Nt),i.intersectsBox(Nt)&&mn(f,n,t,s,i)))}}const qt=new K,nn=new V,Tt=new V,Cs=new U,Us=new U,Ls=new U,Fs=new U;function Ds(e,n,t,s={},i={},a=0,o=1/0){n.boundingBox||n.computeBoundingBox(),nn.set(n.boundingBox.min,n.boundingBox.max,t),nn.needsUpdate=!0;const r=e.geometry,c=r.attributes.position,p=r.index,u=n.attributes.position,f=n.index,l=$.getPrimitive(),y=$.getPrimitive();let m=Cs,T=Us,b=null,d=null;i&&(b=Ls,d=Fs);let h=1/0,A=null,x=null;return qt.copy(t).invert(),Tt.matrix.copy(qt),e.shapecast({boundsTraverseOrder:w=>nn.distanceToBox(w),intersectsBounds:(w,g,_)=>_<h&&_<o?(g&&(Tt.min.copy(w.min),Tt.max.copy(w.max),Tt.needsUpdate=!0),!0):!1,intersectsRange:(w,g)=>{if(n.boundsTree){const _=n.boundsTree;return _.shapecast({boundsTraverseOrder:B=>Tt.distanceToBox(B),intersectsBounds:(B,M,S)=>S<h&&S<o,intersectsRange:(B,M)=>{for(let S=B,C=B+M;S<C;S++){const P=_.resolveTriangleIndex(S);z(y,3*P,f,u),y.a.applyMatrix4(t),y.b.applyMatrix4(t),y.c.applyMatrix4(t),y.needsUpdate=!0;for(let v=w,L=w+g;v<L;v++){const F=e.resolveTriangleIndex(v);z(l,3*F,p,c),l.needsUpdate=!0;const I=l.distanceToTriangle(y,m,b);if(I<h&&(T.copy(m),d&&d.copy(b),h=I,A=v,x=S),I<a)return!0}}}})}else{const _=yt(n);for(let B=0,M=_;B<M;B++){z(y,3*B,f,u),y.a.applyMatrix4(t),y.b.applyMatrix4(t),y.c.applyMatrix4(t),y.needsUpdate=!0;for(let S=w,C=w+g;S<C;S++){const P=e.resolveTriangleIndex(S);z(l,3*P,p,c),l.needsUpdate=!0;const v=l.distanceToTriangle(y,m,b);if(v<h&&(T.copy(m),d&&d.copy(b),h=v,A=S,x=B),v<a)return!0}}}}}),$.releasePrimitive(l),$.releasePrimitive(y),h===1/0?null:(s.point?s.point.copy(T):s.point=T.clone(),s.distance=h,s.faceIndex=A,i&&(i.point?i.point.copy(d):i.point=d.clone(),i.point.applyMatrix4(qt),T.applyMatrix4(qt),i.distance=T.sub(i.point).length(),i.faceIndex=x),s)}function Es(){return typeof SharedArrayBuffer<"u"}const Pt=new D.constructor,jt=new D.constructor,O=new bn(()=>new Y),lt=new Y,ut=new Y,en=new Y,sn=new Y;let on=!1;function Is(e,n,t,s){if(on)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");on=!0;const i=e._roots,a=n._roots;let o,r=0,c=0;const p=new K().copy(t).invert();for(let u=0,f=i.length;u<f;u++){Pt.setBuffer(i[u]),c=0;const l=O.getPrimitive();E(0,Pt.float32Array,l),l.applyMatrix4(p);for(let y=0,m=a.length;y<m&&(jt.setBuffer(a[u]),o=X(0,0,t,p,s,r,c,0,0,l),jt.clearBuffer(),c+=a[y].length,!o);y++);if(O.releasePrimitive(l),Pt.clearBuffer(),r+=i[u].length,o)break}return on=!1,o}function X(e,n,t,s,i,a=0,o=0,r=0,c=0,p=null,u=!1){let f,l;u?(f=jt,l=Pt):(f=Pt,l=jt);const y=f.float32Array,m=f.uint32Array,T=f.uint16Array,b=l.float32Array,d=l.uint32Array,h=l.uint16Array,A=e*2,x=n*2,w=R(A,T),g=R(x,h);let _=!1;if(g&&w)u?_=i(N(n,d),q(n*2,h),N(e,m),q(e*2,T),c,o+n,r,a+e):_=i(N(e,m),q(e*2,T),N(n,d),q(n*2,h),r,a+e,c,o+n);else if(g){const B=O.getPrimitive();E(n,b,B),B.applyMatrix4(t);const M=k(e),S=H(e,m);E(M,y,lt),E(S,y,ut);const C=B.intersectsBox(lt),P=B.intersectsBox(ut);_=C&&X(n,M,s,t,i,o,a,c,r+1,B,!u)||P&&X(n,S,s,t,i,o,a,c,r+1,B,!u),O.releasePrimitive(B)}else{const B=k(n),M=H(n,d);E(B,b,en),E(M,b,sn);const S=p.intersectsBox(en),C=p.intersectsBox(sn);if(S&&C)_=X(e,B,t,s,i,a,o,r,c+1,p,u)||X(e,M,t,s,i,a,o,r,c+1,p,u);else if(S)if(w)_=X(e,B,t,s,i,a,o,r,c+1,p,u);else{const P=O.getPrimitive();P.copy(en).applyMatrix4(t);const v=k(e),L=H(e,m);E(v,y,lt),E(L,y,ut);const F=P.intersectsBox(lt),I=P.intersectsBox(ut);_=F&&X(B,v,s,t,i,o,a,c,r+1,P,!u)||I&&X(B,L,s,t,i,o,a,c,r+1,P,!u),O.releasePrimitive(P)}else if(C)if(w)_=X(e,M,t,s,i,a,o,r,c+1,p,u);else{const P=O.getPrimitive();P.copy(sn).applyMatrix4(t);const v=k(e),L=H(e,m);E(v,y,lt),E(L,y,ut);const F=P.intersectsBox(lt),I=P.intersectsBox(ut);_=F&&X(M,v,s,t,i,o,a,c,r+1,P,!u)||I&&X(M,L,s,t,i,o,a,c,r+1,P,!u),O.releasePrimitive(P)}}return _}const kt=new V,Zn=new Y;class gn{static serialize(n,t={}){t=Mt({cloneBuffers:!0},t);const s=n.geometry,i=n._roots,a=n._indirectBuffer,o=s.getIndex();let r;return t.cloneBuffers?r={roots:i.map(c=>c.slice()),index:o.array.slice(),indirectBuffer:a?a.slice():null}:r={roots:i,index:o.array,indirectBuffer:a},r}static deserialize(n,t,s={}){s=Mt({setIndex:!0,indirect:!!n.indirectBuffer},s);const{index:i,roots:a,indirectBuffer:o}=n,r=new gn(t,Pn(Mt({},s),{[Jt]:!0}));if(r._roots=a,r._indirectBuffer=o||null,s.setIndex){const c=t.getIndex();if(c===null){const p=new hn(n.index,1,!1);t.setIndex(p)}else c.array!==i&&(c.array.set(i),c.needsUpdate=!0)}return r}get indirect(){return!!this._indirectBuffer}constructor(n,t={}){if(n.isBufferGeometry){if(n.index&&n.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t=Object.assign({strategy:te,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,[Jt]:!1},t),t.useSharedArrayBuffer&&!Es())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=n,this._roots=null,this._indirectBuffer=null,t[Jt]||(Oe(this,t),!n.boundingBox&&t.setBoundingBox&&(n.boundingBox=this.getBoundingBox(new Y)));const{_indirectBuffer:s}=this;this.resolveTriangleIndex=t.indirect?i=>s[i]:i=>i}refit(n=null){return(this.indirect?Ps:fs)(this,n)}traverse(n,t=0){const s=this._roots[t],i=new Uint32Array(s),a=new Uint16Array(s);o(0);function o(r,c=0){const p=r*2,u=a[p+15]===Yt;if(u){const f=i[r+6],l=a[p+14];n(c,u,new Float32Array(s,r*4,6),f,l)}else{const f=r+Ht/4,l=i[r+6],y=i[r+7];n(c,u,new Float32Array(s,r*4,6),y)||(o(f,c+1),o(l,c+1))}}}raycast(n,t=_n){const s=this._roots,i=this.geometry,a=[],o=t.isMaterial,r=Array.isArray(t),c=i.groups,p=o?t.side:t,u=this.indirect?_s:ms;for(let f=0,l=s.length;f<l;f++){const y=r?t[c[f].materialIndex].side:p,m=a.length;if(u(this,f,y,n,a),r){const T=c[f].materialIndex;for(let b=m,d=a.length;b<d;b++)a[b].face.materialIndex=T}}return a}raycastFirst(n,t=_n){const s=this._roots,i=this.geometry,a=t.isMaterial,o=Array.isArray(t);let r=null;const c=i.groups,p=a?t.side:t,u=this.indirect?Ss:xs;for(let f=0,l=s.length;f<l;f++){const y=o?t[c[f].materialIndex].side:p,m=u(this,f,y,n);m!=null&&(r==null||m.distance<r.distance)&&(r=m,o&&(m.face.materialIndex=c[f].materialIndex))}return r}intersectsGeometry(n,t){let s=!1;const i=this._roots,a=this.indirect?vs:ws;for(let o=0,r=i.length;o<r&&(s=a(this,o,n,t),!s);o++);return s}shapecast(n){const t=$.getPrimitive(),s=this.indirect?ds:us;let{boundsTraverseOrder:i,intersectsBounds:a,intersectsRange:o,intersectsTriangle:r}=n;if(o&&r){const f=o;o=(l,y,m,T,b)=>f(l,y,m,T,b)?!0:s(l,y,this,r,m,T,t)}else o||(r?o=(f,l,y,m)=>s(f,l,this,r,y,m,t):o=(f,l,y)=>y);let c=!1,p=0;const u=this._roots;for(let f=0,l=u.length;f<l;f++){const y=u[f];if(c=is(this,f,a,o,i,p),c)break;p+=y.byteLength}return $.releasePrimitive(t),c}bvhcast(n,t,s){let{intersectsRanges:i,intersectsTriangles:a}=s;const o=$.getPrimitive(),r=this.geometry.index,c=this.geometry.attributes.position,p=this.indirect?m=>{const T=this.resolveTriangleIndex(m);z(o,T*3,r,c)}:m=>{z(o,m*3,r,c)},u=$.getPrimitive(),f=n.geometry.index,l=n.geometry.attributes.position,y=n.indirect?m=>{const T=n.resolveTriangleIndex(m);z(u,T*3,f,l)}:m=>{z(u,m*3,f,l)};if(a){const m=(T,b,d,h,A,x,w,g)=>{for(let _=d,B=d+h;_<B;_++){y(_),u.a.applyMatrix4(t),u.b.applyMatrix4(t),u.c.applyMatrix4(t),u.needsUpdate=!0;for(let M=T,S=T+b;M<S;M++)if(p(M),o.needsUpdate=!0,a(o,u,M,_,A,x,w,g))return!0}return!1};if(i){const T=i;i=function(b,d,h,A,x,w,g,_){return T(b,d,h,A,x,w,g,_)?!0:m(b,d,h,A,x,w,g,_)}}else i=m}return Is(this,n,t,i)}intersectsBox(n,t){return kt.set(n.min,n.max,t),kt.needsUpdate=!0,this.shapecast({intersectsBounds:s=>kt.intersectsBox(s),intersectsTriangle:s=>kt.intersectsTriangle(s)})}intersectsSphere(n){return this.shapecast({intersectsBounds:t=>n.intersectsBox(t),intersectsTriangle:t=>t.intersectsSphere(n)})}closestPointToGeometry(n,t,s={},i={},a=0,o=1/0){return(this.indirect?Ds:Bs)(this,n,t,s,i,a,o)}closestPointToPoint(n,t={},s=0,i=1/0){return os(this,n,t,s,i)}getBoundingBox(n){return n.makeEmpty(),this._roots.forEach(s=>{E(0,new Float32Array(s),Zn),n.union(Zn)}),n}}function Wn(e,n,t){return e===null||(e.point.applyMatrix4(n.matrixWorld),e.distance=e.point.distanceTo(t.ray.origin),e.object=n,e.distance<t.near||e.distance>t.far)?null:e}const rn=new pe,Kn=new K,zs=cn.prototype.raycast;function Vs(e,n){if(this.geometry.boundsTree){if(this.material===void 0)return;Kn.copy(this.matrixWorld).invert(),rn.copy(e.ray).applyMatrix4(Kn);const t=this.geometry.boundsTree;if(e.firstHitOnly===!0){const s=Wn(t.raycastFirst(rn,this.material),this,e);s&&n.push(s)}else{const s=t.raycast(rn,this.material);for(let i=0,a=s.length;i<a;i++){const o=Wn(s[i],this,e);o&&n.push(o)}}}else zs.call(this,e,n)}function Rs(e){return this.boundsTree=new gn(this,e),this.boundsTree}function Ns(){this.boundsTree=null}const ie=ye("buildingsHeatmap",()=>{const e=Xt(!1),n=Xt(0);function t(i){e.value=i}function s(i){n.value=i}return{showDiv:e,temperature:n,setShowDiv:t,setTemperature:s}}),$s=["object","rotation-x"],qs=["object"],ks=On({__name:"buildingsHeatmap",props:{model:{},opacity:{default:1}},setup(e){(()=>{Sn.prototype.computeBoundsTree=Rs,Sn.prototype.disposeBoundsTree=Ns,cn.prototype.raycast=Vs})();const t=e,s=De();Fe(s);const i=new de(s._renderer.canvas);i.needsUpdate=!0;const a=d=>new he({vertexShader:"\n		varying vec2 vUv;\n		void main() {\n			gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n			vUv = uv;\n		}\n		",fragmentShader:"\n		uniform sampler2D heightMap;\n		uniform float uOpacity;\n		varying vec2 vUv;\n		void main() {\n			gl_FragColor = vec4(texture2D(heightMap, vUv.xy).rgb, uOpacity);\n    }\n		",uniforms:{uOpacity:{value:t.opacity},heightMap:{type:"t",value:d}},depthWrite:!0,depthTest:!0,transparent:!0,side:Qn}),o=t.model.city.clone();delete o.geometry.attributes.normal,delete o.geometry.attributes.uv;const r=o.geometry.clone().applyMatrix4(o.matrix),c=t.model.land.clone();delete c.geometry.attributes.normal;const p=c.geometry.clone().applyMatrix4(c.matrix),u=Le([r,p]);u.applyMatrix4(new K().makeRotationX(Math.PI/2)),Ee(u),u.computeBoundsTree();const f=a(i),l=new cn(u,f);me(()=>{t.opacity&&(f.uniforms.uOpacity.value=t.opacity)});const y=ie(),m=d=>{if(d){const h={x:d.uv.x*s._config.width,y:(1-d.uv.y)*s._config.height};console.log("数值：",d),console.log("数值———：",Ln(s,h)),y.setTemperature(Ln(s,h))}},T=d=>{d&&y.$patch({showDiv:!0})},b=d=>{d&&y.setShowDiv(!1)};return(d,h)=>(xn(),wn(Gn,null,[Mn("primitive",{object:_t(l),"rotation-x":-Math.PI/2,onPointerMove:m,onPointerEnter:T,onPointerLeave:b},null,40,$s),Mn("primitive",{object:t.model.model.children[0].clone()},null,8,qs)],64))}});const Hs={__name:"dataDiv",setup(e){const n=ie(),t=Xt({top:0,left:0});function s(i){t.value.left=i.clientX+5+"px",t.value.top=i.clientY-20+"px"}return we(()=>{window.addEventListener("mousemove",s)}),Ae(()=>{window.removeEventListener("mousemove",s)}),(i,a)=>be((xn(),wn("div",{class:"title",style:Be(t.value)},"温度："+Te(_t(n).temperature)+"℃ ",5)),[[ge,_t(n).showDiv]])}},Xs=xe(Hs,[["__scopeId","data-v-fac3e7fd"]]),Os=On({__name:"heatmap2",async setup(e){let n,t;const s=Xt(!1),i=([n,t]=Pe(()=>ve()),n=await n,t(),n);s.value=!0;const a=vn({width:1,color:"#000",opacity:1,show:!0}),o=vn({opacity:.9});return new _e({title:"参数",expanded:!0}).addBinding(o,"opacity",{label:"透明度",min:0,max:1,step:.1}),(c,p)=>(xn(),wn(Gn,null,[St(Se,{showBuildings:!1,autoRotate:!1},{ability:Me(()=>[St(ks,Cn({model:_t(i)},o),null,16,["model"]),St(Ce,Cn(a,{builds:_t(i).city}),null,16,["builds"])]),_:1}),St(Xs)],64))}});export{Os as default};
