var Ce=Object.defineProperty,Te=Object.defineProperties;var De=Object.getOwnPropertyDescriptors;var T=Object.getOwnPropertySymbols;var k=Object.prototype.hasOwnProperty,ee=Object.prototype.propertyIsEnumerable;var B=(o,e,a)=>e in o?Ce(o,e,{enumerable:!0,configurable:!0,writable:!0,value:a}):o[e]=a,u=(o,e)=>{for(var a in e||(e={}))k.call(e,a)&&B(o,a,e[a]);if(T)for(var a of T(e))ee.call(e,a)&&B(o,a,e[a]);return o},D=(o,e)=>Te(o,De(e));var q=(o,e)=>{var a={};for(var t in o)k.call(o,t)&&e.indexOf(t)<0&&(a[t]=o[t]);if(o!=null&&T)for(var t of T(o))e.indexOf(t)<0&&ee.call(o,t)&&(a[t]=o[t]);return a};var G=(o,e,a)=>(B(o,typeof e!="symbol"?e+"":e,a),a);import{b3 as P,az as x,aR as Ne,cC as Oe,cD as Be,bb as xe,aM as qe,cE as Ge,aT as Ae,aH as Ve,bg as Ie,by as Re,bf as Le,c2 as Ee,cF as ae,bt as We,ap as He,aw as he,a0 as ge,cG as Ue,ba as Xe,cH as Je,aF as Qe,bB as A,co as Ye,bq as Ze,ak as ke,a5 as ze,a8 as ea,aD as aa,aE as ta,o as N,c as be,X as O,K as j,a as b,cc as na,E as we,k as ra,a1 as V,a2 as ia,a3 as oa,cB as ca,r as la,D as I,a7 as te,ab as sa,a9 as ma,aa as ua,v as ne,ag as re}from"./vendor.Vvui1c2y1711593224078.js";import{_ as va}from"./reflectorShaderMesh.vue_vue_type_script_setup_true_lang.IKjb28xr1711593224078.js";/* empty css                                                                                 */import{_ as da}from"./randomLoading.vue_vue_type_script_setup_true_lang.v8SScrSh1711593224078.js";import{C as pa,t as ie,a as oe,s as R}from"./vanilla.QJ6vlup71711593224078.js";import{g as fa}from"./_commonjsHelpers.5-cIlDoe1711593224078.js";import"./ReflectorMaterial.oF6f_2_V1711593224078.js";import"./dither.glsl.y2WXw1t-1711593224078.js";import"./OimoPhysicsBuffer.nw1eAwO51711593224078.js";import"./starLoading.K80pfiVM1711593224078.js";import"./bubbleLoading.kssqp2C41711593224078.js";var L,ce;function _a(){if(ce)return L;ce=1,L=o;function o(e){for(var a=!1,t=0,n=0;n<e.length;n++)switch(a=a||e[n].type==="keyword"&&e[n].data==="for",e[n].data){case"(":e[n].depth=a?t++:t;break;case"{":e[n].depth=a?t:t++,a=!1;break;case"}":e[n].depth=--t;break;default:e[n].depth=t}for(var n=0;n<e.length;n++){var i=e[n],r=n+1;if(!(i.type!=="ident"&&i.type!=="keyword")&&(c(),e[r].type==="ident"&&(c(),r++,e[r].data==="("))){for(;e[r]&&e[r].data!==";"&&e[r].data!=="{";)e[r++].depth++;e[r]&&e[r].data==="{"&&e[r].depth++}}return e;function c(){for(;e[r]&&(e[r].type==="whitespace"||e[r].data==="["||e[r].data==="]"||e[r].data==="integer");)r++}}return L}var E,le;function ya(){if(le)return E;le=1,E=o;function o(e){var a=[0],t=a[0],n=0;if(!e||!e.length)return e;if(!("depth"in e[0]))throw new Error("glsl-token-scope: No scope depth defined on tokens! Use glsl-token-depth on these tokens first");for(var i=0;i<e.length;i++){var r=e[i],c=r.depth;c>n?a.push(++t):c<n&&a.splice(-1,1),r.scope=a[a.length-1],r.stack=a.slice(),n=r.depth}return e}return E}var W,se;function xa(){if(se)return W;se=1,W=o;function o(e){for(var a=0;a<e.length;a++){var t=e[a];if(t.property=!1,t.type==="ident"){for(var n=a;e[--n]&&e[n].type==="whitespace";);e[n]&&e[n].type==="operator"&&e[n].data==="."&&(t.property=!0)}}return e}return W}var H,me;function ha(){return me||(me=1,H={"<<=":!0,">>=":!0,"++":!0,"--":!0,"+=":!0,"-=":!0,"*=":!0,"/=":!0,"%=":!0,"&=":!0,"^=":!0,"|=":!0,"=":!0}),H}var U,ue;function ga(){return ue||(ue=1,U={precision:!0,highp:!0,mediump:!0,lowp:!0,attribute:!0,const:!0,uniform:!0,varying:!0,break:!0,continue:!0,do:!0,for:!0,while:!0,if:!0,else:!0,in:!0,out:!0,inout:!0,true:!0,false:!0,return:!0}),U}var X,ve;function za(){if(ve)return X;ve=1;var o=ha(),e=ga();X=a;function a(t){for(var n=0,i=0;i<t.length;i++){var r=t[i],c=r.type;r.assignment=!1,r.declaration=!1,!(c!=="ident"&&c!=="builtin")&&(n=i+1,l(),t[n].type==="operator"&&o[t[n].data]&&(r.assignment=!0))}for(var i=0;i<t.length;i++){var s=t[i],c=s.type,m=s.data;if(s.declaration=!1,c==="keyword"){if(e[m])continue}else if(c!=="ident")continue;if(n=i+1,v(),t[n].type==="ident"){if(t[n++].declaration=!0,v(),t[n].data==="("){for(n++,l();t[n]&&t[n].data!==")"&&!(t[n].type!=="keyword"&&t[n].type!=="ident");)n++,l(),t[n].type==="ident"&&(t[n++].declaration=!0,l(),v(),l(),t[n].data===","&&(n++,l()));i=n;continue}for(;t[n]&&t[n].data!==";";)t[n].data===","?(n++,l(),(t[n].declaration=t[n].type==="ident")&&n++):(l(),f(),l(),n++);i=n}}for(var i=0;i<t.length;i++){var r=t[i];if(r.type==="keyword"&&r.data==="struct"&&(n=i+1,l(),t[n].type==="ident"&&(n++,l(),t[n++].data==="{"))){for(l();t[n].type==="ident"||t[n].type==="keyword";){do n++,l(),t[n].structMember=!0,t[n].declaration=!1,n++,v();while(t[n].data===",");t[n].data===";"&&n++,l()}if(n++,l(),t[n].type==="ident")for(t[n].declaration=!0,l();t[++n].data===",";)l(),n++,l(),t[n].type==="ident"&&(t[n].declaration=!0),l()}}return t;function l(z){for(;t[n]&&t[n].type==="whitespace";)n++}function v(){for(;t[n]&&(t[n].type==="integer"||t[n].data==="["||t[n].data==="]"||t[n].type==="whitespace");)n++}function f(){if(t[n]&&t[n].data==="("){var z=0;do{if(t[n].data===";")break;t[n].data==="("&&z++,t[n].data===")"&&z--}while(z&&t[++n])}}}return X}var ba=wa;function wa(o,e){_a()(o),ya()(o),xa()(o),za()(o);for(var a=Sa(o),t=e||Pa(),n={},i=0;i<o.length;i++){var r=o[i],c=r.stack,s=r.data;if(r.descoped=!1,r.type==="ident"&&!r.property&&!r.structMember){for(var m=!1,l=c.length-1;l>=0;l--){var v=a[c[l]];if(v&&v[s]){if(m=!0,l)break;r.descoped=r.data,r.data=n[s]=n[s]||t(s,r)||r.data}}m||(r.descoped=r.data,r.data=n[s]=n[s]||t(s,r)||r.data)}}return o}function Pa(){var o=0;return function(a){return a+"_"+(o++).toString(36)}}function Sa(o){for(var e={},a=0;a<o.length;a++){var t=o[a];t.declaration&&(e[t.scope]=e[t.scope]||{},e[t.scope][t.data]=t)}return e}const de=fa(ba);function pe(o){return typeof o=="string"?new x(o).convertLinearToSRGB():o}function $a(o){switch(o){case"alpha":return{min:0,max:1};case"scale":return{min:0};case"map":return{image:void 0};default:return{}}}function Pe(o){return o instanceof P||o instanceof Ve||o instanceof Ie||o instanceof Re||o instanceof Le}function fe(o){return Pe(o)?o.toArray():o instanceof x?"#"+o.clone().convertLinearToSRGB().getHexString():o instanceof Ee?o.image.src:o}const Ka={normal:"normal",add:"add",subtract:"subtract",multiply:"multiply",lighten:"lighten",darken:"darken",divide:"divide",overlay:"overlay",screen:"screen",softlight:"softlight",negation:"negation",reflect:"reflect"},Se={perlin:"perlin",simplex:"simplex",cell:"cell",curl:"curl",white:"white"},J={local:"local",world:"world",uv:"uv"},Ma={phong:Ne,physical:Oe,toon:Be,basic:xe,lambert:qe,standard:Ge};class h{constructor(e,a,t){this.uuid=Ae.generateUUID().replace(/-/g,"_"),this.name="LayerMaterial",this.mode="normal",this.visible=!0;const i=Object.getOwnPropertyNames(e).filter(c=>c.startsWith("u_")).reduce((c,s)=>{var m;let l=(m=Object.getOwnPropertyDescriptor(e,s))==null?void 0:m.value;return(Pe(l)||l instanceof x)&&(l=l.clone()),D(u({},c),{[s.slice(1)]:l})},{});for(const c in i){const s=c.split("_")[1];(a==null?void 0:a[s])!==void 0&&(i[c]=a[s])}a&&Object.keys(a).map(c=>{a[c]!==void 0&&(this[c]=a[c])}),this.uniforms={},this.schema=[];const r={};Object.keys(i).map(c=>{const s=c.split("_")[1];this.uniforms["u_".concat(this.uuid,"_").concat(s)]={value:pe(i[c])},this.schema.push({value:i[c],label:s}),r[s]={set:m=>{this.uniforms["u_".concat(this.uuid,"_").concat(s)].value=pe(m)},get:()=>this.uniforms["u_".concat(this.uuid,"_").concat(s)].value}}),a!=null&&a.name&&(this.name=a.name),a!=null&&a.mode&&(this.mode=a.mode),a!=null&&a.visible&&(this.visible=a.visible),Object.defineProperties(this,r),this.vertexShader="",this.fragmentShader="",this.vertexVariables="",this.fragmentVariables="",this.onParse=t,this.buildShaders(e),this.schema.push({value:this.mode,label:"mode",options:Object.values(Ka)}),this.schema.push({value:this.visible,label:"visible"})}buildShaders(e){var a;const t=Object.getOwnPropertyNames(e).filter(l=>l==="fragmentShader"||l==="vertexShader").reduce((l,v)=>{var f;return D(u({},l),{[v]:(f=Object.getOwnPropertyDescriptor(e,v))==null?void 0:f.value})},{}),n={vert:ie(t.vertexShader||""),frag:ie(t.fragmentShader||"")},i={vert:de(n.vert,this.renameTokens.bind(this)),frag:de(n.frag,this.renameTokens.bind(this))},r={vert:oe(i.vert),frag:oe(i.frag)},c={vert:r.vert.map(l=>l.name).indexOf("main"),frag:r.frag.map(l=>l.name).indexOf("main")},s={vert:c.vert>=0?R(i.vert.slice(0,r.vert[c.vert].outer[0])):"",frag:c.frag>=0?R(i.frag.slice(0,r.frag[c.frag].outer[0])):""},m={vert:c.vert>=0?this.getShaderFromIndex(i.vert,r.vert[c.vert].body):"",frag:c.frag>=0?this.getShaderFromIndex(i.frag,r.frag[c.frag].body):""};this.vertexShader=this.processFinal(m.vert,!0),this.fragmentShader=this.processFinal(m.frag),this.vertexVariables=s.vert,this.fragmentVariables=s.frag,(a=this.onParse)==null||a.call(this,this),this.schema=this.schema.filter((l,v)=>{const f=l.label;return v===this.schema.findIndex(z=>z.label===f)})}renameTokens(e){if(e.startsWith("u_")){const a=e.slice(2);return"u_".concat(this.uuid,"_").concat(a)}else if(e.startsWith("v_")){const a=e.slice(2);return"v_".concat(this.uuid,"_").concat(a)}else if(e.startsWith("f_")){const a=e.slice(2);return"f_".concat(this.uuid,"_").concat(a)}else return e}processFinal(e,a){const t=e.replace(/\sf_/gm," f_".concat(this.uuid,"_")).replace(/\(f_/gm,"(f_".concat(this.uuid,"_")),n=t.match(/^.*return.*$/gm);let i=t.replace(/^.*return.*$/gm,"");if(n!=null&&n[0]){const r=n[0].replace("return","").trim().replace(";",""),c=this.getBlendMode(r,"lamina_finalColor");i+=a?"lamina_finalPosition = ".concat(r,";"):"lamina_finalColor = ".concat(c,";")}return i}getShaderFromIndex(e,a){return R(e.slice(a[0],a[1]))}getBlendMode(e,a){switch(this.mode){default:case"normal":return"lamina_blend_alpha(".concat(a,", ").concat(e,", ").concat(e,".a)");case"add":return"lamina_blend_add(".concat(a,", ").concat(e,", ").concat(e,".a)");case"subtract":return"lamina_blend_subtract(".concat(a,", ").concat(e,", ").concat(e,".a)");case"multiply":return"lamina_blend_multiply(".concat(a,", ").concat(e,", ").concat(e,".a)");case"lighten":return"lamina_blend_lighten(".concat(a,", ").concat(e,", ").concat(e,".a)");case"darken":return"lamina_blend_darken(".concat(a,", ").concat(e,", ").concat(e,".a)");case"divide":return"lamina_blend_divide(".concat(a,", ").concat(e,", ").concat(e,".a)");case"overlay":return"lamina_blend_overlay(".concat(a,", ").concat(e,", ").concat(e,".a)");case"screen":return"lamina_blend_screen(".concat(a,", ").concat(e,", ").concat(e,".a)");case"softlight":return"lamina_blend_softlight(".concat(a,", ").concat(e,", ").concat(e,".a)");case"reflect":return"lamina_blend_reflect(".concat(a,", ").concat(e,", ").concat(e,".a)");case"negation":return"lamina_blend_negation(".concat(a,", ").concat(e,", ").concat(e,".a)")}}getSchema(){return this.schema.map(i=>{var r=i,{label:a,options:t}=r,n=q(r,["label","options"]);return D(u(u({label:a,options:t},$a(a)),n),{value:fe(this[a])})})}serialize(){const e=this.constructor.name.split("$")[0];let a=Object.keys(this);a=a.filter(i=>!["uuid","uniforms","schema","fragmentShader","vertexShader","fragmentVariables","vertexVariables","attribs","events","__r3f","onParse"].includes(i));const t={};a.forEach(i=>{t[i]=this[i]});const n={};for(const i in this.uniforms){const r=i.replace("u_".concat(this.uuid,"_"),"");n[r]=fe(this.uniforms[i].value)}return{constructor:e,properties:u(u({},n),t)}}}class p extends h{constructor(e){super(p,u({name:"Depth"},e),a=>{a.schema.push({value:a.mapping,label:"mapping",options:["vector","world","camera"]});const t=p.getMapping(a.uuid,a.mapping);a.fragmentShader=a.fragmentShader.replace("lamina_mapping_template",t)}),this.mapping="vector"}static getMapping(e,a){switch(a){default:case"vector":return"length(v_".concat(e,"_worldPosition - u_").concat(e,"_origin)");case"world":return"length(v_".concat(e,"_position - vec3(0.))");case"camera":return"length(v_".concat(e,"_worldPosition - cameraPosition)")}}}p.u_near=2;p.u_far=10;p.u_origin=new P(0,0,0);p.u_colorA="white";p.u_colorB="black";p.u_alpha=1;p.vertexShader="\n  varying vec3 v_worldPosition;\n  varying vec3 v_position;\n\n  void main() {\n    v_worldPosition = (vec4(position, 1.0) * modelMatrix).xyz;\n    v_position = position;\n  }\n  ";p.fragmentShader="   \n    uniform float u_alpha;\n    uniform float u_near;\n    uniform float u_far;\n    uniform float u_isVector;\n    uniform vec3 u_origin;\n    uniform vec3 u_colorA;\n    uniform vec3 u_colorB;\n\n    varying vec3 v_worldPosition;\n    varying vec3 v_position;\n\n    void main() {\n      float f_dist = lamina_mapping_template;\n      float f_depth = (f_dist - u_near) / (u_far - u_near);\n			vec3 f_depthColor =  mix(u_colorB, u_colorA, 1.0 - clamp(f_depth, 0., 1.));\n  \n  \n      return vec4(f_depthColor, u_alpha);\n    }\n  ";class S extends h{constructor(e){super(S,u({name:"Color"},e))}}S.u_color="red";S.u_alpha=1;S.fragmentShader="   \n    uniform vec3 u_color;\n    uniform float u_alpha;\n\n    void main() {\n      return vec4(u_color, u_alpha);\n    }\n  ";class d extends h{constructor(e){super(d,u({name:"noise"},e),a=>{a.schema.push({value:a.type,label:"type",options:Object.values(Se)}),a.schema.push({value:a.mapping,label:"mapping",options:Object.values(J)});const t=d.getNoiseFunction(a.type),n=d.getMapping(a.mapping);a.vertexShader=a.vertexShader.replace("lamina_mapping_template",n),a.fragmentShader=a.fragmentShader.replace("lamina_noise_template",t)}),this.type="perlin",this.mapping="local"}static getNoiseFunction(e){switch(e){default:case"perlin":return"lamina_noise_perlin";case"simplex":return"lamina_noise_simplex";case"cell":return"lamina_noise_worley";case"white":return"lamina_noise_white";case"curl":return"lamina_noise_swirl"}}static getMapping(e){switch(e){default:case"local":return"position";case"world":return"(modelMatrix * vec4(position,1.0)).xyz";case"uv":return"vec3(uv, 0.)"}}}d.u_colorA="#666666";d.u_colorB="#666666";d.u_colorC="#FFFFFF";d.u_colorD="#FFFFFF";d.u_alpha=1;d.u_scale=1;d.u_offset=new P(0,0,0);d.vertexShader="\n    varying vec3 v_position;\n\n    void main() {\n        v_position = lamina_mapping_template;\n    }\n  ";d.fragmentShader="   \n    uniform vec3 u_colorA;\n    uniform vec3 u_colorB;\n    uniform vec3 u_colorC;\n    uniform vec3 u_colorD;\n    uniform vec3 u_offset;\n\n    uniform float u_alpha;\n    uniform float u_scale;\n\n    varying vec3 v_position;\n\n\n    void main() {\n        float f_n = lamina_noise_template((v_position + u_offset) * u_scale);\n\n        float f_step1 = 0.;\n        float f_step2 = 0.2;\n        float f_step3 = 0.6;\n        float f_step4 = 1.;\n\n        vec3 f_color = mix(u_colorA, u_colorB, smoothstep(f_step1, f_step2, f_n));\n        f_color = mix(f_color, u_colorC, smoothstep(f_step2, f_step3, f_n));\n        f_color = mix(f_color, u_colorD, smoothstep(f_step3, f_step4, f_n));\n\n        return vec4(f_color, u_alpha);\n    }\n  ";class y extends h{constructor(e){super(y,u({name:"Fresnel"},e))}}y.u_color="white";y.u_alpha=1;y.u_bias=0;y.u_intensity=1;y.u_power=2;y.u_factor=1;y.vertexShader="\n    varying vec3 v_worldPosition;\n    varying vec3 v_worldNormal;\n\n    void main() {\n        v_worldPosition = vec3(-viewMatrix[0][2], -viewMatrix[1][2], -viewMatrix[2][2]);\n        v_worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );\n        \n    }\n  ";y.fragmentShader="   \n    uniform vec3 u_color;\n    uniform float u_alpha;\n    uniform float u_bias;\n    uniform float u_intensity;\n    uniform float u_power;\n    uniform float u_factor;\n\n    varying vec3 v_worldPosition;\n    varying vec3 v_worldNormal;\n\n    void main() {\n        float f_a = (u_factor  + dot(v_worldPosition, v_worldNormal));\n        float f_fresnel = u_bias + u_intensity * pow(abs(f_a), u_power);\n\n        f_fresnel = clamp(f_fresnel, 0.0, 1.0);\n        return vec4(f_fresnel * u_color, u_alpha);\n    }\n  ";class _ extends h{constructor(e){super(_,u({name:"Gradient"},e),a=>{a.schema.push({value:a.axes,label:"axes",options:["x","y","z"]}),a.schema.push({value:a.mapping,label:"mapping",options:Object.values(J)});const t=_.getMapping(a.mapping);a.vertexShader=a.vertexShader.replace("lamina_mapping_template",t||"local"),a.fragmentShader=a.fragmentShader.replace("axes_template",a.axes||"x")}),this.axes="x",this.mapping="local"}static getMapping(e){switch(e){default:case"local":return"position";case"world":return"(modelMatrix * vec4(position,1.0)).xyz";case"uv":return"vec3(uv, 0.)"}}}_.u_colorA="white";_.u_colorB="black";_.u_alpha=1;_.u_start=1;_.u_end=-1;_.u_contrast=1;_.vertexShader="\n		varying vec3 v_position;\n\n		vod main() {\n      v_position = lamina_mapping_template;\n		}\n  ";_.fragmentShader="   \n    uniform vec3 u_colorA;\n    uniform vec3 u_colorB;\n    uniform vec3 u_axis;\n    uniform float u_alpha;\n    uniform float u_start;\n    uniform float u_end;\n    uniform float u_contrast;\n\n		varying vec3 v_position;\n\n    void main() {\n\n      float f_step = smoothstep(u_start, u_end, v_position.axes_template * u_contrast);\n      vec3 f_color = mix(u_colorA, u_colorB, f_step);\n\n      return vec4(f_color, u_alpha);\n    }\n  ";class $ extends h{constructor(e){super($,u({name:"Matcap"},e))}}$.u_alpha=1;$.u_map=void 0;$.vertexShader="\n    varying vec3 v_position;\n    varying vec3 v_normal;\n    \n    void main() {\n      v_position = normalize( vec3( modelViewMatrix * vec4( position, 1.0 ) ) );\n      v_normal = normalize( normalMatrix * normal );\n    }\n    ";$.fragmentShader=" \n		uniform sampler2D u_map;  \n		uniform float u_alpha;  \n		varying vec3 v_position;\n		varying vec3 v_normal;\n\n		\n    void main() {\n			vec3 f_r = reflect( v_position, v_normal );\n			float f_m = 2. * sqrt( pow( f_r.x, 2. ) + pow( f_r.y, 2. ) + pow( f_r.z + 1., 2. ) );\n			vec2 f_vN = f_r.xy / f_m + .5;\n\n			vec3 f_base = texture2D(u_map, f_vN).rgb;\n\n      return vec4(f_base, u_alpha);\n    }\n  ";class K extends h{constructor(e){super(K,u({name:"Texture"},e))}}K.u_alpha=1;K.u_map=void 0;K.vertexShader="\n    varying vec2 v_uv;\n    \n    void main() {\n        v_uv = uv;\n    }\n    ";K.fragmentShader=" \n		uniform sampler2D u_map;  \n		uniform float u_alpha;  \n		varying vec2 v_uv;\n\n    void main() {\n			vec4 f_color = texture2D(u_map, v_uv);\n      return vec4(f_color.rgb, f_color.a * u_alpha);\n    }\n  ";class g extends h{constructor(e){super(g,u({name:"Displace"},e),a=>{a.schema.push({value:a.type,label:"type",options:Object.values(Se)}),a.schema.push({value:a.mapping,label:"mapping",options:Object.values(J)});const t=g.getNoiseFunction(a.type),n=g.getMapping(a.mapping);a.vertexVariables=a.vertexVariables.replace("lamina_mapping_template",n),a.vertexVariables=a.vertexVariables.replace("lamina_noise_template",t)}),this.type="perlin",this.mapping="local"}static getNoiseFunction(e){switch(e){default:case"perlin":return"lamina_noise_perlin";case"simplex":return"lamina_noise_simplex";case"cell":return"lamina_noise_worley";case"white":return"lamina_noise_white";case"curl":return"lamina_noise_swirl"}}static getMapping(e){switch(e){default:case"local":return"p";case"world":return"(modelMatrix * vec4(p,1.0)).xyz";case"uv":return"vec3(uv, 0.)"}}}g.u_strength=1;g.u_scale=1;g.u_offset=new P(0,0,0);g.vertexShader="\n       \n      uniform float u_strength;\n      uniform float u_scale;\n      uniform vec3 u_offset;\n\n      vec3 displace(vec3 p) {\n				vec3 f_position = lamina_mapping_template;\n        float f_n = lamina_noise_template((f_position + u_offset) * u_scale) * u_strength;\n        vec3 f_newPosition = p + (f_n * normal);\n\n				return f_newPosition;\n      }\n\n      \n			vec3 orthogonal(vec3 v) {\n  		  return normalize(abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)\n  		  : vec3(0.0, -v.z, v.y));\n  		}\n  		vec3 recalcNormals(vec3 newPos) {\n  		  float offset = 0.001;\n  		  vec3 tangent = orthogonal(normal);\n  		  vec3 bitangent = normalize(cross(normal, tangent));\n  		  vec3 neighbour1 = position + tangent * offset;\n  		  vec3 neighbour2 = position + bitangent * offset;\n  		  vec3 displacedNeighbour1 = displace(neighbour1);\n  		  vec3 displacedNeighbour2 = displace(neighbour2);\n  		  vec3 displacedTangent = displacedNeighbour1 - newPos;\n  		  vec3 displacedBitangent = displacedNeighbour2 - newPos;\n  		  return normalize(cross(displacedTangent, displacedBitangent));\n  		}\n  \n  \n      void main() {\n       \n				vec3 f_newPosition = displace(position);\n        lamina_finalNormal = recalcNormals(f_newPosition);\n\n        return f_newPosition;\n      }\n    ";class M extends h{constructor(e){super(M,u({name:"Normal"},e))}}M.u_alpha=1;M.u_direction=new P(1,1,1);M.vertexShader="   \n  varying vec3 v_normals; \n\n  void main() {\n    v_normals = normal;\n  }\n";M.fragmentShader="   \n  	uniform float u_alpha;\n  	uniform vec3 u_color;\n  	uniform vec3 u_direction;\n\n		varying vec3 v_normals;\n\n    void main() {\n			vec3 f_normalColor = vec3(1.);\n      f_normalColor.x = v_normals.x * u_direction.x;\n      f_normalColor.y = v_normals.y * u_direction.y;\n      f_normalColor.z = v_normals.z * u_direction.z;\n\n      return vec4(f_normalColor, u_alpha);\n    }\n  ";var ja="\nvec4 lamina_blend_add(const in vec4 x, const in vec4 y, const in float opacity) {\n\n	return vec4(min(x.xyz + y.xyz, 1.0) * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nvec3 lamina_blend_alpha(const in vec3 x, const in vec3 y, const in float opacity) {\n\n	return y * opacity + x * (1.0 - opacity);\n\n}\n\nvec4 lamina_blend_alpha(const in vec4 x, const in vec4 y, const in float opacity) {\n\n	float a = min(y.a, opacity);\n\n	return vec4(lamina_blend_alpha(x.rgb, y.rgb, a), x.a);\n\n}\nvec4 lamina_blend_average(const in vec4 x, const in vec4 y, const in float opacity) {\n\n	return vec4((x.xyz + y.xyz) * 0.5 * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nfloat lamina_blend_color_burn(const in float x, const in float y) {\n\n	return (y == 0.0) ? y : max(1.0 - (1.0 - x) / y, 0.0);\n\n}\n\nvec4 lamina_blend_color_burn(const in vec4 x, const in vec4 y, const in float opacity) {\n\n	vec4 z = vec4(\n		lamina_blend_color_burn(x.r, y.r),\n		lamina_blend_color_burn(x.g, y.g),\n		lamina_blend_color_burn(x.b, y.b),\n		lamina_blend_color_burn(x.a, y.a)\n	);\n\n	return vec4(z.xyz * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nfloat lamina_blend_color_dodge(const in float x, const in float y) {\n\n	return (y == 1.0) ? y : min(x / (1.0 - y), 1.0);\n\n}\n\nvec4 lamina_blend_color_dodge(const in vec4 x, const in vec4 y, const in float opacity) {\n\n	vec4 z = vec4(\n		lamina_blend_color_dodge(x.r, y.r),\n		lamina_blend_color_dodge(x.g, y.g),\n		lamina_blend_color_dodge(x.b, y.b),\n		lamina_blend_color_dodge(x.a, y.a)\n	);\n\n	return vec4(z.xyz * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nvec4 lamina_blend_darken(const in vec4 x, const in vec4 y, const in float opacity) {\n\n	return vec4(min(x.xyz, y.xyz) * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nvec4 lamina_blend_difference(const in vec4 x, const in vec4 y, const in float opacity) {\n\n	return vec4(abs(x.xyz - y.xyz) * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nfloat lamina_blend_divide(const in float x, const in float y) {\n\n	return (y > 0.0) ? min(x / y, 1.0) : 1.0;\n\n}\n\nvec4 lamina_blend_divide(const in vec4 x, const in vec4 y, const in float opacity) {\n\n	vec4 z = vec4(\n		lamina_blend_divide(x.r, y.r),\n		lamina_blend_divide(x.g, y.g),\n		lamina_blend_divide(x.b, y.b),\n		lamina_blend_divide(x.a, y.a)\n	);\n\n	return vec4(z.xyz * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nvec4 lamina_blend_exclusion(const in vec4 x, const in vec4 y, const in float opacity) {\n\n	return vec4((x.xyz + y.xyz - 2.0 * x.xyz * y.xyz) * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nvec4 lamina_blend_lighten(const in vec4 x, const in vec4 y, const in float opacity) {\n\n	return vec4(max(x.xyz, y.xyz) * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nvec4 lamina_blend_multiply(const in vec4 x, const in vec4 y, const in float opacity) {\n\n	return vec4( x.xyz * y.xyz * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nvec4 lamina_blend_negation(const in vec4 x, const in vec4 y, const in float opacity) {\n\n	return vec4((1.0 - abs(1.0 - x.xyz - y.xyz)) * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nvec4 lamina_blend_normal(const in vec4 x, const in vec4 y, const in float opacity) {\n\n	return vec4(y.xyz * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nfloat lamina_blend_overlay(const in float x, const in float y) {\n\n	return (x < 0.5) ? (2.0 * x * y) : (1.0 - 2.0 * (1.0 - x) * (1.0 - y));\n\n}\n\nvec4 lamina_blend_overlay(const in vec4 x, const in vec4 y, const in float opacity) {\n\n	vec4 z = vec4(\n		lamina_blend_overlay(x.r, y.r),\n		lamina_blend_overlay(x.g, y.g),\n		lamina_blend_overlay(x.b, y.b),\n		lamina_blend_overlay(x.a, y.a)\n	);\n\n	return vec4(z.xyz * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nfloat lamina_blend_reflect(const in float x, const in float y) {\n\n	return (y == 1.0) ? y : min(x * x / (1.0 - y), 1.0);\n\n}\n\nvec4 lamina_blend_reflect(const in vec4 x, const in vec4 y, const in float opacity) {\n\n	vec4 z = vec4(\n		lamina_blend_reflect(x.r, y.r),\n		lamina_blend_reflect(x.g, y.g),\n		lamina_blend_reflect(x.b, y.b),\n		lamina_blend_reflect(x.a, y.a)\n	);\n\n	return vec4(z.xyz * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nvec4 lamina_blend_screen(const in vec4 x, const in vec4 y, const in float opacity) {\n\n	return vec4((1.0 - (1.0 - x.xyz) * (1.0 - y.xyz)) * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nfloat lamina_blend_softlight(const in float x, const in float y) {\n\n	return (y < 0.5) ?\n		(2.0 * x * y + x * x * (1.0 - 2.0 * y)) :\n		(sqrt(x) * (2.0 * y - 1.0) + 2.0 * x * (1.0 - y));\n\n}\n\nvec4 lamina_blend_softlight(const in vec4 x, const in vec4 y, const in float opacity) {\n\n	vec4 z = vec4(\n		lamina_blend_softlight(x.r, y.r),\n		lamina_blend_softlight(x.g, y.g),\n		lamina_blend_softlight(x.b, y.b),\n		lamina_blend_softlight(x.a, y.a)\n	);\n\n	return vec4(z.xyz * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\nvec4 lamina_blend_subtract(const in vec4 x, const in vec4 y, const in float opacity) {\n\n	return vec4(max(x.xyz + y.xyz - 1.0, 0.0) * opacity + x.xyz * (1.0 - opacity), x.a);\n\n}\n\n",_e="\n\n// From: https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n// Huge thanks to the creators of these algorithms\n\nfloat lamina_noise_mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 lamina_noise_mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 lamina_noise_perm(vec4 x){return lamina_noise_mod289(((x * 34.0) + 1.0) * x);}\nvec4 lamina_noise_permute(vec4 x) { return mod(((x * 34.0) + 1.0) * x, 289.0); }\nvec4 lamina_noise_taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\n\nfloat lamina_noise_white(vec2 p) {\n  return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) *\n               (0.1 + abs(sin(p.y * 13.0 + p.x))));\n}\n\nfloat lamina_noise_white(vec3 p) {\n  return lamina_noise_white(p.xy);\n}\n\n\nvec3 lamina_noise_fade(vec3 t) { return t * t * t * (t * (t * 6.0 - 15.0) + 10.0); }\n\nfloat lamina_noise_perlin(vec3 P) {\n  vec3 Pi0 = floor(P);        // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P);        // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = lamina_noise_permute(lamina_noise_permute(ix) + iy);\n  vec4 ixy0 = lamina_noise_permute(ixy + iz0);\n  vec4 ixy1 = lamina_noise_permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);\n  vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);\n  vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);\n  vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);\n  vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);\n  vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);\n  vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);\n  vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);\n\n  vec4 norm0 = lamina_noise_taylorInvSqrt(\n      vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = lamina_noise_taylorInvSqrt(\n      vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = lamina_noise_fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111),\n                 fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return lamina_normalize(2.2 * n_xyz);\n}\n\nfloat lamina_noise_simplex(vec3 v) {\n  const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  // First corner\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  // Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  //  x0 = x0 - 0. + 0.0 * C\n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n  // Permutations\n  i = mod(i, 289.0);\n  vec4 p = lamina_noise_permute(lamina_noise_permute(lamina_noise_permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y +\n                             vec4(0.0, i1.y, i2.y, 1.0)) +\n                    i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  // Gradients\n  // ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0 / 7.0; // N=7\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z); //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_); // mod(j,N)\n\n  vec4 x = x_ * ns.x + ns.yyyy;\n  vec4 y = y_ * ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0) * 2.0 + 1.0;\n  vec4 s1 = floor(b1) * 2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  // Normalise gradients\n  vec4 norm =\n      lamina_noise_taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  // Mix final noise value\n  vec4 m =\n      max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n  m = m * m;\n  return lamina_normalize(42.0 *\n         dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3))));\n}\n\nvec3 lamina_noise_simplex3(vec3 x) {\n  float s = lamina_noise_simplex(vec3(x));\n  float s1 = lamina_noise_simplex(vec3(x.y - 19.1, x.z + 33.4, x.x + 47.2));\n  float s2 = lamina_noise_simplex(vec3(x.z + 74.2, x.x - 124.5, x.y + 99.4));\n  vec3 c = vec3(s, s1, s2);\n  return c;\n}\n\nvec3 lamina_noise_curl(vec3 p) {\n  const float e = .1;\n  vec3 dx = vec3(e, 0.0, 0.0);\n  vec3 dy = vec3(0.0, e, 0.0);\n  vec3 dz = vec3(0.0, 0.0, e);\n\n  vec3 p_x0 = lamina_noise_simplex3(p - dx);\n  vec3 p_x1 = lamina_noise_simplex3(p + dx);\n  vec3 p_y0 = lamina_noise_simplex3(p - dy);\n  vec3 p_y1 = lamina_noise_simplex3(p + dy);\n  vec3 p_z0 = lamina_noise_simplex3(p - dz);\n  vec3 p_z1 = lamina_noise_simplex3(p + dz);\n\n  float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;\n  float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;\n  float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;\n\n  const float divisor = 1.0 / (2.0 * e);\n  return normalize(vec3(x, y, z) * divisor);\n}\n\nvec3 lamina_permute(vec3 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\nvec3 lamina_dist(vec3 x, vec3 y, vec3 z,  bool manhattanDistance) {\n  return manhattanDistance ?  abs(x) + abs(y) + abs(z) :  (x * x + y * y + z * z);\n}\n\n// From: https://github.com/Erkaman/glsl-worley\nfloat lamina_noise_worley(vec3 P) {\n  float jitter = 1.;\n  bool manhattanDistance = false; \n\n  float K = 0.142857142857; // 1/7\n  float Ko = 0.428571428571; // 1/2-K/2\n  float  K2 = 0.020408163265306; // 1/(7*7)\n  float Kz = 0.166666666667; // 1/6\n  float Kzo = 0.416666666667; // 1/2-1/6*2\n\n	vec3 Pi = mod(floor(P), 289.0);\n 	vec3 Pf = fract(P) - 0.5;\n\n	vec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);\n	vec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);\n	vec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);\n\n	vec3 p = lamina_permute(Pi.x + vec3(-1.0, 0.0, 1.0));\n	vec3 p1 = lamina_permute(p + Pi.y - 1.0);\n	vec3 p2 = lamina_permute(p + Pi.y);\n	vec3 p3 = lamina_permute(p + Pi.y + 1.0);\n\n	vec3 p11 = lamina_permute(p1 + Pi.z - 1.0);\n	vec3 p12 = lamina_permute(p1 + Pi.z);\n	vec3 p13 = lamina_permute(p1 + Pi.z + 1.0);\n\n	vec3 p21 = lamina_permute(p2 + Pi.z - 1.0);\n	vec3 p22 = lamina_permute(p2 + Pi.z);\n	vec3 p23 = lamina_permute(p2 + Pi.z + 1.0);\n\n	vec3 p31 = lamina_permute(p3 + Pi.z - 1.0);\n	vec3 p32 = lamina_permute(p3 + Pi.z);\n	vec3 p33 = lamina_permute(p3 + Pi.z + 1.0);\n\n	vec3 ox11 = fract(p11*K) - Ko;\n	vec3 oy11 = mod(floor(p11*K), 7.0)*K - Ko;\n	vec3 oz11 = floor(p11*K2)*Kz - Kzo; // p11 < 289 guaranteed\n\n	vec3 ox12 = fract(p12*K) - Ko;\n	vec3 oy12 = mod(floor(p12*K), 7.0)*K - Ko;\n	vec3 oz12 = floor(p12*K2)*Kz - Kzo;\n\n	vec3 ox13 = fract(p13*K) - Ko;\n	vec3 oy13 = mod(floor(p13*K), 7.0)*K - Ko;\n	vec3 oz13 = floor(p13*K2)*Kz - Kzo;\n\n	vec3 ox21 = fract(p21*K) - Ko;\n	vec3 oy21 = mod(floor(p21*K), 7.0)*K - Ko;\n	vec3 oz21 = floor(p21*K2)*Kz - Kzo;\n\n	vec3 ox22 = fract(p22*K) - Ko;\n	vec3 oy22 = mod(floor(p22*K), 7.0)*K - Ko;\n	vec3 oz22 = floor(p22*K2)*Kz - Kzo;\n\n	vec3 ox23 = fract(p23*K) - Ko;\n	vec3 oy23 = mod(floor(p23*K), 7.0)*K - Ko;\n	vec3 oz23 = floor(p23*K2)*Kz - Kzo;\n\n	vec3 ox31 = fract(p31*K) - Ko;\n	vec3 oy31 = mod(floor(p31*K), 7.0)*K - Ko;\n	vec3 oz31 = floor(p31*K2)*Kz - Kzo;\n\n	vec3 ox32 = fract(p32*K) - Ko;\n	vec3 oy32 = mod(floor(p32*K), 7.0)*K - Ko;\n	vec3 oz32 = floor(p32*K2)*Kz - Kzo;\n\n	vec3 ox33 = fract(p33*K) - Ko;\n	vec3 oy33 = mod(floor(p33*K), 7.0)*K - Ko;\n	vec3 oz33 = floor(p33*K2)*Kz - Kzo;\n\n	vec3 dx11 = Pfx + jitter*ox11;\n	vec3 dy11 = Pfy.x + jitter*oy11;\n	vec3 dz11 = Pfz.x + jitter*oz11;\n\n	vec3 dx12 = Pfx + jitter*ox12;\n	vec3 dy12 = Pfy.x + jitter*oy12;\n	vec3 dz12 = Pfz.y + jitter*oz12;\n\n	vec3 dx13 = Pfx + jitter*ox13;\n	vec3 dy13 = Pfy.x + jitter*oy13;\n	vec3 dz13 = Pfz.z + jitter*oz13;\n\n	vec3 dx21 = Pfx + jitter*ox21;\n	vec3 dy21 = Pfy.y + jitter*oy21;\n	vec3 dz21 = Pfz.x + jitter*oz21;\n\n	vec3 dx22 = Pfx + jitter*ox22;\n	vec3 dy22 = Pfy.y + jitter*oy22;\n	vec3 dz22 = Pfz.y + jitter*oz22;\n\n	vec3 dx23 = Pfx + jitter*ox23;\n	vec3 dy23 = Pfy.y + jitter*oy23;\n	vec3 dz23 = Pfz.z + jitter*oz23;\n\n	vec3 dx31 = Pfx + jitter*ox31;\n	vec3 dy31 = Pfy.z + jitter*oy31;\n	vec3 dz31 = Pfz.x + jitter*oz31;\n\n	vec3 dx32 = Pfx + jitter*ox32;\n	vec3 dy32 = Pfy.z + jitter*oy32;\n	vec3 dz32 = Pfz.y + jitter*oz32;\n\n	vec3 dx33 = Pfx + jitter*ox33;\n	vec3 dy33 = Pfy.z + jitter*oy33;\n	vec3 dz33 = Pfz.z + jitter*oz33;\n\n	vec3 d11 = lamina_dist(dx11, dy11, dz11, manhattanDistance);\n	vec3 d12 = lamina_dist(dx12, dy12, dz12, manhattanDistance);\n	vec3 d13 = lamina_dist(dx13, dy13, dz13, manhattanDistance);\n	vec3 d21 = lamina_dist(dx21, dy21, dz21, manhattanDistance);\n	vec3 d22 = lamina_dist(dx22, dy22, dz22, manhattanDistance);\n	vec3 d23 = lamina_dist(dx23, dy23, dz23, manhattanDistance);\n	vec3 d31 = lamina_dist(dx31, dy31, dz31, manhattanDistance);\n	vec3 d32 = lamina_dist(dx32, dy32, dz32, manhattanDistance);\n	vec3 d33 = lamina_dist(dx33, dy33, dz33, manhattanDistance);\n\n	vec3 d1a = min(d11, d12);\n	d12 = max(d11, d12);\n	d11 = min(d1a, d13); // Smallest now not in d12 or d13\n	d13 = max(d1a, d13);\n	d12 = min(d12, d13); // 2nd smallest now not in d13\n	vec3 d2a = min(d21, d22);\n	d22 = max(d21, d22);\n	d21 = min(d2a, d23); // Smallest now not in d22 or d23\n	d23 = max(d2a, d23);\n	d22 = min(d22, d23); // 2nd smallest now not in d23\n	vec3 d3a = min(d31, d32);\n	d32 = max(d31, d32);\n	d31 = min(d3a, d33); // Smallest now not in d32 or d33\n	d33 = max(d3a, d33);\n	d32 = min(d32, d33); // 2nd smallest now not in d33\n	vec3 da = min(d11, d21);\n	d21 = max(d11, d21);\n	d11 = min(da, d31); // Smallest now in d11\n	d31 = max(da, d31); // 2nd smallest now not in d31\n	d11.xy = (d11.x < d11.y) ? d11.xy : d11.yx;\n	d11.xz = (d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest\n	d12 = min(d12, d21); // 2nd smallest now not in d21\n	d12 = min(d12, d22); // nor in d22\n	d12 = min(d12, d31); // nor in d31\n	d12 = min(d12, d32); // nor in d32\n	d11.yz = min(d11.yz,d12.xy); // nor in d12.yz\n	d11.y = min(d11.y,d12.z); // Only two more to go\n	d11.y = min(d11.y,d11.z); // Done! (Phew!)\n\n  vec2 F = sqrt(d11.xy);\n	return F.x; // F1, F2\n\n}\n\nfloat lamina_noise_swirl(vec3 position) {\n    float scale = 0.1;\n    float freq = 4. * scale;\n    float t = 1.;\n\n    vec3 pos = (position * scale) + lamina_noise_curl(position * 7. * scale);\n\n    float worley1 = 1. - lamina_noise_worley((pos * (freq * 2.)) +  (t * 2.));\n    float worley2 = 1. - lamina_noise_worley((pos * (freq * 4.)) +  (t * 4.));\n    float worley3 = 1. - lamina_noise_worley((pos * (freq * 8.)) +  (t * 8.));\n    float worley4 = 1. - lamina_noise_worley((pos * (freq * 16.)) +  (t * 16.));\n    \n    float fbm1 = worley1 * .625 + worley2 * .25 + worley3 * .125;\n    float fbm2 = worley2 * .625 + worley3 * .25 + worley4 * .125;\n    float fbm3 = worley3 * .75 + worley4 * .25;\n\n    vec3 curlWorleyFbm = vec3(fbm1, fbm2, fbm3);\n    float curlWorley = curlWorleyFbm.r * .625 + curlWorleyFbm.g * .25 + \n        curlWorleyFbm.b * .125;\n\n    return curlWorley;\n}\n  \n  \n",ye="\n\nfloat lamina_map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat lamina_normalize(float v) { return lamina_map(v, -1.0, 1.0, 0.0, 1.0); }\n";class Fa extends pa{constructor(c={}){var s=c,{color:e,alpha:a,lighting:t,layers:n,name:i}=s,r=q(s,["color","alpha","lighting","layers","name"]);super(u({baseMaterial:Ma[t||"basic"]},r)),this.name="LayerMaterial",this.layers=[],this.lighting="basic";const m=e||"white",l=a!=null?a:1;this.uniforms={u_lamina_color:{value:typeof m=="string"?new x(m).convertSRGBToLinear():m},u_lamina_alpha:{value:l}},this.layers=n||this.layers,this.lighting=t||this.lighting,this.name=i||this.name,this.refresh()}genShaders(){let e="",a="",t="",n="",i={};return this.layers.filter(r=>r.visible).forEach(r=>{e+=r.vertexVariables+"\n",a+=r.fragmentVariables+"\n",t+=r.vertexShader+"\n",n+=r.fragmentShader+"\n",i=u(u({},i),r.uniforms)}),i=u(u({},i),this.uniforms),{uniforms:i,vertexShader:"\n        ".concat(ye,"\n        ").concat(_e,"\n        ").concat(e,"\n\n        void main() {\n          vec3 lamina_finalPosition = position;\n          vec3 lamina_finalNormal = normal;\n\n          ").concat(t,"\n\n          csm_Position = lamina_finalPosition;\n          csm_Normal = lamina_finalNormal;\n        }\n        "),fragmentShader:"\n        ".concat(ye,"\n        ").concat(_e,"\n        ").concat(ja,"\n        ").concat(a,"\n\n        uniform vec3 u_lamina_color;\n        uniform float u_lamina_alpha;\n\n        void main() {\n          vec4 lamina_finalColor = vec4(u_lamina_color, u_lamina_alpha);\n\n          ").concat(n,"\n\n          csm_DiffuseColor = lamina_finalColor;\n         \n        }\n        ")}}refresh(){const{uniforms:e,fragmentShader:a,vertexShader:t}=this.genShaders();super.update({fragmentShader:a,vertexShader:t,uniforms:e})}serialize(){return{constructor:"LayerMaterial",properties:{color:this.color,alpha:this.alpha,name:this.name,lighting:this.lighting}}}set color(e){var a,t;(a=this.uniforms)!=null&&(t=a.u_lamina_color)!=null&&t.value&&(this.uniforms.u_lamina_color.value=typeof e=="string"?new x(e).convertSRGBToLinear():e)}get color(){var e,a;return(e=this.uniforms)==null||(a=e.u_lamina_color)==null?void 0:a.value}set alpha(e){this.uniforms.u_lamina_alpha.value=e}get alpha(){return this.uniforms.u_lamina_alpha.value}}class w{constructor(e={}){G(this,"material");G(this,"mesh");const{color:a="white",form:t="rect",intensity:n=1}=e,i={circle:new ae(0,1,64),ring:new ae(.5,1,64),rect:new We}[t],r=new xe({side:He,color:new x(a)});r.color.multiplyScalar(n),this.material=r;const c=new he(i,r);this.mesh=c}}const Ca=ge({__name:"environmentForLightformers",props:{resolution:{default:256},near:{default:1},far:{default:1e3}},setup(o){const e=o,a=new Ue(e.resolution);a.texture.type=Xe;const t=new Je(e.near,e.far,a),n=new Qe,i=new A,r=new w;r.mesh.scale.set(10,10,1),r.mesh.position.set(0,5,-9),r.mesh.rotation.x=Math.PI/2;const c=new w({intensity:4});c.mesh.scale.set(20,.1,1),c.mesh.position.set(-5,1,-1),c.mesh.rotation.y=Math.PI/2;const s=new w;s.mesh.scale.set(20,.5,1),s.mesh.position.set(-5,-1,-1),s.mesh.rotation.y=Math.PI/2;const m=new w;m.mesh.scale.set(20,1,1),m.mesh.position.set(10,1,0),m.mesh.rotation.y=-Math.PI/2;const l=new w({form:"ring",color:"red"});l.mesh.scale.set(10,10,10),l.mesh.position.set(-15,4,-18),i.add(r.mesh,c.mesh,s.mesh,m.mesh,l.mesh);const v=new A;v.rotation.set(0,.5,0);const f=new A;v.add(f),[2,0,2,0,2,0,2,0].forEach((F,Z)=>{const C=new w({form:"circle",intensity:2});C.mesh.rotation.x=Math.PI/2,C.mesh.scale.set(3,1,1),C.mesh.position.set(F,4,Z*4),f.add(C.mesh)}),i.add(v);const $e=new Ye(1,64,64),Ke=new Fa({side:Ze,layers:[new S({color:"#444",mode:"normal",alpha:1}),new p({colorA:"blue",colorB:"black",alpha:.8,mode:"normal",near:0,far:300,origin:new P(100,100,100)})]}),Q=new he($e,Ke);Q.scale.set(100,100,100),i.add(Q);const{scene:Y,renderer:Me,sizes:je}=ke();ze(()=>{je.width.value&&n.add(i)});const{onBeforeLoop:Fe}=ea();return Fe(({delta:F})=>{Y.value&&((f.position.z+=F*10)>20&&(f.position.z=-60),t.update(Me.value,n),Y.value.environment=a.texture)}),(F,Z)=>null}}),Ta=["object"],Da={__name:"carModel",async setup(o){let e,a;const{scene:t,nodes:n,materials:i}=([e,a]=aa(()=>ta("https://opensource-1314935952.cos.ap-nanjing.myqcloud.com/model/industry4/911-transformed.glb",{draco:!0,decoderPath:"./draco/"})),e=await e,a(),e);return Object.values(n).forEach(r=>{r.isMesh&&(r.receiveShadow=r.castShadow=!0)}),i.rubber.color=new x("#222"),i.rubber.roughness=.6,i.rubber.roughnessMap=null,i.rubber.normalScale=[4,4],i.window.color=new x("black"),i.window.roughness=0,i.window.clearcoat=.1,i.coat.envMapIntensity=4,i.coat.roughness=.4,i.coat.metalness=1,i.paint.envMapIntensity=2.6,i.paint.roughness=.345,i.paint.metalness=.9,i.paint.color=new x("#666"),(r,c)=>(N(),be(we,null,[O("primitive",{object:j(t)},null,8,Ta),b(j(na),{opacity:.6,blur:.5,position:[0,-.7,0],frames:100,scale:10,far:100})],64))}},Na=O("TresPerspectiveCamera",{position:[5,1,5],fov:30,near:1,far:1e3},null,-1),Oa=O("TresAmbientLight",{color:"#ffffff",intensity:"2.5"},null,-1),Xa=ge({__name:"showCar",setup(o){const e=ra(null);ze(()=>{e.value&&(e.value.shadow.mapSize.width=1024,e.value.shadow.mapSize.height=1024,e.value.shadow.camera.near=1,e.value.shadow.camera.far=100,e.value.shadow.bias=-1e-4)});const a=V({reflectivity:.1,mirror:.92,mixStrength:36,showGridHelper:!1}),t=V({clearColor:"#82839f",shadows:!0,alpha:!1,antialias:!0,pixelRatio:window.devicePixelRatio,shadowMapType:ia,outputColorSpace:oa,toneMapping:ca,useLegacyLights:!0}),n=V({autoRotate:!0});return(i,r)=>{const c=la("TresCanvas");return N(),be(we,null,[b(j(da)),b(c,te(t,{"window-size":""}),{default:I(()=>[Na,b(j(sa),ma(ua(n)),null,16),Oa,O("TresSpotLight",{ref_key:"spotLight",ref:e,position:[0,15,0],angle:.3,penumbra:1,castShadow:"",intensity:2},null,512),(N(),ne(re,null,{default:I(()=>[b(Da)]),_:1})),(N(),ne(re,null,{default:I(()=>[b(va,te(a,{position:[0,-.6,0]}),null,16)]),_:1})),b(j(Ca))]),_:1},16)],64)}}});export{Xa as default};
