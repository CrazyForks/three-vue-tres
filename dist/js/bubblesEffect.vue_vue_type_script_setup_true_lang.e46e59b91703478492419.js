import{aH as T,aM as V,bW as se,bX as ne,bL as W,aJ as E,bl as w,bV as B,br as N,bE as C,al as oe,aU as k,bF as M,aX as F,Z as D,a4 as O,o as R,c as G,J as X,k as I,aA as ie,aQ as ae,aF as q,ai as Q,aN as re,a3 as Z,V as U,a8 as K,a9 as ee,aT as le,an as L}from"./vendor.3b6898491703478492419.js";import{m as te}from"./BufferGeometryUtils.5bc4c5621703478492419.js";const ce=/^[og]\s*(.+)?/,ue=/^mtllib /,fe=/^usemtl /,me=/^usemap /,H=/\s+/,J=new T,A=new T,Y=new T,$=new T,_=new T,S=new V;function pe(){const x={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(s,t){if(this.object&&this.object.fromDeclaration===!1){this.object.name=s,this.object.fromDeclaration=t!==!1;return}const n=this.object&&typeof this.object.currentMaterial=="function"?this.object.currentMaterial():void 0;if(this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0),this.object={name:s||"",fromDeclaration:t!==!1,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(e,o){const l=this._finalize(!1);l&&(l.inherited||l.groupCount<=0)&&this.materials.splice(l.index,1);const c={index:this.materials.length,name:e||"",mtllib:Array.isArray(o)&&o.length>0?o[o.length-1]:"",smooth:l!==void 0?l.smooth:this.smooth,groupStart:l!==void 0?l.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(b){const a={index:typeof b=="number"?b:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return a.clone=this.clone.bind(a),a}};return this.materials.push(c),c},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(e){const o=this.currentMaterial();if(o&&o.groupEnd===-1&&(o.groupEnd=this.geometry.vertices.length/3,o.groupCount=o.groupEnd-o.groupStart,o.inherited=!1),e&&this.materials.length>1)for(let l=this.materials.length-1;l>=0;l--)this.materials[l].groupCount<=0&&this.materials.splice(l,1);return e&&this.materials.length===0&&this.materials.push({name:"",smooth:this.smooth}),o}},n&&n.name&&typeof n.clone=="function"){const e=n.clone(0);e.inherited=!0,this.object.materials.push(e)}this.objects.push(this.object)},finalize:function(){this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0)},parseVertexIndex:function(s,t){const n=parseInt(s,10);return(n>=0?n-1:n+t/3)*3},parseNormalIndex:function(s,t){const n=parseInt(s,10);return(n>=0?n-1:n+t/3)*3},parseUVIndex:function(s,t){const n=parseInt(s,10);return(n>=0?n-1:n+t/2)*2},addVertex:function(s,t,n){const e=this.vertices,o=this.object.geometry.vertices;o.push(e[s+0],e[s+1],e[s+2]),o.push(e[t+0],e[t+1],e[t+2]),o.push(e[n+0],e[n+1],e[n+2])},addVertexPoint:function(s){const t=this.vertices;this.object.geometry.vertices.push(t[s+0],t[s+1],t[s+2])},addVertexLine:function(s){const t=this.vertices;this.object.geometry.vertices.push(t[s+0],t[s+1],t[s+2])},addNormal:function(s,t,n){const e=this.normals,o=this.object.geometry.normals;o.push(e[s+0],e[s+1],e[s+2]),o.push(e[t+0],e[t+1],e[t+2]),o.push(e[n+0],e[n+1],e[n+2])},addFaceNormal:function(s,t,n){const e=this.vertices,o=this.object.geometry.normals;J.fromArray(e,s),A.fromArray(e,t),Y.fromArray(e,n),_.subVectors(Y,A),$.subVectors(J,A),_.cross($),_.normalize(),o.push(_.x,_.y,_.z),o.push(_.x,_.y,_.z),o.push(_.x,_.y,_.z)},addColor:function(s,t,n){const e=this.colors,o=this.object.geometry.colors;e[s]!==void 0&&o.push(e[s+0],e[s+1],e[s+2]),e[t]!==void 0&&o.push(e[t+0],e[t+1],e[t+2]),e[n]!==void 0&&o.push(e[n+0],e[n+1],e[n+2])},addUV:function(s,t,n){const e=this.uvs,o=this.object.geometry.uvs;o.push(e[s+0],e[s+1]),o.push(e[t+0],e[t+1]),o.push(e[n+0],e[n+1])},addDefaultUV:function(){const s=this.object.geometry.uvs;s.push(0,0),s.push(0,0),s.push(0,0)},addUVLine:function(s){const t=this.uvs;this.object.geometry.uvs.push(t[s+0],t[s+1])},addFace:function(s,t,n,e,o,l,c,b,a){const r=this.vertices.length;let i=this.parseVertexIndex(s,r),u=this.parseVertexIndex(t,r),f=this.parseVertexIndex(n,r);if(this.addVertex(i,u,f),this.addColor(i,u,f),c!==void 0&&c!==""){const g=this.normals.length;i=this.parseNormalIndex(c,g),u=this.parseNormalIndex(b,g),f=this.parseNormalIndex(a,g),this.addNormal(i,u,f)}else this.addFaceNormal(i,u,f);if(e!==void 0&&e!==""){const g=this.uvs.length;i=this.parseUVIndex(e,g),u=this.parseUVIndex(o,g),f=this.parseUVIndex(l,g),this.addUV(i,u,f),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(s){this.object.geometry.type="Points";const t=this.vertices.length;for(let n=0,e=s.length;n<e;n++){const o=this.parseVertexIndex(s[n],t);this.addVertexPoint(o),this.addColor(o)}},addLineGeometry:function(s,t){this.object.geometry.type="Line";const n=this.vertices.length,e=this.uvs.length;for(let o=0,l=s.length;o<l;o++)this.addVertexLine(this.parseVertexIndex(s[o],n));for(let o=0,l=t.length;o<l;o++)this.addUVLine(this.parseUVIndex(t[o],e))}};return x.startObject("",!1),x}class we extends se{constructor(s){super(s),this.materials=null}load(s,t,n,e){const o=this,l=new ne(this.manager);l.setPath(this.path),l.setRequestHeader(this.requestHeader),l.setWithCredentials(this.withCredentials),l.load(s,function(c){try{t(o.parse(c))}catch(b){e?e(b):console.error(b),o.manager.itemError(s)}},n,e)}setMaterials(s){return this.materials=s,this}parse(s){const t=new pe;s.indexOf("\r\n")!==-1&&(s=s.replace(/\r\n/g,"\n")),s.indexOf("\\\n")!==-1&&(s=s.replace(/\\\n/g,""));const n=s.split("\n");let e=[];for(let c=0,b=n.length;c<b;c++){const a=n[c].trimStart();if(a.length===0)continue;const r=a.charAt(0);if(r!=="#")if(r==="v"){const i=a.split(H);switch(i[0]){case"v":t.vertices.push(parseFloat(i[1]),parseFloat(i[2]),parseFloat(i[3])),i.length>=7?(S.setRGB(parseFloat(i[4]),parseFloat(i[5]),parseFloat(i[6])).convertSRGBToLinear(),t.colors.push(S.r,S.g,S.b)):t.colors.push(void 0,void 0,void 0);break;case"vn":t.normals.push(parseFloat(i[1]),parseFloat(i[2]),parseFloat(i[3]));break;case"vt":t.uvs.push(parseFloat(i[1]),parseFloat(i[2]));break}}else if(r==="f"){const u=a.slice(1).trim().split(H),f=[];for(let h=0,d=u.length;h<d;h++){const m=u[h];if(m.length>0){const v=m.split("/");f.push(v)}}const g=f[0];for(let h=1,d=f.length-1;h<d;h++){const m=f[h],v=f[h+1];t.addFace(g[0],m[0],v[0],g[1],m[1],v[1],g[2],m[2],v[2])}}else if(r==="l"){const i=a.substring(1).trim().split(" ");let u=[];const f=[];if(a.indexOf("/")===-1)u=i;else for(let g=0,h=i.length;g<h;g++){const d=i[g].split("/");d[0]!==""&&u.push(d[0]),d[1]!==""&&f.push(d[1])}t.addLineGeometry(u,f)}else if(r==="p"){const u=a.slice(1).trim().split(" ");t.addPointGeometry(u)}else if((e=ce.exec(a))!==null){const i=(" "+e[0].slice(1).trim()).slice(1);t.startObject(i)}else if(fe.test(a))t.object.startMaterial(a.substring(7).trim(),t.materialLibraries);else if(ue.test(a))t.materialLibraries.push(a.substring(7).trim());else if(me.test(a))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if(r==="s"){if(e=a.split(" "),e.length>1){const u=e[1].trim().toLowerCase();t.object.smooth=u!=="0"&&u!=="off"}else t.object.smooth=!0;const i=t.object.currentMaterial();i&&(i.smooth=t.object.smooth)}else{if(a==="\0")continue;console.warn('THREE.OBJLoader: Unexpected line: "'+a+'"')}}t.finalize();const o=new W;if(o.materialLibraries=[].concat(t.materialLibraries),!(t.objects.length===1&&t.objects[0].geometry.vertices.length===0)===!0)for(let c=0,b=t.objects.length;c<b;c++){const a=t.objects[c],r=a.geometry,i=a.materials,u=r.type==="Line",f=r.type==="Points";let g=!1;if(r.vertices.length===0)continue;const h=new E;h.setAttribute("position",new w(r.vertices,3)),r.normals.length>0&&h.setAttribute("normal",new w(r.normals,3)),r.colors.length>0&&(g=!0,h.setAttribute("color",new w(r.colors,3))),r.hasUVIndices===!0&&h.setAttribute("uv",new w(r.uvs,2));const d=[];for(let v=0,P=i.length;v<P;v++){const y=i[v],z=y.name+"_"+y.smooth+"_"+g;let p=t.materials[z];if(this.materials!==null){if(p=this.materials.create(y.name),u&&p&&!(p instanceof B)){const j=new B;N.prototype.copy.call(j,p),j.color.copy(p.color),p=j}else if(f&&p&&!(p instanceof C)){const j=new C({size:10,sizeAttenuation:!1});N.prototype.copy.call(j,p),j.color.copy(p.color),j.map=p.map,p=j}}p===void 0&&(u?p=new B:f?p=new C({size:1,sizeAttenuation:!1}):p=new oe,p.name=y.name,p.flatShading=!y.smooth,p.vertexColors=g,t.materials[z]=p),d.push(p)}let m;if(d.length>1){for(let v=0,P=i.length;v<P;v++){const y=i[v];h.addGroup(y.groupStart,y.groupCount,v)}u?m=new k(h,d):f?m=new M(h,d):m=new F(h,d)}else u?m=new k(h,d[0]):f?m=new M(h,d[0]):m=new F(h,d[0]);m.name=a.name,o.add(m)}else if(t.vertices.length>0){const c=new C({size:1,sizeAttenuation:!1}),b=new E;b.setAttribute("position",new w(t.vertices,3)),t.colors.length>0&&t.colors[0]!==void 0&&(b.setAttribute("color",new w(t.colors,3)),c.vertexColors=!0);const a=new M(b,c);o.add(a)}return o}}const je=(x,s)=>new Promise((t,n)=>{s.setCrossOrigin("Anonymous"),s.load(x,e=>{t(e)},e=>{console.log("".concat(e.loaded/e.total*100,"% loaded"))},e=>{console.error(e),n(e)})}),he=["object"],Pe=D({__name:"cloudPoints",props:{model:{},color:{default:"#FFF"},opacity:{default:1}},setup(x){const s=x,t=new W;return s.model.traverse(n=>{if(n instanceof F){const e=n.geometry.clone();n.geometry.dispose(),n.material.dispose();const o=new C({color:s.color});o.opacity=s.opacity,o.transparent=!0;const l=new M(e,o);t.add(l)}}),O(()=>{s.color&&t.traverse(n=>{n instanceof M&&(n.material.color=new V(s.color))}),s.opacity&&t.traverse(n=>{n instanceof M&&(n.material.opacity=s.opacity)})}),(n,e)=>(R(),G("primitive",{object:X(t)},null,8,he))}}),de="uniform float c;\nuniform float p;\nuniform float uTime;\nvarying float intensity;\nvarying vec2 vUv;\nvoid main(){\n    vUv=uv;\n    vec3 vNormal=normalize(normalMatrix*normal);\n    intensity=pow(c-abs(dot(vNormal,vec3(0,0,1))),p);\n    gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.);\n}",ge="uniform vec3 glowColor;\nuniform sampler2D lightningTexture;\nvarying float intensity;\nvarying vec2 vUv;\nuniform float offsetY;\nuniform float uTime;\nuniform float uOpacity;\n\nvoid main(){\n  vec2 uv=vUv;\n  uv.y+=offsetY;\n  vec3 glow=glowColor*intensity;\n  vec3 color=vec3(step(.1,uv.y)-step(.2,uv.y))-vec3(texture2D(lightningTexture,uv));\n  float alpha=clamp(cos(uTime*3.),.5,1.);\n  gl_FragColor=vec4(glow+color,alpha*uOpacity);\n}",be=U("TresBufferGeometry",null,null,-1),ze=D({__name:"xRayEffect",props:{model:{},color:{default:"#84ccff"},opacity:{default:1}},async setup(x){let s,t;const n=x,e=I(),o=[];n.model.traverse(r=>{r instanceof F&&(r.geometry.verticesNeedUpdate=!0,o.push(r.geometry))});const l=([s,t]=ie(()=>ae({map:"./plugins/medical/image/brainXRayLight.png"})),s=await s,t(),s),c={uniforms:{c:{type:"f",value:1.11},p:{type:"f",value:1},glowColor:{type:"c",value:new V(n.color)},lightningTexture:{type:"t",value:l.map},offsetY:{type:"f",value:.1},uTime:{type:"f",value:0},uOpacity:{type:"f",value:n.opacity}},vertexShader:de,fragmentShader:ge,side:q,blending:Q,depthWrite:!1};c.uniforms.offsetY.value=Math.sin(5);const{camera:b}=re(),{onLoop:a}=Z();return a(({delta:r})=>{b.value.position&&e.value&&(c.uniforms.uTime.value+=r)}),O(()=>{e.value&&(e.value.geometry.dispose(),e.value.geometry=te(o)),n.color&&(c.uniforms.glowColor.value=new V(n.color)),n.opacity&&(c.uniforms.uOpacity.value=n.opacity)}),(r,i)=>(R(),G("TresMesh",{ref_key:"TresMeshRef",ref:e},[be,U("TresShaderMaterial",K(ee(c)),null,16)],512))}}),ve="uniform float p;\nuniform float uTime;\nuniform float uSlowTime;\nuniform float uBubblesUp;\nvarying float intensity;\nattribute vec2 aDelayDuration;\nattribute float size;\nattribute vec4 bubbles;\nvarying float alpha;\n\nfloat easeExpoInOut(float p){\n    return((p*=2.)<1.)?.5*pow(2.,10.*(p-1.)):.5*(2.-pow(2.,-10.*(p-1.)));\n}\n\nvoid main()\n{\n    intensity=.9;\n    vec4 mvPosition=modelViewMatrix*vec4(position,1.);\n    gl_PointSize=size*(300./-mvPosition.z);\n    float m=mod(size,sin(uSlowTime*.12+size));\n    \n    alpha=step(.5,abs(m));\n    if(m>.5&&m<.7){\n        gl_PointSize=.9*size;\n    }\n    if(m>.8){\n        gl_PointSize=.9*size;\n    }\n    \n    gl_Position=projectionMatrix*mvPosition;\n    \n    if(bubbles.w>0.&&bubbles.w<2.&&bubbles.x!=0.&&bubbles.y!=0.){\n        gl_PointSize=size+15.;\n        alpha=clamp(abs(sin(uTime-bubbles.y)),.3,1.);\n        \n        float tProgress=smoothstep(0.,aDelayDuration.x,uBubblesUp);\n        vec3 tranlated=mix(position,bubbles.xyz,tProgress);\n        vec4 bPosition=modelViewMatrix*vec4(tranlated,1.);\n        \n        gl_PointSize=uBubblesUp*gl_PointSize;\n        gl_Position+=projectionMatrix*bPosition;\n        alpha=5.;\n    }\n    \n    if(bubbles.w==2.){\n        alpha=clamp(abs(sin(uTime-bubbles.y)),.3,.6);\n        gl_PointSize=size+60.;\n        \n        gl_PointSize=uBubblesUp*gl_PointSize;\n        float normalized=clamp(uBubblesUp,0.,2.)*2.;\n        vec3 tranlated=mix(position,bubbles.xyz,normalized);\n        vec4 bPosition=modelViewMatrix*vec4(tranlated,1.);\n        gl_Position+=projectionMatrix*bPosition;\n    }\n    if(bubbles.w==3.){\n        alpha=clamp(abs(sin(uTime-bubbles.y)),.3,1.);\n        gl_PointSize=size+90.;\n        \n        gl_PointSize=uBubblesUp*gl_PointSize;\n        float normalized=clamp(uBubblesUp,0.,2.)*2.;\n        vec3 tranlated=mix(position,bubbles.xyz,normalized);\n        vec4 bPosition=modelViewMatrix*vec4(tranlated,1.);\n        gl_Position+=projectionMatrix*bPosition;\n    }\n}",ye="uniform vec3 glowColor;\nvarying float intensity;\nvarying float alpha;\nuniform float uOpacity;\nvoid main()\n{\n    float distanceToCenter=distance(gl_PointCoord,vec2(.5));\n    float pct=1.-smoothstep(0.,.5,distanceToCenter);\n    vec3 color=vec3(1.)*gl_FragColor.rgb;\n    vec3 glow=glowColor*intensity;\n    gl_FragColor=vec4(glow,clamp(alpha,0.,1.));\n    gl_FragColor=vec4(glow,pct*gl_FragColor.a);\n    gl_FragColor=vec4(gl_FragColor.rgb,gl_FragColor.a*uOpacity);\n    // gl_FragColor=vec4(1.,1.,0.,1.);\n}",Me=D({__name:"bubblesEffect",props:{model:{},color:{default:"#FFF"},opacity:{default:1}},setup(x){const s=x,t=["afective","semantic","episodic","process","amigdala","brainstem","bridge","cerebellum","analitic"],n={};s.model.traverse(a=>{a instanceof F&&t.map(r=>{if(a.name.includes(r)){if(n[r]){const i=[n[r],a.geometry];return n[r]=te(i),n}return n[r]=a.geometry}return[]})});const e=I(),o=()=>{const r=[],i=[],u=[],f=[],d=[];for(let m=0;m<2e4-t.length*3;m+=1){const v=L.randInt(0,t.length-1),P=t[v],y=n[P].attributes.position.array[m*3+0]||0,z=n[P].attributes.position.array[m*3+1]||0,p=n[P].attributes.position.array[m*3+2]||0;if(i.push(y,z,p),r[m]=L.randFloat(10,20),m%100===0){const j=L.randInt(100,250)+z;d.push(y,j,p,1)}else d.push(y,z,p,0);f[m*2+0]=L.randFloat(.5,1.5),f[m*2+1]=2.5}e.value.setAttribute("aDelayDuration",new w(f,2)),e.value.setAttribute("bubbles",new w(d,4)),e.value.setAttribute("position",new w(i,3)),e.value.setAttribute("color",new w(u,3)),e.value.setAttribute("size",new w(r,1)),e.value.computeBoundingSphere()},l=new le({uniforms:{glowColor:{type:"c",value:new V(s.color)},uTime:{type:"f",value:0},uSlowTime:{type:"f",value:0},uBubblesUp:{type:"f",value:1},uOpacity:{type:"f",value:s.opacity}},vertexShader:ve,fragmentShader:ye,blending:Q,side:q,depthTest:!1,vertexColors:!1,transparent:!0});O(()=>{e.value&&o()});const c=I(),{onLoop:b}=Z();return b(({delta:a})=>{c.value&&(c.value.material.uniforms.uTime.value+=1/20,c.value.material.uniforms.uSlowTime.value+=1/400),s.color&&(l.uniforms.glowColor.value=new V(s.color)),s.opacity&&(l.uniforms.uOpacity.value=s.opacity)}),(a,r)=>(R(),G("TresPoints",{ref_key:"TresMeshRef",ref:c},[U("TresBufferGeometry",{ref_key:"BufferGeometryRef",ref:e},null,512),U("TresShaderMaterial",K(ee(X(l))),null,16)],512))}});export{we as O,Pe as _,ze as a,Me as b,je as l};
