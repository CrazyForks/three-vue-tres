import{$ as u,a4 as d,aR as x,aZ as s,a5 as y,o as m,c as g,W as e,a9 as v,aa as h,a6 as w,v as C,D as q,a7 as M,K as p,a8 as k,a as f,ab as D}from"./vendor.briXmWCi1709613738534.js";const L="varying vec2 vUv;\nvoid main(){\n	gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.);\n	vUv=uv;\n}",S="#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform vec3 u_mouse;\nuniform float u_time;\nvarying vec2 vUv;\n\nmat2 rot2D(float angle){\n  float s=sin(angle);\n  float c=cos(angle);\n  return mat2(c,-s,s,c);\n}\nfloat sdCutSphere(vec3 p,float r,float h)\n{\n  // sampling independent computations (only depend on shape)\n  float w=sqrt(r*r-h*h);\n  \n  // sampling dependant computations\n  vec2 q=vec2(length(p.xz),p.y);\n  float s=max((h-r)*q.x*q.x+w*w*(h+r-2.*q.y),h*q.x-w*q.y);\n  return(s<0.)?length(q)-r:\n  (q.x<w)?h-q.y:\n  length(q-vec2(w,h));\n}\n\nfloat sdCappedCone(vec3 p,vec3 a,vec3 b,float ra,float rb)\n{\n  float rba=rb-ra;\n  float baba=dot(b-a,b-a);\n  float papa=dot(p-a,p-a);\n  float paba=dot(p-a,b-a)/baba;\n  float x=sqrt(papa-paba*paba*baba);\n  float cax=max(0.,x-((paba<.5)?ra:rb));\n  float cay=abs(paba-.5)-.5;\n  float k=rba*rba+baba;\n  float f=clamp((rba*(x-ra)+paba*baba)/k,0.,1.);\n  float cbx=x-ra-f*rba;\n  float cby=paba-f;\n  float s=(cbx<0.&&cay<0.)?-1.:1.;\n  return s*sqrt(min(cax*cax+cay*cay*baba,\n    cbx*cbx+cby*cby*baba));\n  }\n  float smin(float d1,float d2,float k){\n    float h=clamp(.5+.5*(d2-d1)/k,0.,1.);\n    return mix(d2,d1,h)-k*h*(1.-h);\n  }\n  //模糊摆动，y的值越大，摆动频率越大\n  vec3 bendPoint(vec3 p,float k)\n  {\n    float c=cos(k*p.y);\n    float s=sin(k*p.y);\n    mat2 m=mat2(c,-s,s,c);\n    vec3 q=vec3(m*p.xy,p.z);\n    return q;\n  }\n  float map(vec3 p){\n    vec3 q=p;\n    p=bendPoint(p,sin(u_time*5.));\n    // p.xy*=rot2D(sin(u_time)*.1);\n    vec3 pp2=vec3(0.,.8,0.);\n    vec3 pp1=vec3(0.,-.2,0.);\n    float CappedConesdf=sdCappedCone(-p,pp1,pp2,.2,.1);\n    float CutSpheresdf=sdCutSphere(-p-vec3(0.,.4,0.),.5,.2)-.1;\n    float entity=smin(CappedConesdf,CutSpheresdf,.1);\n    entity=smin(entity,-q.y+.1,.2);\n    return entity;\n  }\n  \n  void main(){\n    vec3 ro=vec3(0.,0.,-4.);//起始位置\n    vec3 rd=normalize(vec3(vUv-.5,1.));//方向\n    // horizontal camera rotation\n    \n    // ro.xz*=rot2D(-u_mouse.x*.001);\n    // rd.xz*=rot2D(-u_mouse.x*.001);\n    // ro.xy*=rot2D(-u_mouse.y*.001);\n    // rd.xy*=rot2D(-u_mouse.y*.001);\n    float t=0.;\n    vec3 color=vec3(0.);\n    for(int i=0;i<80;i++){\n      vec3 p=ro+rd*t;\n      float d=map(p);\n      t+=d;\n      //优化效率\n      if(t>100.||d<.001){\n        break;\n      }\n      \n    }\n    color=vec3(t)*.2;\n    gl_FragColor=vec4(color,1.);\n    \n  }",P=["rotation"],T={ref:"TresTubeGeometryRef",args:[1e3,1e3]},z=u({__name:"rayMarchingMaterialMushroom",setup(b){const{onLoop:t,onAfterLoop:o}=d(),n={transparent:!0,depthWrite:!0,depthTest:!0,side:x,vertexShader:L,fragmentShader:S,uniforms:{u_resolution:{value:new s(window.innerWidth,window.innerHeight)},u_mouse:{value:new s(0,0)},u_time:{value:0}}},r=window.innerWidth/2,i=window.innerHeight/2;let c=0,l=0;function _(a){c=a.clientX-r,l=a.clientY-i}return document.addEventListener("mousemove",_,!1),y(()=>{}),t(({elapsed:a})=>{n.uniforms.u_time.value+=.001,n.uniforms.u_mouse.value=new s(c,l)}),o(()=>{}),(a,E)=>(m(),g("TresMesh",{ref:"MeshRef",rotation:[Math.PI/2,0,0]},[e("TresPlaneGeometry",T,null,512),e("TresShaderMaterial",v(h(n)),null,16)],8,P))}}),R={ref:"perspectiveCameraRef",position:[0,1500,0],fov:45,near:1,far:1e4},V=e("TresAmbientLight",{color:"#ffffff"},null,-1),B=e("TresDirectionalLight",{position:[100,100,0],intensity:.5,color:"#ffffff"},null,-1),U=u({__name:"rayMarchingMushroom",setup(b){const t={clearColor:"#000000",shadows:!0,alpha:!1,useLegacyLights:!0},o={autoRotate:!1,enableDamping:!0},{onLoop:n}=d();return n(({delta:r})=>{}),w(()=>{}),(r,i)=>(m(),C(p(k),M(t,{"window-size":""}),{default:q(()=>[e("TresPerspectiveCamera",R,null,512),f(p(D),v(h(o)),null,16),V,B,f(z)]),_:1},16))}});export{U as default};
