var Qn=Object.defineProperty,Jn=Object.defineProperties;var Gn=Object.getOwnPropertyDescriptors;var An=Object.getOwnPropertySymbols;var On=Object.prototype.hasOwnProperty,te=Object.prototype.propertyIsEnumerable;var Tn=(e,n,t)=>n in e?Qn(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t,xt=(e,n)=>{for(var t in n||(n={}))On.call(n,t)&&Tn(e,t,n[t]);if(An)for(var t of An(n))te.call(n,t)&&Tn(e,t,n[t]);return e},Wt=(e,n)=>Jn(e,Gn(n));import{b6 as mn,aQ as L,aZ as et,aP as $n,bb as Z,b4 as gt,bc as ne,bd as tt,be as W,b8 as ee,aR as kn,b7 as bn,at as Xn,bf as se,bg as ie,b5 as Bn,ba as re,aq as oe}from"./vendor.Fk0OTSuU1709709202159.js";import{W as ce}from"./Water2.kqkDGq9i1709709202159.js";const Hn=0,ae=1,le=2,Pn=2,Yt=1.25,gn=1,Mt=6*4+4+4,Ht=65535,ue=Math.pow(2,-24),Zt=Symbol("SKIP_GENERATION");function fe(e){return e.index?e.index.count:e.attributes.position.count}function dt(e){return fe(e)/3}function pe(e,n=ArrayBuffer){return e>65535?new Uint32Array(new n(4*e)):new Uint16Array(new n(2*e))}function ye(e,n){if(!e.index){const t=e.attributes.position.count,s=n.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=pe(t,s);e.setIndex(new mn(i,1));for(let a=0;a<t;a++)i[a]=a}}function jn(e){const n=dt(e),t=e.drawRange,s=t.start/3,i=(t.start+t.count)/3,a=Math.max(0,s),r=Math.min(n,i)-a;return[{offset:Math.floor(a),count:Math.floor(r)}]}function Wn(e){if(!e.groups||!e.groups.length)return jn(e);const n=[],t=new Set,s=e.drawRange,i=s.start/3,a=(s.start+s.count)/3;for(const o of e.groups){const c=o.start/3,f=(o.start+o.count)/3;t.add(Math.max(i,c)),t.add(Math.min(a,f))}const r=Array.from(t.values()).sort((o,c)=>o-c);for(let o=0;o<r.length-1;o++){const c=r[o],f=r[o+1];n.push({offset:Math.floor(c),count:Math.floor(f-c)})}return n}function de(e){if(e.groups.length===0)return!1;const n=dt(e),t=Wn(e).sort((a,r)=>a.offset-r.offset),s=t[t.length-1];s.count=Math.min(n-s.offset,s.count);let i=0;return t.forEach(({count:a})=>i+=a),n!==i}function Kt(e,n,t,s,i){let a=1/0,r=1/0,o=1/0,c=-1/0,f=-1/0,u=-1/0,p=1/0,l=1/0,y=1/0,x=-1/0,P=-1/0,w=-1/0;for(let d=n*6,m=(n+t)*6;d<m;d+=6){const h=e[d+0],b=e[d+1],A=h-b,B=h+b;A<a&&(a=A),B>c&&(c=B),h<p&&(p=h),h>x&&(x=h);const T=e[d+2],_=e[d+3],g=T-_,S=T+_;g<r&&(r=g),S>f&&(f=S),T<l&&(l=T),T>P&&(P=T);const C=e[d+4],M=e[d+5],U=C-M,F=C+M;U<o&&(o=U),F>u&&(u=F),C<y&&(y=C),C>w&&(w=C)}s[0]=a,s[1]=r,s[2]=o,s[3]=c,s[4]=f,s[5]=u,i[0]=p,i[1]=l,i[2]=y,i[3]=x,i[4]=P,i[5]=w}function me(e,n=null,t=null,s=null){const i=e.attributes.position,a=e.index?e.index.array:null,r=dt(e),o=i.normalized;let c;n===null?(c=new Float32Array(r*6*4),t=0,s=r):(c=n,t=t||0,s=s||r);const f=i.array,u=i.offset||0;let p=3;i.isInterleavedBufferAttribute&&(p=i.data.stride);const l=["getX","getY","getZ"];for(let y=t;y<t+s;y++){const x=y*3,P=y*6;let w=x+0,d=x+1,m=x+2;a&&(w=a[w],d=a[d],m=a[m]),o||(w=w*p+u,d=d*p+u,m=m*p+u);for(let h=0;h<3;h++){let b,A,B;o?(b=i[l[h]](w),A=i[l[h]](d),B=i[l[h]](m)):(b=f[w+h],A=f[d+h],B=f[m+h]);let T=b;A<T&&(T=A),B<T&&(T=B);let _=b;A>_&&(_=A),B>_&&(_=B);const g=(_-T)/2,S=h*2;c[P+S+0]=T+g,c[P+S+1]=g+(Math.abs(T)+g)*ue}}return c}function E(e,n,t){return t.min.x=n[e],t.min.y=n[e+1],t.min.z=n[e+2],t.max.x=n[e+3],t.max.y=n[e+4],t.max.z=n[e+5],t}function _n(e){let n=-1,t=-1/0;for(let s=0;s<3;s++){const i=e[s+3]-e[s];i>t&&(t=i,n=s)}return n}function Mn(e,n){n.set(e)}function Sn(e,n,t){let s,i;for(let a=0;a<3;a++){const r=a+3;s=e[a],i=n[a],t[a]=s<i?s:i,s=e[r],i=n[r],t[r]=s>i?s:i}}function Ct(e,n,t){for(let s=0;s<3;s++){const i=n[e+2*s],a=n[e+2*s+1],r=i-a,o=i+a;r<t[s]&&(t[s]=r),o>t[s+3]&&(t[s+3]=o)}}function wt(e){const n=e[3]-e[0],t=e[4]-e[1],s=e[5]-e[2];return 2*(n*t+t*s+s*n)}const Y=32,he=(e,n)=>e.candidate-n.candidate,J=new Array(Y).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),Ut=new Float32Array(6);function xe(e,n,t,s,i,a){let r=-1,o=0;if(a===Hn)r=_n(n),r!==-1&&(o=(n[r]+n[r+3])/2);else if(a===ae)r=_n(e),r!==-1&&(o=we(t,s,i,r));else if(a===le){const c=wt(e);let f=Yt*i;const u=s*6,p=(s+i)*6;for(let l=0;l<3;l++){const y=n[l],w=(n[l+3]-y)/Y;if(i<Y/4){const d=[...J];d.length=i;let m=0;for(let b=u;b<p;b+=6,m++){const A=d[m];A.candidate=t[b+2*l],A.count=0;const{bounds:B,leftCacheBounds:T,rightCacheBounds:_}=A;for(let g=0;g<3;g++)_[g]=1/0,_[g+3]=-1/0,T[g]=1/0,T[g+3]=-1/0,B[g]=1/0,B[g+3]=-1/0;Ct(b,t,B)}d.sort(he);let h=i;for(let b=0;b<h;b++){const A=d[b];for(;b+1<h&&d[b+1].candidate===A.candidate;)d.splice(b+1,1),h--}for(let b=u;b<p;b+=6){const A=t[b+2*l];for(let B=0;B<h;B++){const T=d[B];A>=T.candidate?Ct(b,t,T.rightCacheBounds):(Ct(b,t,T.leftCacheBounds),T.count++)}}for(let b=0;b<h;b++){const A=d[b],B=A.count,T=i-A.count,_=A.leftCacheBounds,g=A.rightCacheBounds;let S=0;B!==0&&(S=wt(_)/c);let C=0;T!==0&&(C=wt(g)/c);const M=gn+Yt*(S*B+C*T);M<f&&(r=l,f=M,o=A.candidate)}}else{for(let h=0;h<Y;h++){const b=J[h];b.count=0,b.candidate=y+w+h*w;const A=b.bounds;for(let B=0;B<3;B++)A[B]=1/0,A[B+3]=-1/0}for(let h=u;h<p;h+=6){let B=~~((t[h+2*l]-y)/w);B>=Y&&(B=Y-1);const T=J[B];T.count++,Ct(h,t,T.bounds)}const d=J[Y-1];Mn(d.bounds,d.rightCacheBounds);for(let h=Y-2;h>=0;h--){const b=J[h],A=J[h+1];Sn(b.bounds,A.rightCacheBounds,b.rightCacheBounds)}let m=0;for(let h=0;h<Y-1;h++){const b=J[h],A=b.count,B=b.bounds,_=J[h+1].rightCacheBounds;A!==0&&(m===0?Mn(B,Ut):Sn(B,Ut,Ut)),m+=A;let g=0,S=0;m!==0&&(g=wt(Ut)/c);const C=i-m;C!==0&&(S=wt(_)/c);const M=gn+Yt*(g*m+S*C);M<f&&(r=l,f=M,o=b.candidate)}}}}else console.warn("MeshBVH: Invalid build strategy value ".concat(a," used."));return{axis:r,pos:o}}function we(e,n,t,s){let i=0;for(let a=n,r=n+t;a<r;a++)i+=e[a*6+s*2];return i/t}class Qt{constructor(){this.boundingData=new Float32Array(6)}}function Ae(e,n,t,s,i,a){let r=s,o=s+i-1;const c=a.pos,f=a.axis*2;for(;;){for(;r<=o&&t[r*6+f]<c;)r++;for(;r<=o&&t[o*6+f]>=c;)o--;if(r<o){for(let u=0;u<3;u++){let p=n[r*3+u];n[r*3+u]=n[o*3+u],n[o*3+u]=p}for(let u=0;u<6;u++){let p=t[r*6+u];t[r*6+u]=t[o*6+u],t[o*6+u]=p}r++,o--}else return r}}function Te(e,n,t,s,i,a){let r=s,o=s+i-1;const c=a.pos,f=a.axis*2;for(;;){for(;r<=o&&t[r*6+f]<c;)r++;for(;r<=o&&t[o*6+f]>=c;)o--;if(r<o){let u=e[r];e[r]=e[o],e[o]=u;for(let p=0;p<6;p++){let l=t[r*6+p];t[r*6+p]=t[o*6+p],t[o*6+p]=l}r++,o--}else return r}}function I(e,n){return n[e+15]===65535}function N(e,n){return n[e+6]}function q(e,n){return n[e+14]}function $(e){return e+8}function k(e,n){return n[e+6]}function Yn(e,n){return n[e+7]}let Zn,_t,kt,Kn;const be=Math.pow(2,32);function on(e){return e.count?1:1+on(e.left)+on(e.right)}function Be(e,n,t){return Zn=new Float32Array(t),_t=new Uint32Array(t),kt=new Uint16Array(t),Kn=new Uint8Array(t),cn(e,n)}function cn(e,n){const t=e/4,s=e/2,i=!!n.count,a=n.boundingData;for(let r=0;r<6;r++)Zn[t+r]=a[r];if(i)if(n.buffer){const r=n.buffer;Kn.set(new Uint8Array(r),e);for(let o=e,c=e+r.byteLength;o<c;o+=Mt){const f=o/2;I(f,kt)||(_t[o/4+6]+=t)}return e+r.byteLength}else{const r=n.offset,o=n.count;return _t[t+6]=r,kt[s+14]=o,kt[s+15]=Ht,e+Mt}else{const r=n.left,o=n.right,c=n.splitAxis;let f;if(f=cn(e+Mt,r),f/4>be)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return _t[t+6]=f/4,f=cn(f,o),_t[t+7]=c,f}}function Pe(e,n){const t=(e.index?e.index.count:e.attributes.position.count)/3,s=t>2**16,i=s?4:2,a=n?new SharedArrayBuffer(t*i):new ArrayBuffer(t*i),r=s?new Uint32Array(a):new Uint16Array(a);for(let o=0,c=r.length;o<c;o++)r[o]=o;return r}function ge(e,n,t,s,i){const{maxDepth:a,verbose:r,maxLeafTris:o,strategy:c,onProgress:f,indirect:u}=i,p=e._indirectBuffer,l=e.geometry,y=l.index?l.index.array:null,x=u?Te:Ae,P=dt(l),w=new Float32Array(6);let d=!1;const m=new Qt;return Kt(n,t,s,m.boundingData,w),b(m,t,s,w),m;function h(A){f&&f(A/P)}function b(A,B,T,_=null,g=0){if(!d&&g>=a&&(d=!0,r&&(console.warn("MeshBVH: Max depth of ".concat(a," reached when generating BVH. Consider increasing maxDepth.")),console.warn(l))),T<=o||g>=a)return h(B+T),A.offset=B,A.count=T,A;const S=xe(A.boundingData,_,n,B,T,c);if(S.axis===-1)return h(B+T),A.offset=B,A.count=T,A;const C=x(p,y,n,B,T,S);if(C===B||C===B+T)h(B+T),A.offset=B,A.count=T;else{A.splitAxis=S.axis;const M=new Qt,U=B,F=C-B;A.left=M,Kt(n,U,F,M.boundingData,w),b(M,U,F,w,g+1);const v=new Qt,R=C,Q=T-F;A.right=v,Kt(n,R,Q,v.boundingData,w),b(v,R,Q,w,g+1)}return A}}function _e(e,n){const t=e.geometry;n.indirect&&(e._indirectBuffer=Pe(t,n.useSharedArrayBuffer),de(t)&&!n.verbose&&console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),e._indirectBuffer||ye(t,n);const s=n.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=me(t),a=n.indirect?jn(t):Wn(t);e._roots=a.map(r=>{const o=ge(e,i,r.offset,r.count,n),c=on(o),f=new s(Mt*c);return Be(0,o,f),f})}class K{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(n,t){let s=1/0,i=-1/0;for(let a=0,r=n.length;a<r;a++){const c=n[a][t];s=c<s?c:s,i=c>i?c:i}this.min=s,this.max=i}setFromPoints(n,t){let s=1/0,i=-1/0;for(let a=0,r=t.length;a<r;a++){const o=t[a],c=n.dot(o);s=c<s?c:s,i=c>i?c:i}this.min=s,this.max=i}isSeparated(n){return this.min>n.max||n.min>this.max}}K.prototype.setFromBox=function(){const e=new L;return function(t,s){const i=s.min,a=s.max;let r=1/0,o=-1/0;for(let c=0;c<=1;c++)for(let f=0;f<=1;f++)for(let u=0;u<=1;u++){e.x=i.x*c+a.x*(1-c),e.y=i.y*f+a.y*(1-f),e.z=i.z*u+a.z*(1-u);const p=t.dot(e);r=Math.min(p,r),o=Math.max(p,o)}this.min=r,this.max=o}}();const Me=function(){const e=new L,n=new L,t=new L;return function(i,a,r){const o=i.start,c=e,f=a.start,u=n;t.subVectors(o,f),e.subVectors(i.end,i.start),n.subVectors(a.end,a.start);const p=t.dot(u),l=u.dot(c),y=u.dot(u),x=t.dot(c),w=c.dot(c)*y-l*l;let d,m;w!==0?d=(p*l-x*y)/w:d=0,m=(p+d*l)/y,r.x=d,r.y=m}}(),hn=function(){const e=new et,n=new L,t=new L;return function(i,a,r,o){Me(i,a,e);let c=e.x,f=e.y;if(c>=0&&c<=1&&f>=0&&f<=1){i.at(c,r),a.at(f,o);return}else if(c>=0&&c<=1){f<0?a.at(0,o):a.at(1,o),i.closestPointToPoint(o,!0,r);return}else if(f>=0&&f<=1){c<0?i.at(0,r):i.at(1,r),a.closestPointToPoint(r,!0,o);return}else{let u;c<0?u=i.start:u=i.end;let p;f<0?p=a.start:p=a.end;const l=n,y=t;if(i.closestPointToPoint(p,!0,n),a.closestPointToPoint(u,!0,t),l.distanceToSquared(p)<=y.distanceToSquared(u)){r.copy(l),o.copy(p);return}else{r.copy(u),o.copy(y);return}}}}(),Se=function(){const e=new L,n=new L,t=new $n,s=new Z;return function(a,r){const{radius:o,center:c}=a,{a:f,b:u,c:p}=r;if(s.start=f,s.end=u,s.closestPointToPoint(c,!0,e).distanceTo(c)<=o||(s.start=f,s.end=p,s.closestPointToPoint(c,!0,e).distanceTo(c)<=o)||(s.start=u,s.end=p,s.closestPointToPoint(c,!0,e).distanceTo(c)<=o))return!0;const P=r.getPlane(t);if(Math.abs(P.distanceToPoint(c))<=o){const d=P.projectPoint(c,n);if(r.containsPoint(d))return!0}return!1}}(),Ce=1e-15;function Jt(e){return Math.abs(e)<Ce}class j extends gt{constructor(...n){super(...n),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new L),this.satBounds=new Array(4).fill().map(()=>new K),this.points=[this.a,this.b,this.c],this.sphere=new ne,this.plane=new $n,this.needsUpdate=!0}intersectsSphere(n){return Se(n,this)}update(){const n=this.a,t=this.b,s=this.c,i=this.points,a=this.satAxes,r=this.satBounds,o=a[0],c=r[0];this.getNormal(o),c.setFromPoints(o,i);const f=a[1],u=r[1];f.subVectors(n,t),u.setFromPoints(f,i);const p=a[2],l=r[2];p.subVectors(t,s),l.setFromPoints(p,i);const y=a[3],x=r[3];y.subVectors(s,n),x.setFromPoints(y,i),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(o,n),this.needsUpdate=!1}}j.prototype.closestPointToSegment=function(){const e=new L,n=new L,t=new Z;return function(i,a=null,r=null){const{start:o,end:c}=i,f=this.points;let u,p=1/0;for(let l=0;l<3;l++){const y=(l+1)%3;t.start.copy(f[l]),t.end.copy(f[y]),hn(t,i,e,n),u=e.distanceToSquared(n),u<p&&(p=u,a&&a.copy(e),r&&r.copy(n))}return this.closestPointToPoint(o,e),u=o.distanceToSquared(e),u<p&&(p=u,a&&a.copy(e),r&&r.copy(o)),this.closestPointToPoint(c,e),u=c.distanceToSquared(e),u<p&&(p=u,a&&a.copy(e),r&&r.copy(c)),Math.sqrt(p)}}();j.prototype.intersectsTriangle=function(){const e=new j,n=new Array(3),t=new Array(3),s=new K,i=new K,a=new L,r=new L,o=new L,c=new L,f=new L,u=new Z,p=new Z,l=new Z,y=new L;function x(P,w,d){const m=P.points;let h=0,b=-1;for(let A=0;A<3;A++){const{start:B,end:T}=u;B.copy(m[A]),T.copy(m[(A+1)%3]),u.delta(r);const _=Jt(w.distanceToPoint(B));if(Jt(w.normal.dot(r))&&_){d.copy(u),h=2;break}const g=w.intersectLine(u,y);if(!g&&_&&y.copy(B),(g||_)&&!Jt(y.distanceTo(T))){if(h<=1)(h===1?d.start:d.end).copy(y),_&&(b=h);else if(h>=2){(b===1?d.start:d.end).copy(y),h=2;break}if(h++,h===2&&b===-1)break}}return h}return function(w,d=null,m=!1){this.needsUpdate&&this.update(),w.isExtendedTriangle?w.needsUpdate&&w.update():(e.copy(w),e.update(),w=e);const h=this.plane,b=w.plane;if(Math.abs(h.normal.dot(b.normal))>1-1e-10){const A=this.satBounds,B=this.satAxes;t[0]=w.a,t[1]=w.b,t[2]=w.c;for(let g=0;g<4;g++){const S=A[g],C=B[g];if(s.setFromPoints(C,t),S.isSeparated(s))return!1}const T=w.satBounds,_=w.satAxes;n[0]=this.a,n[1]=this.b,n[2]=this.c;for(let g=0;g<4;g++){const S=T[g],C=_[g];if(s.setFromPoints(C,n),S.isSeparated(s))return!1}for(let g=0;g<4;g++){const S=B[g];for(let C=0;C<4;C++){const M=_[C];if(a.crossVectors(S,M),s.setFromPoints(a,n),i.setFromPoints(a,t),s.isSeparated(i))return!1}}return d&&(m||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),d.start.set(0,0,0),d.end.set(0,0,0)),!0}else{const A=x(this,b,p);if(A===1&&w.containsPoint(p.end))return d&&(d.start.copy(p.end),d.end.copy(p.end)),!0;if(A!==2)return!1;const B=x(w,h,l);if(B===1&&this.containsPoint(l.end))return d&&(d.start.copy(l.end),d.end.copy(l.end)),!0;if(B!==2)return!1;if(p.delta(o),l.delta(c),o.dot(c)<0){let U=l.start;l.start=l.end,l.end=U}const T=p.start.dot(o),_=p.end.dot(o),g=l.start.dot(o),S=l.end.dot(o),C=_<g,M=T<S;return T!==S&&g!==_&&C===M?!1:(d&&(f.subVectors(p.start,l.start),f.dot(o)>0?d.start.copy(p.start):d.start.copy(l.start),f.subVectors(p.end,l.end),f.dot(o)<0?d.end.copy(p.end):d.end.copy(l.end)),!0)}}}();j.prototype.distanceToPoint=function(){const e=new L;return function(t){return this.closestPointToPoint(t,e),t.distanceTo(e)}}();j.prototype.distanceToTriangle=function(){const e=new L,n=new L,t=["a","b","c"],s=new Z,i=new Z;return function(r,o=null,c=null){const f=o||c?s:null;if(this.intersectsTriangle(r,f))return(o||c)&&(o&&f.getCenter(o),c&&f.getCenter(c)),0;let u=1/0;for(let p=0;p<3;p++){let l;const y=t[p],x=r[y];this.closestPointToPoint(x,e),l=x.distanceToSquared(e),l<u&&(u=l,o&&o.copy(e),c&&c.copy(x));const P=this[y];r.closestPointToPoint(P,e),l=P.distanceToSquared(e),l<u&&(u=l,o&&o.copy(P),c&&c.copy(e))}for(let p=0;p<3;p++){const l=t[p],y=t[(p+1)%3];s.set(this[l],this[y]);for(let x=0;x<3;x++){const P=t[x],w=t[(x+1)%3];i.set(r[P],r[w]),hn(s,i,e,n);const d=e.distanceToSquared(n);d<u&&(u=d,o&&o.copy(e),c&&c.copy(n))}}return Math.sqrt(u)}}();class V{constructor(n,t,s){this.isOrientedBox=!0,this.min=new L,this.max=new L,this.matrix=new tt,this.invMatrix=new tt,this.points=new Array(8).fill().map(()=>new L),this.satAxes=new Array(3).fill().map(()=>new L),this.satBounds=new Array(3).fill().map(()=>new K),this.alignedSatBounds=new Array(3).fill().map(()=>new K),this.needsUpdate=!1,n&&this.min.copy(n),t&&this.max.copy(t),s&&this.matrix.copy(s)}set(n,t,s){this.min.copy(n),this.max.copy(t),this.matrix.copy(s),this.needsUpdate=!0}copy(n){this.min.copy(n.min),this.max.copy(n.max),this.matrix.copy(n.matrix),this.needsUpdate=!0}}V.prototype.update=function(){return function(){const n=this.matrix,t=this.min,s=this.max,i=this.points;for(let f=0;f<=1;f++)for(let u=0;u<=1;u++)for(let p=0;p<=1;p++){const l=1*f|2*u|4*p,y=i[l];y.x=f?s.x:t.x,y.y=u?s.y:t.y,y.z=p?s.z:t.z,y.applyMatrix4(n)}const a=this.satBounds,r=this.satAxes,o=i[0];for(let f=0;f<3;f++){const u=r[f],p=a[f],l=1<<f,y=i[l];u.subVectors(o,y),p.setFromPoints(u,i)}const c=this.alignedSatBounds;c[0].setFromPointsField(i,"x"),c[1].setFromPointsField(i,"y"),c[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();V.prototype.intersectsBox=function(){const e=new K;return function(t){this.needsUpdate&&this.update();const s=t.min,i=t.max,a=this.satBounds,r=this.satAxes,o=this.alignedSatBounds;if(e.min=s.x,e.max=i.x,o[0].isSeparated(e)||(e.min=s.y,e.max=i.y,o[1].isSeparated(e))||(e.min=s.z,e.max=i.z,o[2].isSeparated(e)))return!1;for(let c=0;c<3;c++){const f=r[c],u=a[c];if(e.setFromBox(f,t),u.isSeparated(e))return!1}return!0}}();V.prototype.intersectsTriangle=function(){const e=new j,n=new Array(3),t=new K,s=new K,i=new L;return function(r){this.needsUpdate&&this.update(),r.isExtendedTriangle?r.needsUpdate&&r.update():(e.copy(r),e.update(),r=e);const o=this.satBounds,c=this.satAxes;n[0]=r.a,n[1]=r.b,n[2]=r.c;for(let l=0;l<3;l++){const y=o[l],x=c[l];if(t.setFromPoints(x,n),y.isSeparated(t))return!1}const f=r.satBounds,u=r.satAxes,p=this.points;for(let l=0;l<3;l++){const y=f[l],x=u[l];if(t.setFromPoints(x,p),y.isSeparated(t))return!1}for(let l=0;l<3;l++){const y=c[l];for(let x=0;x<4;x++){const P=u[x];if(i.crossVectors(y,P),t.setFromPoints(i,n),s.setFromPoints(i,p),t.isSeparated(s))return!1}}return!0}}();V.prototype.closestPointToPoint=function(){return function(n,t){return this.needsUpdate&&this.update(),t.copy(n).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),t}}();V.prototype.distanceToPoint=function(){const e=new L;return function(t){return this.closestPointToPoint(t,e),t.distanceTo(e)}}();V.prototype.distanceToBox=function(){const e=["x","y","z"],n=new Array(12).fill().map(()=>new Z),t=new Array(12).fill().map(()=>new Z),s=new L,i=new L;return function(r,o=0,c=null,f=null){if(this.needsUpdate&&this.update(),this.intersectsBox(r))return(c||f)&&(r.getCenter(i),this.closestPointToPoint(i,s),r.closestPointToPoint(s,i),c&&c.copy(s),f&&f.copy(i)),0;const u=o*o,p=r.min,l=r.max,y=this.points;let x=1/0;for(let w=0;w<8;w++){const d=y[w];i.copy(d).clamp(p,l);const m=d.distanceToSquared(i);if(m<x&&(x=m,c&&c.copy(d),f&&f.copy(i),m<u))return Math.sqrt(m)}let P=0;for(let w=0;w<3;w++)for(let d=0;d<=1;d++)for(let m=0;m<=1;m++){const h=(w+1)%3,b=(w+2)%3,A=d<<h|m<<b,B=1<<w|d<<h|m<<b,T=y[A],_=y[B];n[P].set(T,_);const S=e[w],C=e[h],M=e[b],U=t[P],F=U.start,v=U.end;F[S]=p[S],F[C]=d?p[C]:l[C],F[M]=m?p[M]:l[C],v[S]=l[S],v[C]=d?p[C]:l[C],v[M]=m?p[M]:l[C],P++}for(let w=0;w<=1;w++)for(let d=0;d<=1;d++)for(let m=0;m<=1;m++){i.x=w?l.x:p.x,i.y=d?l.y:p.y,i.z=m?l.z:p.z,this.closestPointToPoint(i,s);const h=i.distanceToSquared(s);if(h<x&&(x=h,c&&c.copy(s),f&&f.copy(i),h<u))return Math.sqrt(h)}for(let w=0;w<12;w++){const d=n[w];for(let m=0;m<12;m++){const h=t[m];hn(d,h,s,i);const b=s.distanceToSquared(i);if(b<x&&(x=b,c&&c.copy(s),f&&f.copy(i),b<u))return Math.sqrt(b)}}return Math.sqrt(x)}}();class xn{constructor(n){this._getNewPrimitive=n,this._primitives=[]}getPrimitive(){const n=this._primitives;return n.length===0?this._getNewPrimitive():n.pop()}releasePrimitive(n){this._primitives.push(n)}}class Ue extends xn{constructor(){super(()=>new j)}}const X=new Ue;class Le{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const n=[];let t=null;this.setBuffer=s=>{t&&n.push(t),t=s,this.float32Array=new Float32Array(s),this.uint16Array=new Uint16Array(s),this.uint32Array=new Uint32Array(s)},this.clearBuffer=()=>{t=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,n.length!==0&&this.setBuffer(n.pop())}}}const z=new Le;let O,yt;const st=[],Lt=new xn(()=>new W);function Fe(e,n,t,s,i,a){O=Lt.getPrimitive(),yt=Lt.getPrimitive(),st.push(O,yt),z.setBuffer(e._roots[n]);const r=an(0,e.geometry,t,s,i,a);z.clearBuffer(),Lt.releasePrimitive(O),Lt.releasePrimitive(yt),st.pop(),st.pop();const o=st.length;return o>0&&(yt=st[o-1],O=st[o-2]),r}function an(e,n,t,s,i=null,a=0,r=0){const{float32Array:o,uint16Array:c,uint32Array:f}=z;let u=e*2;if(I(u,c)){const l=N(e,f),y=q(u,c);return E(e,o,O),s(l,y,!1,r,a+e,O)}else{let S=function(M){const{uint16Array:U,uint32Array:F}=z;let v=M*2;for(;!I(v,U);)M=$(M),v=M*2;return N(M,F)},C=function(M){const{uint16Array:U,uint32Array:F}=z;let v=M*2;for(;!I(v,U);)M=k(M,F),v=M*2;return N(M,F)+q(v,U)};const l=$(e),y=k(e,f);let x=l,P=y,w,d,m,h;if(i&&(m=O,h=yt,E(x,o,m),E(P,o,h),w=i(m),d=i(h),d<w)){x=y,P=l;const M=w;w=d,d=M,m=h}m||(m=O,E(x,o,m));const b=I(x*2,c),A=t(m,b,w,r+1,a+x);let B;if(A===Pn){const M=S(x),F=C(x)-M;B=s(M,F,!0,r+1,a+x,m)}else B=A&&an(x,n,t,s,i,a,r+1);if(B)return!0;h=yt,E(P,o,h);const T=I(P*2,c),_=t(h,T,d,r+1,a+P);let g;if(_===Pn){const M=S(P),F=C(P)-M;g=s(M,F,!0,r+1,a+P,h)}else g=_&&an(P,n,t,s,i,a,r+1);return!!g}}const At=new L,Gt=new L;function ve(e,n,t={},s=0,i=1/0){const a=s*s,r=i*i;let o=1/0,c=null;if(e.shapecast({boundsTraverseOrder:u=>(At.copy(n).clamp(u.min,u.max),At.distanceToSquared(n)),intersectsBounds:(u,p,l)=>l<o&&l<r,intersectsTriangle:(u,p)=>{u.closestPointToPoint(n,At);const l=n.distanceToSquared(At);return l<o&&(Gt.copy(At),o=l,c=p),l<a}}),o===1/0)return null;const f=Math.sqrt(o);return t.point?t.point.copy(Gt):t.point=Gt.clone(),t.distance=f,t.faceIndex=c,t}const it=new L,rt=new L,ot=new L,Ft=new et,vt=new et,zt=new et,Cn=new L,Un=new L,Ln=new L,Et=new L;function ze(e,n,t,s,i,a){let r;return a===ee?r=e.intersectTriangle(s,t,n,!0,i):r=e.intersectTriangle(n,t,s,a!==kn,i),r===null?null:{distance:e.origin.distanceTo(i),point:i.clone()}}function Ee(e,n,t,s,i,a,r,o,c){it.fromBufferAttribute(n,a),rt.fromBufferAttribute(n,r),ot.fromBufferAttribute(n,o);const f=ze(e,it,rt,ot,Et,c);if(f){s&&(Ft.fromBufferAttribute(s,a),vt.fromBufferAttribute(s,r),zt.fromBufferAttribute(s,o),f.uv=gt.getInterpolation(Et,it,rt,ot,Ft,vt,zt,new et)),i&&(Ft.fromBufferAttribute(i,a),vt.fromBufferAttribute(i,r),zt.fromBufferAttribute(i,o),f.uv1=gt.getInterpolation(Et,it,rt,ot,Ft,vt,zt,new et)),t&&(Cn.fromBufferAttribute(t,a),Un.fromBufferAttribute(t,r),Ln.fromBufferAttribute(t,o),f.normal=gt.getInterpolation(Et,it,rt,ot,Cn,Un,Ln,new L),f.normal.dot(e.direction)>0&&f.normal.multiplyScalar(-1));const u={a,b:r,c:o,normal:new L,materialIndex:0};gt.getNormal(it,rt,ot,u.normal),f.face=u,f.faceIndex=a}return f}function jt(e,n,t,s,i){const a=s*3;let r=a+0,o=a+1,c=a+2;const f=e.index;e.index&&(r=f.getX(r),o=f.getX(o),c=f.getX(c));const{position:u,normal:p,uv:l,uv1:y}=e.attributes,x=Ee(t,u,p,l,y,r,o,c,n);return x?(x.faceIndex=s,i&&i.push(x),x):null}function D(e,n,t,s){const i=e.a,a=e.b,r=e.c;let o=n,c=n+1,f=n+2;t&&(o=t.getX(o),c=t.getX(c),f=t.getX(f)),i.x=s.getX(o),i.y=s.getY(o),i.z=s.getZ(o),a.x=s.getX(c),a.y=s.getY(c),a.z=s.getZ(c),r.x=s.getX(f),r.y=s.getY(f),r.z=s.getZ(f)}function Re(e,n,t,s,i,a){const{geometry:r,_indirectBuffer:o}=e;for(let c=s,f=s+i;c<f;c++)jt(r,n,t,c,a)}function De(e,n,t,s,i){const{geometry:a,_indirectBuffer:r}=e;let o=1/0,c=null;for(let f=s,u=s+i;f<u;f++){let p;p=jt(a,n,t,f),p&&p.distance<o&&(c=p,o=p.distance)}return c}function Ve(e,n,t,s,i,a,r){const{geometry:o}=t,{index:c}=o,f=o.attributes.position;for(let u=e,p=n+e;u<p;u++){let l;if(l=u,D(r,l*3,c,f),r.needsUpdate=!0,s(r,l,i,a))return!0}return!1}function Ie(e,n=null){n&&Array.isArray(n)&&(n=new Set(n));const t=e.geometry,s=t.index?t.index.array:null,i=t.attributes.position;let a,r,o,c,f=0;const u=e._roots;for(let l=0,y=u.length;l<y;l++)a=u[l],r=new Uint32Array(a),o=new Uint16Array(a),c=new Float32Array(a),p(0,f),f+=a.byteLength;function p(l,y,x=!1){const P=l*2;if(o[P+15]===Ht){const d=r[l+6],m=o[P+14];let h=1/0,b=1/0,A=1/0,B=-1/0,T=-1/0,_=-1/0;for(let g=3*d,S=3*(d+m);g<S;g++){let C=s[g];const M=i.getX(C),U=i.getY(C),F=i.getZ(C);M<h&&(h=M),M>B&&(B=M),U<b&&(b=U),U>T&&(T=U),F<A&&(A=F),F>_&&(_=F)}return c[l+0]!==h||c[l+1]!==b||c[l+2]!==A||c[l+3]!==B||c[l+4]!==T||c[l+5]!==_?(c[l+0]=h,c[l+1]=b,c[l+2]=A,c[l+3]=B,c[l+4]=T,c[l+5]=_,!0):!1}else{const d=l+8,m=r[l+6],h=d+y,b=m+y;let A=x,B=!1,T=!1;n?A||(B=n.has(h),T=n.has(b),A=!B&&!T):(B=!0,T=!0);const _=A||B,g=A||T;let S=!1;_&&(S=p(d,y,A));let C=!1;g&&(C=p(m,y,A));const M=S||C;if(M)for(let U=0;U<3;U++){const F=d+U,v=m+U,R=c[F],Q=c[F+3],mt=c[v],ht=c[v+3];c[l+U]=R<mt?R:mt,c[l+U+3]=Q>ht?Q:ht}return M}}}const Fn=new W;function nt(e,n,t,s){return E(e,n,Fn),t.intersectBox(Fn,s)}function Ne(e,n,t,s,i,a){const{geometry:r,_indirectBuffer:o}=e;for(let c=s,f=s+i;c<f;c++){let u=o?o[c]:c;jt(r,n,t,u,a)}}function qe(e,n,t,s,i){const{geometry:a,_indirectBuffer:r}=e;let o=1/0,c=null;for(let f=s,u=s+i;f<u;f++){let p;p=jt(a,n,t,r?r[f]:f),p&&p.distance<o&&(c=p,o=p.distance)}return c}function $e(e,n,t,s,i,a,r){const{geometry:o}=t,{index:c}=o,f=o.attributes.position;for(let u=e,p=n+e;u<p;u++){let l;if(l=t.resolveTriangleIndex(u),D(r,l*3,c,f),r.needsUpdate=!0,s(r,l,i,a))return!0}return!1}const vn=new L;function ke(e,n,t,s,i){z.setBuffer(e._roots[n]),ln(0,e,t,s,i),z.clearBuffer()}function ln(e,n,t,s,i){const{float32Array:a,uint16Array:r,uint32Array:o}=z,c=e*2;if(I(c,r)){const u=N(e,o),p=q(c,r);Re(n,t,s,u,p,i)}else{const u=$(e);nt(u,a,s,vn)&&ln(u,n,t,s,i);const p=k(e,o);nt(p,a,s,vn)&&ln(p,n,t,s,i)}}const zn=new L,Xe=["x","y","z"];function He(e,n,t,s){z.setBuffer(e._roots[n]);const i=un(0,e,t,s);return z.clearBuffer(),i}function un(e,n,t,s){const{float32Array:i,uint16Array:a,uint32Array:r}=z;let o=e*2;if(I(o,a)){const f=N(e,r),u=q(o,a);return De(n,t,s,f,u)}else{const f=Yn(e,r),u=Xe[f],l=s.direction[u]>=0;let y,x;l?(y=$(e),x=k(e,r)):(y=k(e,r),x=$(e));const w=nt(y,i,s,zn)?un(y,n,t,s):null;if(w){const h=w.point[u];if(l?h<=i[x+f]:h>=i[x+f+3])return w}const m=nt(x,i,s,zn)?un(x,n,t,s):null;return w&&m?w.distance<=m.distance?w:m:w||m||null}}const Rt=new W,ct=new j,at=new j,Tt=new tt,En=new V,Dt=new V;function je(e,n,t,s){z.setBuffer(e._roots[n]);const i=fn(0,e,t,s);return z.clearBuffer(),i}function fn(e,n,t,s,i=null){const{float32Array:a,uint16Array:r,uint32Array:o}=z;let c=e*2;if(i===null&&(t.boundingBox||t.computeBoundingBox(),En.set(t.boundingBox.min,t.boundingBox.max,s),i=En),I(c,r)){const u=n.geometry,p=u.index,l=u.attributes.position,y=t.index,x=t.attributes.position,P=N(e,o),w=q(c,r);if(Tt.copy(s).invert(),t.boundsTree)return E(e,a,Dt),Dt.matrix.copy(Tt),Dt.needsUpdate=!0,t.boundsTree.shapecast({intersectsBounds:m=>Dt.intersectsBox(m),intersectsTriangle:m=>{m.a.applyMatrix4(s),m.b.applyMatrix4(s),m.c.applyMatrix4(s),m.needsUpdate=!0;for(let h=P*3,b=(w+P)*3;h<b;h+=3)if(D(at,h,p,l),at.needsUpdate=!0,m.intersectsTriangle(at))return!0;return!1}});for(let d=P*3,m=(w+P)*3;d<m;d+=3){D(ct,d,p,l),ct.a.applyMatrix4(Tt),ct.b.applyMatrix4(Tt),ct.c.applyMatrix4(Tt),ct.needsUpdate=!0;for(let h=0,b=y.count;h<b;h+=3)if(D(at,h,y,x),at.needsUpdate=!0,ct.intersectsTriangle(at))return!0}}else{const u=e+8,p=o[e+6];return E(u,a,Rt),!!(i.intersectsBox(Rt)&&fn(u,n,t,s,i)||(E(p,a,Rt),i.intersectsBox(Rt)&&fn(p,n,t,s,i)))}}const Vt=new tt,Ot=new V,bt=new V,We=new L,Ye=new L,Ze=new L,Ke=new L;function Qe(e,n,t,s={},i={},a=0,r=1/0){n.boundingBox||n.computeBoundingBox(),Ot.set(n.boundingBox.min,n.boundingBox.max,t),Ot.needsUpdate=!0;const o=e.geometry,c=o.attributes.position,f=o.index,u=n.attributes.position,p=n.index,l=X.getPrimitive(),y=X.getPrimitive();let x=We,P=Ye,w=null,d=null;i&&(w=Ze,d=Ke);let m=1/0,h=null,b=null;return Vt.copy(t).invert(),bt.matrix.copy(Vt),e.shapecast({boundsTraverseOrder:A=>Ot.distanceToBox(A),intersectsBounds:(A,B,T)=>T<m&&T<r?(B&&(bt.min.copy(A.min),bt.max.copy(A.max),bt.needsUpdate=!0),!0):!1,intersectsRange:(A,B)=>{if(n.boundsTree)return n.boundsTree.shapecast({boundsTraverseOrder:_=>bt.distanceToBox(_),intersectsBounds:(_,g,S)=>S<m&&S<r,intersectsRange:(_,g)=>{for(let S=_,C=_+g;S<C;S++){D(y,3*S,p,u),y.a.applyMatrix4(t),y.b.applyMatrix4(t),y.c.applyMatrix4(t),y.needsUpdate=!0;for(let M=A,U=A+B;M<U;M++){D(l,3*M,f,c),l.needsUpdate=!0;const F=l.distanceToTriangle(y,x,w);if(F<m&&(P.copy(x),d&&d.copy(w),m=F,h=M,b=S),F<a)return!0}}}});{const T=dt(n);for(let _=0,g=T;_<g;_++){D(y,3*_,p,u),y.a.applyMatrix4(t),y.b.applyMatrix4(t),y.c.applyMatrix4(t),y.needsUpdate=!0;for(let S=A,C=A+B;S<C;S++){D(l,3*S,f,c),l.needsUpdate=!0;const M=l.distanceToTriangle(y,x,w);if(M<m&&(P.copy(x),d&&d.copy(w),m=M,h=S,b=_),M<a)return!0}}}}}),X.releasePrimitive(l),X.releasePrimitive(y),m===1/0?null:(s.point?s.point.copy(P):s.point=P.clone(),s.distance=m,s.faceIndex=h,i&&(i.point?i.point.copy(d):i.point=d.clone(),i.point.applyMatrix4(Vt),P.applyMatrix4(Vt),i.distance=P.sub(i.point).length(),i.faceIndex=b),s)}function Je(e,n=null){n&&Array.isArray(n)&&(n=new Set(n));const t=e.geometry,s=t.index?t.index.array:null,i=t.attributes.position;let a,r,o,c,f=0;const u=e._roots;for(let l=0,y=u.length;l<y;l++)a=u[l],r=new Uint32Array(a),o=new Uint16Array(a),c=new Float32Array(a),p(0,f),f+=a.byteLength;function p(l,y,x=!1){const P=l*2;if(o[P+15]===Ht){const d=r[l+6],m=o[P+14];let h=1/0,b=1/0,A=1/0,B=-1/0,T=-1/0,_=-1/0;for(let g=d,S=d+m;g<S;g++){const C=3*e.resolveTriangleIndex(g);for(let M=0;M<3;M++){let U=C+M;U=s?s[U]:U;const F=i.getX(U),v=i.getY(U),R=i.getZ(U);F<h&&(h=F),F>B&&(B=F),v<b&&(b=v),v>T&&(T=v),R<A&&(A=R),R>_&&(_=R)}}return c[l+0]!==h||c[l+1]!==b||c[l+2]!==A||c[l+3]!==B||c[l+4]!==T||c[l+5]!==_?(c[l+0]=h,c[l+1]=b,c[l+2]=A,c[l+3]=B,c[l+4]=T,c[l+5]=_,!0):!1}else{const d=l+8,m=r[l+6],h=d+y,b=m+y;let A=x,B=!1,T=!1;n?A||(B=n.has(h),T=n.has(b),A=!B&&!T):(B=!0,T=!0);const _=A||B,g=A||T;let S=!1;_&&(S=p(d,y,A));let C=!1;g&&(C=p(m,y,A));const M=S||C;if(M)for(let U=0;U<3;U++){const F=d+U,v=m+U,R=c[F],Q=c[F+3],mt=c[v],ht=c[v+3];c[l+U]=R<mt?R:mt,c[l+U+3]=Q>ht?Q:ht}return M}}}const Rn=new L;function Ge(e,n,t,s,i){z.setBuffer(e._roots[n]),pn(0,e,t,s,i),z.clearBuffer()}function pn(e,n,t,s,i){const{float32Array:a,uint16Array:r,uint32Array:o}=z,c=e*2;if(I(c,r)){const u=N(e,o),p=q(c,r);Ne(n,t,s,u,p,i)}else{const u=$(e);nt(u,a,s,Rn)&&pn(u,n,t,s,i);const p=k(e,o);nt(p,a,s,Rn)&&pn(p,n,t,s,i)}}const Dn=new L,Oe=["x","y","z"];function ts(e,n,t,s){z.setBuffer(e._roots[n]);const i=yn(0,e,t,s);return z.clearBuffer(),i}function yn(e,n,t,s){const{float32Array:i,uint16Array:a,uint32Array:r}=z;let o=e*2;if(I(o,a)){const f=N(e,r),u=q(o,a);return qe(n,t,s,f,u)}else{const f=Yn(e,r),u=Oe[f],l=s.direction[u]>=0;let y,x;l?(y=$(e),x=k(e,r)):(y=k(e,r),x=$(e));const w=nt(y,i,s,Dn)?yn(y,n,t,s):null;if(w){const h=w.point[u];if(l?h<=i[x+f]:h>=i[x+f+3])return w}const m=nt(x,i,s,Dn)?yn(x,n,t,s):null;return w&&m?w.distance<=m.distance?w:m:w||m||null}}const It=new W,lt=new j,ut=new j,Bt=new tt,Vn=new V,Nt=new V;function ns(e,n,t,s){z.setBuffer(e._roots[n]);const i=dn(0,e,t,s);return z.clearBuffer(),i}function dn(e,n,t,s,i=null){const{float32Array:a,uint16Array:r,uint32Array:o}=z;let c=e*2;if(i===null&&(t.boundingBox||t.computeBoundingBox(),Vn.set(t.boundingBox.min,t.boundingBox.max,s),i=Vn),I(c,r)){const u=n.geometry,p=u.index,l=u.attributes.position,y=t.index,x=t.attributes.position,P=N(e,o),w=q(c,r);if(Bt.copy(s).invert(),t.boundsTree)return E(e,a,Nt),Nt.matrix.copy(Bt),Nt.needsUpdate=!0,t.boundsTree.shapecast({intersectsBounds:m=>Nt.intersectsBox(m),intersectsTriangle:m=>{m.a.applyMatrix4(s),m.b.applyMatrix4(s),m.c.applyMatrix4(s),m.needsUpdate=!0;for(let h=P,b=w+P;h<b;h++)if(D(ut,3*n.resolveTriangleIndex(h),p,l),ut.needsUpdate=!0,m.intersectsTriangle(ut))return!0;return!1}});for(let d=P,m=w+P;d<m;d++){const h=n.resolveTriangleIndex(d);D(lt,3*h,p,l),lt.a.applyMatrix4(Bt),lt.b.applyMatrix4(Bt),lt.c.applyMatrix4(Bt),lt.needsUpdate=!0;for(let b=0,A=y.count;b<A;b+=3)if(D(ut,b,y,x),ut.needsUpdate=!0,lt.intersectsTriangle(ut))return!0}}else{const u=e+8,p=o[e+6];return E(u,a,It),!!(i.intersectsBox(It)&&dn(u,n,t,s,i)||(E(p,a,It),i.intersectsBox(It)&&dn(p,n,t,s,i)))}}const qt=new tt,tn=new V,Pt=new V,es=new L,ss=new L,is=new L,rs=new L;function os(e,n,t,s={},i={},a=0,r=1/0){n.boundingBox||n.computeBoundingBox(),tn.set(n.boundingBox.min,n.boundingBox.max,t),tn.needsUpdate=!0;const o=e.geometry,c=o.attributes.position,f=o.index,u=n.attributes.position,p=n.index,l=X.getPrimitive(),y=X.getPrimitive();let x=es,P=ss,w=null,d=null;i&&(w=is,d=rs);let m=1/0,h=null,b=null;return qt.copy(t).invert(),Pt.matrix.copy(qt),e.shapecast({boundsTraverseOrder:A=>tn.distanceToBox(A),intersectsBounds:(A,B,T)=>T<m&&T<r?(B&&(Pt.min.copy(A.min),Pt.max.copy(A.max),Pt.needsUpdate=!0),!0):!1,intersectsRange:(A,B)=>{if(n.boundsTree){const T=n.boundsTree;return T.shapecast({boundsTraverseOrder:_=>Pt.distanceToBox(_),intersectsBounds:(_,g,S)=>S<m&&S<r,intersectsRange:(_,g)=>{for(let S=_,C=_+g;S<C;S++){const M=T.resolveTriangleIndex(S);D(y,3*M,p,u),y.a.applyMatrix4(t),y.b.applyMatrix4(t),y.c.applyMatrix4(t),y.needsUpdate=!0;for(let U=A,F=A+B;U<F;U++){const v=e.resolveTriangleIndex(U);D(l,3*v,f,c),l.needsUpdate=!0;const R=l.distanceToTriangle(y,x,w);if(R<m&&(P.copy(x),d&&d.copy(w),m=R,h=U,b=S),R<a)return!0}}}})}else{const T=dt(n);for(let _=0,g=T;_<g;_++){D(y,3*_,p,u),y.a.applyMatrix4(t),y.b.applyMatrix4(t),y.c.applyMatrix4(t),y.needsUpdate=!0;for(let S=A,C=A+B;S<C;S++){const M=e.resolveTriangleIndex(S);D(l,3*M,f,c),l.needsUpdate=!0;const U=l.distanceToTriangle(y,x,w);if(U<m&&(P.copy(x),d&&d.copy(w),m=U,h=S,b=_),U<a)return!0}}}}}),X.releasePrimitive(l),X.releasePrimitive(y),m===1/0?null:(s.point?s.point.copy(P):s.point=P.clone(),s.distance=m,s.faceIndex=h,i&&(i.point?i.point.copy(d):i.point=d.clone(),i.point.applyMatrix4(qt),P.applyMatrix4(qt),i.distance=P.sub(i.point).length(),i.faceIndex=b),s)}function cs(){return typeof SharedArrayBuffer<"u"}const St=new z.constructor,Xt=new z.constructor,G=new xn(()=>new W),ft=new W,pt=new W,nn=new W,en=new W;let sn=!1;function as(e,n,t,s){if(sn)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");sn=!0;const i=e._roots,a=n._roots;let r,o=0,c=0;const f=new tt().copy(t).invert();for(let u=0,p=i.length;u<p;u++){St.setBuffer(i[u]),c=0;const l=G.getPrimitive();E(0,St.float32Array,l),l.applyMatrix4(f);for(let y=0,x=a.length;y<x&&(Xt.setBuffer(a[u]),r=H(0,0,t,f,s,o,c,0,0,l),Xt.clearBuffer(),c+=a[y].length,!r);y++);if(G.releasePrimitive(l),St.clearBuffer(),o+=i[u].length,r)break}return sn=!1,r}function H(e,n,t,s,i,a=0,r=0,o=0,c=0,f=null,u=!1){let p,l;u?(p=Xt,l=St):(p=St,l=Xt);const y=p.float32Array,x=p.uint32Array,P=p.uint16Array,w=l.float32Array,d=l.uint32Array,m=l.uint16Array,h=e*2,b=n*2,A=I(h,P),B=I(b,m);let T=!1;if(B&&A)u?T=i(N(n,d),q(n*2,m),N(e,x),q(e*2,P),c,r+n,o,a+e):T=i(N(e,x),q(e*2,P),N(n,d),q(n*2,m),o,a+e,c,r+n);else if(B){const _=G.getPrimitive();E(n,w,_),_.applyMatrix4(t);const g=$(e),S=k(e,x);E(g,y,ft),E(S,y,pt);const C=_.intersectsBox(ft),M=_.intersectsBox(pt);T=C&&H(n,g,s,t,i,r,a,c,o+1,_,!u)||M&&H(n,S,s,t,i,r,a,c,o+1,_,!u),G.releasePrimitive(_)}else{const _=$(n),g=k(n,d);E(_,w,nn),E(g,w,en);const S=f.intersectsBox(nn),C=f.intersectsBox(en);if(S&&C)T=H(e,_,t,s,i,a,r,o,c+1,f,u)||H(e,g,t,s,i,a,r,o,c+1,f,u);else if(S)if(A)T=H(e,_,t,s,i,a,r,o,c+1,f,u);else{const M=G.getPrimitive();M.copy(nn).applyMatrix4(t);const U=$(e),F=k(e,x);E(U,y,ft),E(F,y,pt);const v=M.intersectsBox(ft),R=M.intersectsBox(pt);T=v&&H(_,U,s,t,i,r,a,c,o+1,M,!u)||R&&H(_,F,s,t,i,r,a,c,o+1,M,!u),G.releasePrimitive(M)}else if(C)if(A)T=H(e,g,t,s,i,a,r,o,c+1,f,u);else{const M=G.getPrimitive();M.copy(en).applyMatrix4(t);const U=$(e),F=k(e,x);E(U,y,ft),E(F,y,pt);const v=M.intersectsBox(ft),R=M.intersectsBox(pt);T=v&&H(g,U,s,t,i,r,a,c,o+1,M,!u)||R&&H(g,F,s,t,i,r,a,c,o+1,M,!u),G.releasePrimitive(M)}}return T}const $t=new V,In=new W,ls={strategy:Hn,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0};class wn{static serialize(n,t={}){t=xt({cloneBuffers:!0},t);const s=n.geometry,i=n._roots,a=n._indirectBuffer,r=s.getIndex();let o;return t.cloneBuffers?o={roots:i.map(c=>c.slice()),index:r.array.slice(),indirectBuffer:a?a.slice():null}:o={roots:i,index:r.array,indirectBuffer:a},o}static deserialize(n,t,s={}){s=xt({setIndex:!0,indirect:!!n.indirectBuffer},s);const{index:i,roots:a,indirectBuffer:r}=n,o=new wn(t,Wt(xt({},s),{[Zt]:!0}));if(o._roots=a,o._indirectBuffer=r||null,s.setIndex){const c=t.getIndex();if(c===null){const f=new mn(n.index,1,!1);t.setIndex(f)}else c.array!==i&&(c.array.set(i),c.needsUpdate=!0)}return o}get indirect(){return!!this._indirectBuffer}constructor(n,t={}){if(n.isBufferGeometry){if(n.index&&n.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t=Object.assign(Wt(xt({},ls),{[Zt]:!1}),t),t.useSharedArrayBuffer&&!cs())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=n,this._roots=null,this._indirectBuffer=null,t[Zt]||(_e(this,t),!n.boundingBox&&t.setBoundingBox&&(n.boundingBox=this.getBoundingBox(new W)));const{_indirectBuffer:s}=this;this.resolveTriangleIndex=t.indirect?i=>s[i]:i=>i}refit(n=null){return(this.indirect?Je:Ie)(this,n)}traverse(n,t=0){const s=this._roots[t],i=new Uint32Array(s),a=new Uint16Array(s);r(0);function r(o,c=0){const f=o*2,u=a[f+15]===Ht;if(u){const p=i[o+6],l=a[f+14];n(c,u,new Float32Array(s,o*4,6),p,l)}else{const p=o+Mt/4,l=i[o+6],y=i[o+7];n(c,u,new Float32Array(s,o*4,6),y)||(r(p,c+1),r(l,c+1))}}}raycast(n,t=bn){const s=this._roots,i=this.geometry,a=[],r=t.isMaterial,o=Array.isArray(t),c=i.groups,f=r?t.side:t,u=this.indirect?Ge:ke;for(let p=0,l=s.length;p<l;p++){const y=o?t[c[p].materialIndex].side:f,x=a.length;if(u(this,p,y,n,a),o){const P=c[p].materialIndex;for(let w=x,d=a.length;w<d;w++)a[w].face.materialIndex=P}}return a}raycastFirst(n,t=bn){const s=this._roots,i=this.geometry,a=t.isMaterial,r=Array.isArray(t);let o=null;const c=i.groups,f=a?t.side:t,u=this.indirect?ts:He;for(let p=0,l=s.length;p<l;p++){const y=r?t[c[p].materialIndex].side:f,x=u(this,p,y,n);x!=null&&(o==null||x.distance<o.distance)&&(o=x,r&&(x.face.materialIndex=c[p].materialIndex))}return o}intersectsGeometry(n,t){let s=!1;const i=this._roots,a=this.indirect?ns:je;for(let r=0,o=i.length;r<o&&(s=a(this,r,n,t),!s);r++);return s}shapecast(n){const t=X.getPrimitive(),s=this.indirect?$e:Ve;let{boundsTraverseOrder:i,intersectsBounds:a,intersectsRange:r,intersectsTriangle:o}=n;if(r&&o){const p=r;r=(l,y,x,P,w)=>p(l,y,x,P,w)?!0:s(l,y,this,o,x,P,t)}else r||(o?r=(p,l,y,x)=>s(p,l,this,o,y,x,t):r=(p,l,y)=>y);let c=!1,f=0;const u=this._roots;for(let p=0,l=u.length;p<l;p++){const y=u[p];if(c=Fe(this,p,a,r,i,f),c)break;f+=y.byteLength}return X.releasePrimitive(t),c}bvhcast(n,t,s){let{intersectsRanges:i,intersectsTriangles:a}=s;const r=X.getPrimitive(),o=this.geometry.index,c=this.geometry.attributes.position,f=this.indirect?x=>{const P=this.resolveTriangleIndex(x);D(r,P*3,o,c)}:x=>{D(r,x*3,o,c)},u=X.getPrimitive(),p=n.geometry.index,l=n.geometry.attributes.position,y=n.indirect?x=>{const P=n.resolveTriangleIndex(x);D(u,P*3,p,l)}:x=>{D(u,x*3,p,l)};if(a){const x=(P,w,d,m,h,b,A,B)=>{for(let T=d,_=d+m;T<_;T++){y(T),u.a.applyMatrix4(t),u.b.applyMatrix4(t),u.c.applyMatrix4(t),u.needsUpdate=!0;for(let g=P,S=P+w;g<S;g++)if(f(g),r.needsUpdate=!0,a(r,u,g,T,h,b,A,B))return!0}return!1};if(i){const P=i;i=function(w,d,m,h,b,A,B,T){return P(w,d,m,h,b,A,B,T)?!0:x(w,d,m,h,b,A,B,T)}}else i=x}return as(this,n,t,i)}intersectsBox(n,t){return $t.set(n.min,n.max,t),$t.needsUpdate=!0,this.shapecast({intersectsBounds:s=>$t.intersectsBox(s),intersectsTriangle:s=>$t.intersectsTriangle(s)})}intersectsSphere(n){return this.shapecast({intersectsBounds:t=>n.intersectsBox(t),intersectsTriangle:t=>t.intersectsSphere(n)})}closestPointToGeometry(n,t,s={},i={},a=0,r=1/0){return(this.indirect?os:Qe)(this,n,t,s,i,a,r)}closestPointToPoint(n,t={},s=0,i=1/0){return ve(this,n,t,s,i)}getBoundingBox(n){return n.makeEmpty(),this._roots.forEach(s=>{E(0,new Float32Array(s),In),n.union(In)}),n}}function Nn(e,n,t){return e===null||(e.point.applyMatrix4(n.matrixWorld),e.distance=e.point.distanceTo(t.ray.origin),e.object=n,e.distance<t.near||e.distance>t.far)?null:e}const rn=new se,qn=new tt,us=Xn.prototype.raycast;function fs(e,n){if(this.geometry.boundsTree){if(this.material===void 0)return;qn.copy(this.matrixWorld).invert(),rn.copy(e.ray).applyMatrix4(qn);const t=this.geometry.boundsTree;if(e.firstHitOnly===!0){const s=Nn(t.raycastFirst(rn,this.material),this,e);s&&n.push(s)}else{const s=t.raycast(rn,this.material);for(let i=0,a=s.length;i<a;i++){const r=Nn(s[i],this,e);r&&n.push(r)}}}else us.call(this,e,n)}function ps(e){return this.boundsTree=new wn(this,e),this.boundsTree}function ys(){this.boundsTree=null}const ds=e=>{e.computeBoundingBox();const{max:n,min:t}=e.boundingBox;e.deleteAttribute("uv");const s=n.x-t.x,i=n.y-t.y,a=[];for(let o=0;o<e.attributes.position.count;o++)a.push((e.attributes.position.getX(o)-t.x)/s),a.push((e.attributes.position.getY(o)-t.y)/i);const r=new Float32Array(a);e.setAttribute("uv",new mn(r,2))},ws=(e,n)=>new Promise((t,s)=>{ie(e,{},{method:"get"}).then(i=>{n&&t(i[n]),t(i.features)}).catch(i=>{console.error(i),s(error)})}),As=()=>{Bn.prototype.computeBoundsTree=ps,Bn.prototype.disposeBoundsTree=ys,Xn.prototype.raycast=fs},Ts=async e=>{const n=await re(["./plugins/water/images/Water_1_M_Normal.jpg","./plugins/water/images/Water_2_M_Normal.jpg"]),t=e.geometry.clone();ds(t),t.computeBoundsTree();const s=new ce(t,{color:new oe("#fff"),scale:20,flowDirection:new et(1,1),textureWidth:1024,textureHeight:1024,normalMap0:n[0],normalMap1:n[1]});return s.material.transparent=!0,s.material.depthWrite=!0,s.material.depthTest=!0,s.material.side=kn,s.material.uniforms.config.value.w=20,s.material.uniforms.reflectivity.value=.46,s};export{fs as a,ps as c,ys as d,As as i,ws as l,ds as r,Ts as s};
