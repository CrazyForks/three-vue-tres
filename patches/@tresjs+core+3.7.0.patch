diff --git a/node_modules/@tresjs/core/.DS_Store b/node_modules/@tresjs/core/.DS_Store
new file mode 100644
index 0000000..c88a062
Binary files /dev/null and b/node_modules/@tresjs/core/.DS_Store differ
diff --git a/node_modules/@tresjs/core/dist/index.d.ts b/node_modules/@tresjs/core/dist/index.d.ts
index 074d248..0039ce4 100644
--- a/node_modules/@tresjs/core/dist/index.d.ts
+++ b/node_modules/@tresjs/core/dist/index.d.ts
@@ -1,3 +1,17 @@
-export * from './src/index'
-import Tres from './src/index'
-export default Tres
+import type { App } from 'vue';
+import { normalizeColor, normalizeVectorFlexibleParam } from './utils/normalize';
+import templateCompilerOptions from './utils/template-compiler-options';
+export * from './composables';
+export * from './core/catalogue';
+export * from './components';
+export * from './types';
+export interface TresOptions {
+    extends?: Record<string, unknown>;
+}
+export interface TresPlugin {
+    [key: string]: any;
+    install: (app: App, options?: TresOptions) => void;
+}
+declare const plugin: TresPlugin;
+export default plugin;
+export { normalizeColor, normalizeVectorFlexibleParam, templateCompilerOptions, };
diff --git a/node_modules/@tresjs/core/dist/tres.js b/node_modules/@tresjs/core/dist/tres.js
index f4aa1f2..a198664 100644
--- a/node_modules/@tresjs/core/dist/tres.js
+++ b/node_modules/@tresjs/core/dist/tres.js
@@ -1,612 +1,433 @@
 /**
  * name: @tresjs/core
- * version: v3.7.0
+ * version: v3.6.0
  * (c) 2024
  * description: Declarative ThreeJS using Vue Components
  * author: Alvaro Saburido <hola@alvarosaburido.dev> (https://github.com/alvarosabu/)
  */
-var je = Object.defineProperty;
-var He = (e, r, t) => r in e ? je(e, r, { enumerable: !0, configurable: !0, writable: !0, value: t }) : e[r] = t;
-var J = (e, r, t) => (He(e, typeof r != "symbol" ? r + "" : r, t), t);
-import { ref as R, computed as P, watchEffect as O, onUnmounted as F, shallowRef as D, watch as me, reactive as ge, readonly as Re, provide as q, inject as $e, createRenderer as Ie, defineComponent as ne, useSlots as ze, getCurrentInstance as oe, onMounted as Ne, openBlock as Ve, createElementBlock as We, normalizeClass as Ue, unref as Fe, normalizeStyle as Ge, h as se, Fragment as Je } from "vue";
-import * as ve from "three";
-import { PerspectiveCamera as K, OrthographicCamera as Qe, Camera as Ye, Clock as qe, Vector3 as he, Color as V, MeshBasicMaterial as ye, DoubleSide as Ke, REVISION as Xe, SRGBColorSpace as Ze, ACESFilmicToneMapping as et, PCFSoftShadowMap as tt, WebGLRenderer as Q, LoadingManager as rt, TextureLoader as nt, Vector2 as ot, Raycaster as st, BufferAttribute as it, Scene as at, Line as lt, BufferGeometry as ie, Float32BufferAttribute as ae, LineBasicMaterial as ut, Mesh as ct, BackSide as dt, DirectionalLightHelper as ft, PointLightHelper as pt, SpotLightHelper as mt, HemisphereLightHelper as gt, ArrowHelper as vt } from "three";
-import { createEventHook as H, useRafFn as we, toValue as M, unrefElement as ht, useDevicePixelRatio as yt, usePointer as wt, useElementBounding as bt, useWindowSize as _t, useElementSize as Et, refDebounced as Mt, useFps as Ct, useMemory as St } from "@vueuse/core";
-const xt = "@tresjs/core", Pt = "module", kt = "3.7.0", At = "pnpm@8.10.2", Tt = "Declarative ThreeJS using Vue Components", Lt = "Alvaro Saburido <hola@alvarosaburido.dev> (https://github.com/alvarosabu/)", Ot = "MIT", Dt = [
-  "vue",
-  "3d",
-  "threejs",
-  "three",
-  "threejs-vue"
-], Bt = !1, jt = {
-  ".": {
-    types: "./dist/index.d.ts",
-    require: "./dist/tres.umd.cjs",
-    import: "./dist/tres.js"
-  },
-  "./components": {
-    types: "./dist/components/index.d.ts"
-  },
-  "./composables": {
-    types: "./dist/composables/index.d.ts"
-  },
-  "./types": {
-    types: "./dist/types/index.d.ts"
-  },
-  "./utils": {
-    types: "./dist/utils/index.d.ts"
-  },
-  "./*": "./*"
-}, Ht = "./dist/tres.js", Rt = "./dist/tres.js", $t = "./dist/index.d.ts", It = [
-  "dist",
-  "*.d.ts"
-], zt = {
-  access: "public"
-}, Nt = {
-  dev: "cd playground && npm run dev",
-  build: "vite build",
-  playground: "cd playground && npm run dev",
-  test: "vitest",
-  "test:ci": "vitest run",
-  "test:ui": "vitest --ui",
-  release: "release-it",
-  coverage: "vitest run --coverage",
-  lint: "eslint . --ext .js,.jsx,.ts,.tsx,.vue",
-  "docs:dev": "vitepress dev docs",
-  "docs:build": "vitepress build docs",
-  "docs:serve": "vitepress serve docs",
-  "docs:preview": "vitepress preview docs",
-  "docs:contributors": "esno scripts/update-contributors.ts"
-}, Vt = {
-  three: ">=0.133",
-  vue: ">=3.3"
-}, Wt = {
-  "@alvarosabu/utils": "^3.1.1",
-  "@vueuse/core": "^10.7.0"
-}, Ut = {
-  "@release-it/conventional-changelog": "^8.0.1",
-  "@stackblitz/sdk": "^1.9.0",
-  "@tresjs/cientos": "3.6.0",
-  "@tresjs/eslint-config-vue": "^0.2.1",
-  "@types/three": "^0.159.0",
-  "@typescript-eslint/eslint-plugin": "^6.14.0",
-  "@typescript-eslint/parser": "^6.14.0",
-  "@vitejs/plugin-vue": "^4.5.2",
-  "@vitest/coverage-c8": "^0.33.0",
-  "@vitest/ui": "^1.0.4",
-  "@vue/test-utils": "^2.4.3",
-  eslint: "^8.55.0",
-  "eslint-plugin-vue": "^9.19.2",
-  esno: "^4.0.0",
-  gsap: "^3.12.3",
-  jsdom: "^23.0.1",
-  kolorist: "^1.8.0",
-  ohmyfetch: "^0.4.21",
-  pathe: "^1.1.1",
-  "release-it": "^17.0.1",
-  "rollup-plugin-analyzer": "^4.0.0",
-  "rollup-plugin-copy": "^3.5.0",
-  "rollup-plugin-visualizer": "^5.11.0",
-  three: "^0.159.0",
-  unocss: "^0.58.0",
-  unplugin: "^1.5.1",
-  "unplugin-vue-components": "^0.26.0",
-  vite: "^5.0.8",
-  "vite-plugin-banner": "^0.7.1",
-  "vite-plugin-dts": "3.6.4",
-  "vite-plugin-inspect": "^0.8.1",
-  "vite-plugin-require-transform": "^1.0.21",
-  "vite-svg-loader": "^5.1.0",
-  vitepress: "1.0.0-rc.31",
-  vitest: "^1.0.4",
-  vue: "^3.3.11",
-  "vue-demi": "^0.14.6"
-}, Ft = {
-  name: xt,
-  type: Pt,
-  version: kt,
-  packageManager: At,
-  description: Tt,
-  author: Lt,
-  license: Ot,
-  keywords: Dt,
-  sideEffects: Bt,
-  exports: jt,
-  main: Ht,
-  module: Rt,
-  types: $t,
-  files: It,
-  publishConfig: zt,
-  scripts: Nt,
-  peerDependencies: Vt,
-  dependencies: Wt,
-  devDependencies: Ut
-}, Gt = ({ sizes: e, scene: r }) => {
-  const t = R([]), n = P(
+import { ref as B, computed as k, watchEffect as D, onUnmounted as $, shallowRef as L, watch as ne, reactive as de, readonly as ve, provide as G, inject as ge, createRenderer as ye, defineComponent as J, useSlots as he, getCurrentInstance as K, onMounted as we, openBlock as Ee, createElementBlock as _e, normalizeClass as Ce, normalizeStyle as Me, h as X, Fragment as Pe } from "vue";
+import * as be from "three";
+import { PerspectiveCamera as W, OrthographicCamera as Ae, Camera as ke, Clock as De, Vector3 as Te, Color as H, REVISION as Le, SRGBColorSpace as Se, ACESFilmicToneMapping as Be, PCFSoftShadowMap as xe, WebGLRenderer as I, TextureLoader as Oe, Vector2 as je, Raycaster as Re, BufferAttribute as He, Scene as Fe } from "three";
+import { createEventHook as S, useRafFn as ae, toValue as C, unrefElement as ze, useDevicePixelRatio as $e, usePointer as Ne, useElementBounding as Ie, useWindowSize as Ve, useElementSize as Ge, useFps as We, useMemory as Ue } from "@vueuse/core";
+const Ye = ({ sizes: e, scene: a }) => {
+  const t = B([]), r = k(
     () => t.value[0]
-  ), s = (i, l = !1) => {
-    t.value.some(({ uuid: c }) => c === i.uuid) || (l ? o(i) : t.value.push(i));
-  }, a = (i) => {
-    t.value = t.value.filter(({ uuid: l }) => l !== i.uuid);
-  }, o = (i) => {
-    const l = i instanceof Ye ? i : t.value.find((p) => p.uuid === i);
+  ), n = (s, l = !1) => {
+    t.value.some(({ uuid: c }) => c === s.uuid) || (l ? u(s) : t.value.push(s));
+  }, o = (s) => {
+    t.value = t.value.filter(({ uuid: l }) => l !== s.uuid);
+  }, u = (s) => {
+    const l = s instanceof ke ? s : t.value.find((p) => p.uuid === s);
     if (!l)
       return;
     const c = t.value.filter(({ uuid: p }) => p !== l.uuid);
     t.value = [l, ...c];
   };
-  return O(() => {
-    e.aspectRatio.value && t.value.forEach((i) => {
-      i instanceof K && (i.aspect = e.aspectRatio.value), (i instanceof K || i instanceof Qe) && i.updateProjectionMatrix();
+  return D(() => {
+    e.aspectRatio.value && t.value.forEach((s) => {
+      s instanceof W && (s.aspect = e.aspectRatio.value), (s instanceof W || s instanceof Ae) && s.updateProjectionMatrix();
     });
-  }), r.userData.tres__registerCamera = s, r.userData.tres__deregisterCamera = a, F(() => {
+  }), a.userData.tres__registerCamera = n, a.userData.tres__deregisterCamera = o, $(() => {
     t.value = [];
   }), {
-    camera: n,
+    camera: r,
     cameras: t,
-    registerCamera: s,
-    deregisterCamera: a,
-    setCameraActive: o
+    registerCamera: n,
+    deregisterCamera: o,
+    setCameraActive: u
   };
-}, be = H(), _e = H(), ee = H(), j = new qe();
-let W = 0, U = 0;
-const { pause: Jt, resume: Qt, isActive: Yt } = we(
+}, oe = S(), se = S(), Y = S(), T = new De();
+let F = 0, z = 0;
+const { pause: qe, resume: Je, isActive: Ke } = ae(
   () => {
-    be.trigger({ delta: W, elapsed: U, clock: j }), _e.trigger({ delta: W, elapsed: U, clock: j }), ee.trigger({ delta: W, elapsed: U, clock: j });
+    oe.trigger({ delta: F, elapsed: z, clock: T }), se.trigger({ delta: F, elapsed: z, clock: T }), Y.trigger({ delta: F, elapsed: z, clock: T });
   },
   { immediate: !1 }
 );
-ee.on(() => {
-  W = j.getDelta(), U = j.getElapsedTime();
+Y.on(() => {
+  F = T.getDelta(), z = T.getElapsedTime();
 });
-const te = () => ({
-  onBeforeLoop: be.on,
-  onLoop: _e.on,
-  onAfterLoop: ee.on,
-  pause: Jt,
-  resume: Qt,
-  isActive: Yt
-}), Vr = !0, le = "[TresJS ▲ ■ ●] ";
-function T() {
-  function e(n, s) {
-    console.error(`${le} ${n}`, s || "");
+const ie = () => ({
+  onBeforeLoop: oe.on,
+  onLoop: se.on,
+  onAfterLoop: Y.on,
+  pause: qe,
+  resume: Je,
+  isActive: Ke
+}), Pt = !0, Q = "[TresJS ▲ ■ ●] ";
+function x() {
+  function e(r, n) {
+    console.error(`${Q} ${r}`, n || "");
   }
-  function r(n) {
-    console.warn(`${le} ${n}`);
+  function a(r) {
+    console.warn(`${Q} ${r}`);
   }
-  function t(n, s) {
+  function t(r, n) {
   }
   return {
     logError: e,
-    logWarning: r,
+    logWarning: a,
     logMessage: t
   };
 }
-function Wr(e) {
-  return typeof e == "number" ? [e, e, e] : e instanceof he ? [e.x, e.y, e.z] : e;
+function bt(e) {
+  return typeof e == "number" ? [e, e, e] : e instanceof Te ? [e.x, e.y, e.z] : e;
 }
-function qt(e) {
-  return e instanceof V ? e : Array.isArray(e) ? new V(...e) : new V(e);
+function Xe(e) {
+  return e instanceof H ? e : Array.isArray(e) ? new H(...e) : new H(e);
 }
-class Kt extends ve.Mesh {
-  constructor(...t) {
-    super(...t);
-    J(this, "type", "HightlightMesh");
-    J(this, "createTime");
-    this.createTime = Date.now();
-  }
-  onBeforeRender() {
-    const n = (Date.now() - this.createTime) / 1e3, o = 1 + 0.07 * Math.sin(2.5 * n);
-    this.scale.set(o, o, o);
-  }
-}
-const Ee = (e, r) => {
-  for (const t of Object.keys(r))
-    r[t] instanceof Object && Object.assign(r[t], Ee(e[t], r[t]));
-  return Object.assign(e || {}, r), e;
-}, Xt = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot", Zt = /* @__PURE__ */ er(Xt);
-function ue(e) {
+const le = (e, a) => {
+  for (const t of Object.keys(a))
+    a[t] instanceof Object && Object.assign(a[t], le(e[t], a[t]));
+  return Object.assign(e || {}, a), e;
+}, Qe = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot", Ze = /* @__PURE__ */ et(Qe);
+function Z(e) {
   return e && e.nodeType === 1;
 }
-function I(e) {
-  return e.replace(/-([a-z])/g, (r, t) => t.toUpperCase());
+function j(e) {
+  return e.replace(/-([a-z])/g, (a, t) => t.toUpperCase());
 }
-function er(e, r) {
-  const t = /* @__PURE__ */ Object.create(null), n = e.split(",");
-  for (let s = 0; s < n.length; s++)
-    t[n[s]] = !0;
-  return r ? (s) => !!t[s.toLowerCase()] : (s) => !!t[s];
+function et(e, a) {
+  const t = /* @__PURE__ */ Object.create(null), r = e.split(",");
+  for (let n = 0; n < r.length; n++)
+    t[r[n]] = !0;
+  return a ? (n) => !!t[n.toLowerCase()] : (n) => !!t[n];
 }
-const tr = (e, r) => {
-  const t = /* @__PURE__ */ new Set(), n = [];
-  for (const s of e) {
-    const a = r(s);
-    t.has(a) || (t.add(a), n.push(s));
+const tt = (e, a) => {
+  const t = /* @__PURE__ */ new Set(), r = [];
+  for (const n of e) {
+    const o = a(n);
+    t.has(o) || (t.add(o), r.push(n));
   }
-  return n;
-}, ce = (e, r) => {
-  if (!r)
+  return r;
+}, ee = (e, a) => {
+  if (!a)
     return;
-  const t = Array.isArray(r) ? r : r.match(/([^[.\]])+/g);
-  return t == null ? void 0 : t.reduce((n, s) => n && n[s], e);
-}, rr = (e, r, t) => {
-  const n = Array.isArray(r) ? r : r.match(/([^[.\]])+/g);
-  n && n.reduce((s, a, o) => (s[a] === void 0 && (s[a] = {}), o === n.length - 1 && (s[a] = t), s[a]), e);
+  const t = Array.isArray(a) ? a : a.match(/([^[.\]])+/g);
+  return t == null ? void 0 : t.reduce((r, n) => r && r[n], e);
+}, rt = (e, a, t) => {
+  const r = Array.isArray(a) ? a : a.match(/([^[.\]])+/g);
+  r && r.reduce((n, o, u) => (n[o] === void 0 && (n[o] = {}), u === r.length - 1 && (n[o] = t), n[o]), e);
 };
-function Me(e, r) {
-  if (ue(e) && ue(r)) {
-    const s = e.attributes, a = r.attributes;
-    return s.length !== a.length ? !1 : Array.from(s).every(({ name: o, value: i }) => r.getAttribute(o) === i);
+function ue(e, a) {
+  if (Z(e) && Z(a)) {
+    const n = e.attributes, o = a.attributes;
+    return n.length !== o.length ? !1 : Array.from(n).every(({ name: u, value: s }) => a.getAttribute(u) === s);
   }
-  if (e === r)
+  if (e === a)
     return !0;
-  if (e === null || typeof e != "object" || r === null || typeof r != "object")
+  if (e === null || typeof e != "object" || a === null || typeof a != "object")
     return !1;
-  const t = Object.keys(e), n = Object.keys(r);
-  if (t.length !== n.length)
+  const t = Object.keys(e), r = Object.keys(a);
+  if (t.length !== r.length)
     return !1;
-  for (const s of t)
-    if (!n.includes(s) || !Me(e[s], r[s]))
+  for (const n of t)
+    if (!r.includes(n) || !ue(e[n], a[n]))
       return !1;
   return !0;
 }
-function nr(e, r) {
-  if (!Array.isArray(e) || !Array.isArray(r) || e.length !== r.length)
+function nt(e, a) {
+  if (!Array.isArray(e) || !Array.isArray(a) || e.length !== a.length)
     return !1;
   for (let t = 0; t < e.length; t++)
-    if (!Me(e[t], r[t]))
+    if (!ue(e[t], a[t]))
       return !1;
   return !0;
 }
-const or = Array.isArray;
-function sr(e, r, t, n) {
-  const s = (l) => {
-    if (l.uuid === r)
-      return l;
-    for (const c of l.children) {
-      const p = s(c);
-      if (p)
-        return p;
-    }
-  }, a = s(e);
-  if (!a) {
-    console.warn("Object with UUID not found in the scene.");
-    return;
-  }
-  let o = a;
-  for (let l = 0; l < t.length - 1; l++)
-    if (o[t[l]] !== void 0)
-      o = o[t[l]];
-    else {
-      console.warn(`Property path is not valid: ${t.join(".")}`);
-      return;
-    }
-  const i = t[t.length - 1];
-  o[i] !== void 0 ? o[i] = n : console.warn(`Property path is not valid: ${t.join(".")}`);
-}
-function ir(e) {
-  const r = new ye({
-    color: 11003607,
-    // Highlight color, e.g., yellow
-    transparent: !0,
-    opacity: 0.2,
-    depthTest: !1,
-    // So the highlight is always visible
-    side: Ke
-    // To e
-  });
-  return new Kt(e.geometry.clone(), r);
-}
-function Ce(e) {
-  var t;
-  let r = e.value;
-  return e.value && ((t = e.value) != null && t.isMesh) && (r = e.value.position), Array.isArray(e.value) && (r = new he(...r)), r;
-}
-const ar = Number.parseInt(Xe.replace("dev", "")), z = {
+const at = Array.isArray, ot = Number.parseInt(Le.replace("dev", "")), R = {
   realistic: {
     shadows: !0,
     physicallyCorrectLights: !0,
-    outputColorSpace: Ze,
-    toneMapping: et,
+    outputColorSpace: Se,
+    toneMapping: Be,
     toneMappingExposure: 3,
     shadowMap: {
       enabled: !0,
-      type: tt
+      type: xe
     }
   }
 };
-function lr({
+function st({
   scene: e,
-  canvas: r,
+  canvas: a,
   options: t,
-  disableRender: n,
-  contextParts: { sizes: s, camera: a }
+  disableRender: r,
+  contextParts: { sizes: n, camera: o }
 }) {
-  const o = P(() => ({
-    alpha: M(t.alpha),
-    depth: M(t.depth),
-    canvas: ht(r),
-    context: M(t.context),
-    stencil: M(t.stencil),
-    antialias: M(t.antialias) === void 0 ? !0 : M(t.antialias),
-    precision: M(t.precision),
-    powerPreference: M(t.powerPreference),
-    premultipliedAlpha: M(t.premultipliedAlpha),
-    preserveDrawingBuffer: M(t.preserveDrawingBuffer),
-    logarithmicDepthBuffer: M(t.logarithmicDepthBuffer),
-    failIfMajorPerformanceCaveat: M(t.failIfMajorPerformanceCaveat)
-  })), i = D(new Q(o.value));
-  me(o, () => {
-    i.value.dispose(), i.value = new Q(o.value);
-  }), O(() => {
-    i.value.setSize(s.width.value, s.height.value);
+  const u = k(() => ({
+    alpha: C(t.alpha),
+    depth: C(t.depth),
+    canvas: ze(a),
+    context: C(t.context),
+    stencil: C(t.stencil),
+    antialias: C(t.antialias) === void 0 ? !0 : C(t.antialias),
+    precision: C(t.precision),
+    powerPreference: C(t.powerPreference),
+    premultipliedAlpha: C(t.premultipliedAlpha),
+    preserveDrawingBuffer: C(t.preserveDrawingBuffer),
+    logarithmicDepthBuffer: C(t.logarithmicDepthBuffer),
+    failIfMajorPerformanceCaveat: C(t.failIfMajorPerformanceCaveat)
+  })), s = L(new I(u.value));
+  ne(u, () => {
+    s.value.dispose(), s.value = new I(u.value);
+  }), D(() => {
+    s.value.setSize(n.width.value, n.height.value);
   });
-  const { pixelRatio: l } = yt();
-  O(() => {
-    i.value.setPixelRatio(l.value);
+  const { pixelRatio: l } = $e();
+  D(() => {
+    s.value.setPixelRatio(l.value);
   });
-  const { logError: c } = T(), d = (() => {
-    const f = new Q(), h = {
+  const { logError: c } = x(), f = (() => {
+    const m = new I(), h = {
       shadowMap: {
-        enabled: f.shadowMap.enabled,
-        type: f.shadowMap.type
+        enabled: m.shadowMap.enabled,
+        type: m.shadowMap.type
       },
-      toneMapping: f.toneMapping,
-      toneMappingExposure: f.toneMappingExposure,
-      outputColorSpace: f.outputColorSpace
+      toneMapping: m.toneMapping,
+      toneMappingExposure: m.toneMappingExposure,
+      outputColorSpace: m.outputColorSpace
     };
-    return f.dispose(), h;
+    return m.dispose(), h;
   })();
-  O(() => {
-    const f = M(t.preset);
-    f && (f in z || c(`Renderer Preset must be one of these: ${Object.keys(z).join(", ")}`), Ee(i.value, z[f]));
-    const h = (C, S) => {
-      const b = M(C), x = () => {
-        if (f)
-          return ce(z[f], S);
+  D(() => {
+    const m = C(t.preset);
+    m && (m in R || c(`Renderer Preset must be one of these: ${Object.keys(R).join(", ")}`), le(s.value, R[m]));
+    const h = (P, b) => {
+      const E = C(P), A = () => {
+        if (m)
+          return ee(R[m], b);
       };
-      if (b !== void 0)
-        return b;
-      const g = x();
-      return g !== void 0 ? g : ce(d, S);
-    }, _ = (C, S) => rr(i.value, S, h(C, S));
-    _(t.shadows, "shadowMap.enabled"), _(t.toneMapping, "toneMapping"), _(t.shadowMapType, "shadowMap.type"), ar < 150 && _(!t.useLegacyLights, "physicallyCorrectLights"), _(t.outputColorSpace, "outputColorSpace"), _(t.toneMappingExposure, "toneMappingExposure");
-    const w = h(t.clearColor, "clearColor");
-    w && i.value.setClearColor(
-      w ? qt(w) : new V(0)
+      if (E !== void 0)
+        return E;
+      const g = A();
+      return g !== void 0 ? g : ee(f, b);
+    }, d = (P, b) => rt(s.value, b, h(P, b));
+    d(t.shadows, "shadowMap.enabled"), d(t.toneMapping, "toneMapping"), d(t.shadowMapType, "shadowMap.type"), ot < 150 && d(!t.useLegacyLights, "physicallyCorrectLights"), d(t.outputColorSpace, "outputColorSpace"), d(t.toneMappingExposure, "toneMappingExposure");
+    const M = h(t.clearColor, "clearColor");
+    M && s.value.setClearColor(
+      M ? Xe(M) : new H(0)
       // default clear color is not easily/efficiently retrievable from three
     );
   });
-  const { pause: u, resume: m, onLoop: y } = te();
-  return y(() => {
-    a.value && !M(n) && i.value.render(e, a.value);
-  }), m(), F(() => {
-    u(), i.value.dispose(), i.value.forceContextLoss();
+  const { pause: i, resume: v, onLoop: w } = ie();
+  return w(() => {
+    o.value && !C(r) && s.value.render(e, o.value);
+  }), v(), $(() => {
+    i(), s.value.dispose(), s.value.forceContextLoss();
   }), {
-    renderer: i
+    renderer: s
   };
 }
-const de = (e) => typeof e == "function", ur = (e) => !!e && e.constructor === Array;
-function cr(e) {
-  const r = { nodes: {}, materials: {} };
+const te = (e) => typeof e == "function", it = (e) => !!e && e.constructor === Array;
+function lt(e) {
+  const a = { nodes: {}, materials: {} };
   return e && e.traverse((t) => {
-    t.name && (r.nodes[t.name] = t), t.material && !r.materials[t.material.name] && (r.materials[t.material.name] = t.material);
-  }), r;
+    t.name && (a.nodes[t.name] = t), t.material && !a.materials[t.material.name] && (a.materials[t.material.name] = t.material);
+  }), a;
 }
-async function Ur(e, r, t, n, s) {
-  const { logError: a } = T(), o = new e();
-  s && s(o), t && t(o);
-  const l = (Array.isArray(r) ? r : [r]).map(
-    (c) => new Promise((p, d) => {
-      o.load(
+async function At(e, a, t, r, n) {
+  const { logError: o } = x(), u = new e();
+  n && n(u), t && t(u);
+  const l = (Array.isArray(a) ? a : [a]).map(
+    (c) => new Promise((p, f) => {
+      u.load(
         c,
-        (u) => {
-          u.scene && Object.assign(u, cr(u.scene)), p(u);
+        (i) => {
+          i.scene && Object.assign(i, lt(i.scene)), p(i);
         },
-        n,
-        (u) => d(a("[useLoader] - Failed to load resource", u))
+        r,
+        (i) => f(o("[useLoader] - Failed to load resource", i))
       );
     })
   );
-  return ur(r) ? await Promise.all(l) : await l[0];
+  return it(a) ? await Promise.all(l) : await l[0];
 }
-async function Fr(e) {
-  const r = new rt(), t = new nt(r), n = (s) => new Promise((a, o) => {
+async function kt(e, a) {
+  const t = new Oe(a), r = (n) => new Promise((o, u) => {
     t.load(
-      s,
-      (i) => a(i),
+      n,
+      (s) => o(s),
       () => null,
       () => {
-        o(new Error("[useTextures] - Failed to load texture"));
+        u(new Error("[useTextures] - Failed to load texture"));
       }
     );
   });
-  if (or(e)) {
-    const s = await Promise.all(e.map((a) => n(a)));
-    return e.length > 1 ? s : s[0];
+  if (at(e)) {
+    const n = await Promise.all(e.map((o) => r(o)));
+    return e.length > 1 ? n : n[0];
   } else {
     const {
-      map: s,
-      displacementMap: a,
-      normalMap: o,
-      roughnessMap: i,
+      map: n,
+      displacementMap: o,
+      normalMap: u,
+      roughnessMap: s,
       metalnessMap: l,
       aoMap: c,
       alphaMap: p,
-      matcap: d
+      matcap: f
     } = e;
     return {
-      map: s ? await n(s) : null,
-      displacementMap: a ? await n(a) : null,
-      normalMap: o ? await n(o) : null,
-      roughnessMap: i ? await n(i) : null,
-      metalnessMap: l ? await n(l) : null,
-      aoMap: c ? await n(c) : null,
-      alphaMap: p ? await n(p) : null,
-      matcap: d ? await n(d) : null
+      map: n ? await r(n) : null,
+      displacementMap: o ? await r(o) : null,
+      normalMap: u ? await r(u) : null,
+      roughnessMap: s ? await r(s) : null,
+      metalnessMap: l ? await r(l) : null,
+      aoMap: c ? await r(c) : null,
+      alphaMap: p ? await r(p) : null,
+      matcap: f ? await r(f) : null
     };
   }
 }
-const dr = (e, { renderer: r, camera: t, raycaster: n }) => {
-  const s = P(() => r.value.domElement), { x: a, y: o } = wt({ target: s }), { width: i, height: l, top: c, left: p } = bt(s), d = ({ x: g, y: E }) => {
-    if (s.value)
+const ut = (e, { renderer: a, camera: t, raycaster: r }) => {
+  const n = k(() => a.value.domElement), { x: o, y: u } = Ne({ target: n }), { width: s, height: l, top: c, left: p } = Ie(n), f = ({ x: g, y: _ }) => {
+    if (n.value)
       return {
-        x: (g - p.value) / i.value * 2 - 1,
-        y: -((E - c.value) / l.value) * 2 + 1
+        x: (g - p.value) / s.value * 2 - 1,
+        y: -((_ - c.value) / l.value) * 2 + 1
       };
-  }, u = ({ x: g, y: E }) => {
+  }, i = ({ x: g, y: _ }) => {
     if (t.value)
-      return n.value.setFromCamera(new ot(g, E), t.value), n.value.intersectObjects(e.value, !1);
-  }, m = (g) => {
-    const E = d({
-      x: (g == null ? void 0 : g.clientX) ?? a.value,
-      y: (g == null ? void 0 : g.clientY) ?? o.value
+      return r.value.setFromCamera(new je(g, _), t.value), r.value.intersectObjects(e.value, !1);
+  }, v = (g) => {
+    const _ = f({
+      x: (g == null ? void 0 : g.clientX) ?? o.value,
+      y: (g == null ? void 0 : g.clientY) ?? u.value
     });
-    return E ? u(E) || [] : [];
-  }, y = P(() => m()), f = H(), h = H(), _ = (g, E) => {
-    g.trigger({ event: E, intersects: m(E) });
-  }, w = (g) => {
-    _(h, g);
+    return _ ? i(_) || [] : [];
+  }, w = k(() => v()), m = S(), h = S(), d = (g, _) => {
+    g.trigger({ event: _, intersects: v(_) });
+  }, M = (g) => {
+    d(h, g);
   };
-  let C;
-  const S = (g) => {
-    var E;
-    C = (E = m(g)[0]) == null ? void 0 : E.object;
-  }, b = (g) => {
-    var E;
-    g instanceof PointerEvent && C === ((E = m(g)[0]) == null ? void 0 : E.object) && _(f, g);
-  }, x = (g) => h.trigger({ event: g, intersects: [] });
-  return s.value.addEventListener("pointerup", b), s.value.addEventListener("pointerdown", S), s.value.addEventListener("pointermove", w), s.value.addEventListener("pointerleave", x), F(() => {
-    s != null && s.value && (s.value.removeEventListener("pointerup", b), s.value.removeEventListener("pointerdown", S), s.value.removeEventListener("pointermove", w), s.value.removeEventListener("pointerleave", x));
+  let P;
+  const b = (g) => {
+    var _;
+    P = (_ = v(g)[0]) == null ? void 0 : _.object;
+  }, E = (g) => {
+    var _;
+    g instanceof PointerEvent && P === ((_ = v(g)[0]) == null ? void 0 : _.object) && d(m, g);
+  }, A = (g) => h.trigger({ event: g, intersects: [] });
+  return n.value.addEventListener("pointerup", E), n.value.addEventListener("pointerdown", b), n.value.addEventListener("pointermove", M), n.value.addEventListener("pointerleave", A), $(() => {
+    n != null && n.value && (n.value.removeEventListener("pointerup", E), n.value.removeEventListener("pointerdown", b), n.value.removeEventListener("pointermove", M), n.value.removeEventListener("pointerleave", A));
   }), {
-    intersects: y,
-    onClick: (g) => f.on(g).off,
+    intersects: w,
+    onClick: (g) => m.on(g).off,
     onPointerMove: (g) => h.on(g).off
   };
 };
-function Gr() {
-  const { logWarning: e } = T();
-  function r(a, o, i) {
+function Dt() {
+  const { logWarning: e } = x();
+  function a(o, u, s) {
     let l = null;
-    return a.traverse((c) => {
-      c[o] === i && (l = c);
-    }), l || e(`Child with ${o} '${i}' not found.`), l;
+    return o.traverse((c) => {
+      c[u] === s && (l = c);
+    }), l || e(`Child with ${u} '${s}' not found.`), l;
   }
-  function t(a, o, i) {
+  function t(o, u, s) {
     const l = [];
-    return a.traverse((c) => {
-      c[o].includes(i) && l.push(c);
-    }), l.length || e(`Children with ${o} '${i}' not found.`), l;
+    return o.traverse((c) => {
+      c[u].includes(s) && l.push(c);
+    }), l.length || e(`Children with ${u} '${s}' not found.`), l;
   }
-  function n(a, o) {
-    return r(a, "name", o);
+  function r(o, u) {
+    return a(o, "name", u);
   }
-  function s(a, o) {
-    return t(a, "name", o);
+  function n(o, u) {
+    return t(o, "name", u);
   }
   return {
-    seek: r,
-    seekByName: n,
+    seek: a,
+    seekByName: r,
     seekAll: t,
-    seekAllByName: s
+    seekAllByName: n
   };
 }
-const fr = ({ scene: e, contextParts: r }) => {
-  const t = ge({
+const ct = ({ scene: e, contextParts: a }) => {
+  const t = de({
     click: /* @__PURE__ */ new Map(),
     pointerMove: /* @__PURE__ */ new Map(),
     pointerEnter: /* @__PURE__ */ new Map(),
     pointerLeave: /* @__PURE__ */ new Map()
-  }), n = R(/* @__PURE__ */ new Set()), s = (u) => {
-    n.value.add(u);
-  }, a = (u) => {
-    n.value.delete(u);
-  }, o = (u) => {
-    Object.values(t).forEach((m) => m.delete(u)), a(u);
-  }, i = (u) => {
-    const { onClick: m, onPointerMove: y, onPointerEnter: f, onPointerLeave: h } = u;
-    m && t.click.set(u, m), y && t.pointerMove.set(u, y), f && t.pointerEnter.set(u, f), h && t.pointerLeave.set(u, h);
+  }), r = B(/* @__PURE__ */ new Set()), n = (i) => {
+    r.value.add(i);
+  }, o = (i) => {
+    r.value.delete(i);
+  }, u = (i) => {
+    Object.values(t).forEach((v) => v.delete(i)), o(i);
+  }, s = (i) => {
+    const { onClick: v, onPointerMove: w, onPointerEnter: m, onPointerLeave: h } = i;
+    v && t.click.set(i, v), w && t.pointerMove.set(i, w), m && t.pointerEnter.set(i, m), h && t.pointerLeave.set(i, h);
   };
-  e.userData.tres__registerAtPointerEventHandler = i, e.userData.tres__deregisterAtPointerEventHandler = o, e.userData.tres__registerBlockingObjectAtPointerEventHandler = s, e.userData.tres__deregisterBlockingObjectAtPointerEventHandler = a;
-  const l = P(
-    () => tr(
+  e.userData.tres__registerAtPointerEventHandler = s, e.userData.tres__deregisterAtPointerEventHandler = u, e.userData.tres__registerBlockingObjectAtPointerEventHandler = n, e.userData.tres__deregisterBlockingObjectAtPointerEventHandler = o;
+  const l = k(
+    () => tt(
       [
-        ...Array.from(n.value),
-        ...Object.values(t).map((u) => Array.from(u.keys())).flat()
+        ...Array.from(r.value),
+        ...Object.values(t).map((i) => Array.from(i.keys())).flat()
       ],
-      ({ uuid: u }) => u
+      ({ uuid: i }) => i
     )
-  ), { onClick: c, onPointerMove: p } = dr(l, r);
-  c(({ intersects: u, event: m }) => {
-    var y;
-    u.length && ((y = t.click.get(u[0].object)) == null || y(u[0], m));
+  ), { onClick: c, onPointerMove: p } = ut(l, a);
+  c(({ intersects: i, event: v }) => {
+    var w;
+    i.length && ((w = t.click.get(i[0].object)) == null || w(i[0], v));
   });
-  let d;
-  return p(({ intersects: u, event: m }) => {
-    var w, C, S, b;
-    const y = (w = u == null ? void 0 : u[0]) == null ? void 0 : w.object, { pointerLeave: f, pointerEnter: h, pointerMove: _ } = t;
-    d && d !== y && ((C = f.get(d)) == null || C(d, m)), y && (d !== y && ((S = h.get(y)) == null || S(u[0], m)), (b = _.get(y)) == null || b(u[0], m)), d = y || null;
+  let f;
+  return p(({ intersects: i, event: v }) => {
+    var M, P, b, E;
+    const w = (M = i == null ? void 0 : i[0]) == null ? void 0 : M.object, { pointerLeave: m, pointerEnter: h, pointerMove: d } = t;
+    f && f !== w && ((P = m.get(f)) == null || P(f, v)), w && (f !== w && ((b = h.get(w)) == null || b(i[0], v)), (E = d.get(w)) == null || E(i[0], v)), f = w || null;
   }), {
-    registerObject: i,
-    deregisterObject: o
+    registerObject: s,
+    deregisterObject: u
   };
 };
-function Se(e) {
-  let r = 0;
+function ft(e) {
+  let a = 0;
   return e.traverse((t) => {
     if (t.isMesh && t.geometry) {
-      const n = t.geometry, s = n.attributes.position.count * 3 * Float32Array.BYTES_PER_ELEMENT, a = n.index ? n.index.count * Uint32Array.BYTES_PER_ELEMENT : 0, o = n.attributes.normal ? n.attributes.normal.count * 3 * Float32Array.BYTES_PER_ELEMENT : 0, i = n.attributes.uv ? n.attributes.uv.count * 2 * Float32Array.BYTES_PER_ELEMENT : 0, l = s + a + o + i;
-      r += l;
+      const r = t.geometry, n = r.attributes.position.count * 3 * Float32Array.BYTES_PER_ELEMENT, o = r.index ? r.index.count * Uint32Array.BYTES_PER_ELEMENT : 0, u = r.attributes.normal ? r.attributes.normal.count * 3 * Float32Array.BYTES_PER_ELEMENT : 0, s = r.attributes.uv ? r.attributes.uv.count * 2 * Float32Array.BYTES_PER_ELEMENT : 0, l = n + o + u + s;
+      a += l;
     }
-  }), r;
+  }), a;
 }
-function pr(e) {
-  return (e / 1024).toFixed(2);
-}
-const X = R({}), re = (e) => Object.assign(X.value, e);
-function mr({
+const U = B({}), q = (e) => Object.assign(U.value, e);
+function mt({
   scene: e,
-  canvas: r,
+  canvas: a,
   windowSize: t,
-  disableRender: n,
-  rendererOptions: s
+  disableRender: r,
+  rendererOptions: n
 }) {
-  const a = P(
-    () => M(t) ? _t() : Et(M(r).parentElement)
-  ), o = D({
-    width: 0,
-    height: 0
-  }), i = Mt(o, 10), l = O(() => {
-    o.value = {
-      width: a.value.width.value,
-      height: a.value.height.value
-    };
-  }), c = P(() => i.value.width / i.value.height), p = {
-    height: P(() => i.value.height),
-    width: P(() => i.value.width),
-    aspectRatio: c
-  }, d = D(e), {
-    camera: u,
-    cameras: m,
-    registerCamera: y,
-    deregisterCamera: f,
-    setCameraActive: h
-  } = Gt({ sizes: p, scene: e }), { renderer: _ } = lr(
+  const o = k(
+    () => C(t) ? Ve() : Ge(C(a).parentElement)
+  ), u = k(() => o.value.width.value), s = k(() => o.value.height.value), l = k(() => u.value / s.value), c = {
+    height: s,
+    width: u,
+    aspectRatio: l
+  }, p = L(e), {
+    camera: f,
+    cameras: i,
+    registerCamera: v,
+    deregisterCamera: w,
+    setCameraActive: m
+  } = Ye({ sizes: c, scene: e }), { renderer: h } = st(
     {
       scene: e,
-      canvas: r,
-      options: s,
-      contextParts: { sizes: p, camera: u },
-      disableRender: n
+      canvas: a,
+      options: n,
+      contextParts: { sizes: c, camera: f },
+      disableRender: r
     }
-  ), w = {
-    sizes: p,
-    scene: d,
-    camera: u,
-    cameras: Re(m),
-    renderer: _,
-    raycaster: D(new st()),
-    controls: R(null),
+  ), d = {
+    sizes: c,
+    scene: p,
+    camera: f,
+    cameras: ve(i),
+    renderer: h,
+    raycaster: L(new Re()),
+    controls: B(null),
     perf: {
       maxFrames: 160,
       fps: {
@@ -619,136 +440,136 @@ function mr({
         accumulator: []
       }
     },
-    extend: re,
-    registerCamera: y,
-    setCameraActive: h,
-    deregisterCamera: f
+    extend: q,
+    registerCamera: v,
+    setCameraActive: m,
+    deregisterCamera: w
   };
-  q("useTres", w);
-  const C = 100, S = Ct({ every: C }), { isSupported: b, memory: x } = St({ interval: C }), g = 160;
-  let E = performance.now();
-  const Te = ({ timestamp: $ }) => {
-    w.scene.value && (w.perf.memory.allocatedMem = Se(w.scene.value)), $ - E >= C && (E = $, w.perf.fps.accumulator.push(S.value), w.perf.fps.accumulator.length > g && w.perf.fps.accumulator.shift(), w.perf.fps.value = S.value, b.value && x.value && (w.perf.memory.accumulator.push(x.value.usedJSHeapSize / 1024 / 1024), w.perf.memory.accumulator.length > g && w.perf.memory.accumulator.shift(), w.perf.memory.currentMem = w.perf.memory.accumulator.reduce((De, Be) => De + Be, 0) / w.perf.memory.accumulator.length));
+  G("useTres", d);
+  const M = 100, P = We({ every: M }), { isSupported: b, memory: E } = Ue({ interval: M }), A = 160;
+  let g = performance.now();
+  const _ = ({ timestamp: O }) => {
+    d.scene.value && (d.perf.memory.allocatedMem = ft(d.scene.value)), O - g >= M && (g = O, d.perf.fps.accumulator.push(P.value), d.perf.fps.accumulator.length > A && d.perf.fps.accumulator.shift(), d.perf.fps.value = P.value, b.value && E.value && (d.perf.memory.accumulator.push(E.value.usedJSHeapSize / 1024 / 1024), d.perf.memory.accumulator.length > A && d.perf.memory.accumulator.shift(), d.perf.memory.currentMem = d.perf.memory.accumulator.reduce((me, pe) => me + pe, 0) / d.perf.memory.accumulator.length));
   };
-  let G = 0;
-  const Le = 1, { pause: Oe, resume: Rr } = we(({ delta: $ }) => {
-    window.__TRES__DEVTOOLS__ && (Te({ timestamp: performance.now() }), G += $, G >= Le && (window.__TRES__DEVTOOLS__.cb(w), G = 0));
+  let N = 0;
+  const ce = 1, { pause: fe, resume: Et } = ae(({ delta: O }) => {
+    window.__TRES__DEVTOOLS__ && (_({ timestamp: performance.now() }), N += O, N >= ce && (window.__TRES__DEVTOOLS__.cb(d), N = 0));
   }, { immediate: !0 });
-  return F(() => {
-    l(), Oe();
-  }), w;
+  return $(() => {
+    fe();
+  }), d;
 }
-function gr() {
-  const e = $e("useTres");
+function pt() {
+  const e = ge("useTres");
   if (!e)
     throw new Error("useTresContext must be used together with useTresContextProvider");
   return e;
 }
-const Jr = gr;
-let v = null;
-const { logError: fe } = T(), Y = [
+const Tt = pt;
+let y = null;
+const { logError: re } = x(), V = [
   "onClick",
   "onPointerMove",
   "onPointerEnter",
   "onPointerLeave"
-], vr = {
-  createElement(e, r, t, n) {
-    var o, i;
-    if (n || (n = {}), n.args || (n.args = []), e === "template" || Zt(e))
+], dt = {
+  createElement(e, a, t, r) {
+    var u, s;
+    if (r || (r = {}), r.args || (r.args = []), e === "template" || Ze(e))
       return null;
-    let s = e.replace("Tres", ""), a;
+    let n = e.replace("Tres", ""), o;
     if (e === "primitive") {
-      (n == null ? void 0 : n.object) === void 0 && fe("Tres primitives need a prop 'object'");
-      const l = n.object;
-      s = l.type, a = Object.assign(l, { type: s, attach: n.attach, primitive: !0 });
+      (r == null ? void 0 : r.object) === void 0 && re("Tres primitives need a prop 'object'");
+      const l = r.object;
+      n = l.type, o = Object.assign(l, { type: n, attach: r.attach, primitive: !0 });
     } else {
-      const l = X.value[s];
-      l || fe(`${s} is not defined on the THREE namespace. Use extend to add it to the catalog.`), a = new l(...n.args);
+      const l = U.value[n];
+      l || re(`${n} is not defined on the THREE namespace. Use extend to add it to the catalog.`), o = new l(...r.args);
     }
-    return a.isCamera && (n != null && n.position || a.position.set(3, 3, 3), n != null && n.lookAt || a.lookAt(0, 0, 0)), (n == null ? void 0 : n.attach) === void 0 && (a.isMaterial ? a.attach = "material" : a.isBufferGeometry && (a.attach = "geometry")), a.isObject3D && ((o = n == null ? void 0 : n.material) != null && o.isMaterial && (a.userData.tres__materialViaProp = !0), (i = n == null ? void 0 : n.geometry) != null && i.isBufferGeometry && (a.userData.tres__geometryViaProp = !0)), a.userData = {
-      ...a.userData,
-      tres__name: s
-    }, a;
+    return o.isCamera && (r != null && r.position || o.position.set(3, 3, 3), r != null && r.lookAt || o.lookAt(0, 0, 0)), (r == null ? void 0 : r.attach) === void 0 && (o.isMaterial ? o.attach = "material" : o.isBufferGeometry && (o.attach = "geometry")), o.isObject3D && ((u = r == null ? void 0 : r.material) != null && u.isMaterial && (o.userData.tres__materialViaProp = !0), (s = r == null ? void 0 : r.geometry) != null && s.isBufferGeometry && (o.userData.tres__geometryViaProp = !0)), o.userData = {
+      ...o.userData,
+      tres__name: n
+    }, o;
   },
-  insert(e, r) {
-    var n, s, a, o;
-    r && r.isScene && (v = r);
-    const t = r || v;
+  insert(e, a) {
+    var r, n, o, u;
+    a && a.isScene && (y = a);
+    const t = a || y;
     if (e != null && e.isObject3D) {
       if (e != null && e.isCamera) {
-        if (!(v != null && v.userData.tres__registerCamera))
+        if (!(y != null && y.userData.tres__registerCamera))
           throw "could not find tres__registerCamera on scene's userData";
-        (s = v == null ? void 0 : (n = v.userData).tres__registerCamera) == null || s.call(n, e);
+        (n = y == null ? void 0 : (r = y.userData).tres__registerCamera) == null || n.call(r, e);
       }
-      if (e && Y.some((i) => e[i])) {
-        if (!(v != null && v.userData.tres__registerAtPointerEventHandler))
+      if (e && V.some((s) => e[s])) {
+        if (!(y != null && y.userData.tres__registerAtPointerEventHandler))
           throw "could not find tres__registerAtPointerEventHandler on scene's userData";
-        (o = v == null ? void 0 : (a = v.userData).tres__registerAtPointerEventHandler) == null || o.call(a, e);
+        (u = y == null ? void 0 : (o = y.userData).tres__registerAtPointerEventHandler) == null || u.call(o, e);
       }
     }
     e != null && e.isObject3D && (t != null && t.isObject3D) ? (t.add(e), e.dispatchEvent({ type: "added" })) : e != null && e.isFog ? t.fog = e : typeof (e == null ? void 0 : e.attach) == "string" && (e.__previousAttach = e[t == null ? void 0 : t.attach], t && (t[e.attach] = e));
   },
   remove(e) {
-    var r, t;
+    var a, t;
     if (e) {
       if (e.isObject3D) {
-        const n = e, s = (c) => {
-          var d, u;
+        const r = e, n = (c) => {
+          var f, i;
           const p = c;
-          c.userData.tres__materialViaProp || ((d = p.material) == null || d.dispose(), p.material = void 0), c.userData.tres__geometryViaProp || ((u = p.geometry) == null || u.dispose(), p.geometry = void 0);
-        }, a = v == null ? void 0 : v.userData.tres__deregisterAtPointerEventHandler, o = v == null ? void 0 : v.userData.tres__deregisterBlockingObjectAtPointerEventHandler, i = (c) => {
-          var p, d;
-          if (!o)
+          c.userData.tres__materialViaProp || ((f = p.material) == null || f.dispose(), p.material = void 0), c.userData.tres__geometryViaProp || ((i = p.geometry) == null || i.dispose(), p.geometry = void 0);
+        }, o = y == null ? void 0 : y.userData.tres__deregisterAtPointerEventHandler, u = y == null ? void 0 : y.userData.tres__deregisterBlockingObjectAtPointerEventHandler, s = (c) => {
+          var p, f;
+          if (!u)
             throw "could not find tres__deregisterBlockingObjectAtPointerEventHandler on scene's userData";
-          if ((d = v == null ? void 0 : (p = v.userData).tres__deregisterBlockingObjectAtPointerEventHandler) == null || d.call(p, c), !a)
+          if ((f = y == null ? void 0 : (p = y.userData).tres__deregisterBlockingObjectAtPointerEventHandler) == null || f.call(p, c), !o)
             throw "could not find tres__deregisterAtPointerEventHandler on scene's userData";
-          c && Y.some((u) => c[u]) && (a == null || a(c));
+          c && V.some((i) => c[i]) && (o == null || o(c));
         }, l = (c) => {
-          const p = v == null ? void 0 : v.userData.tres__deregisterCamera;
+          const p = y == null ? void 0 : y.userData.tres__deregisterCamera;
           if (!p)
             throw "could not find tres__deregisterCamera on scene's userData";
           c.isCamera && (p == null || p(c));
         };
-        (r = e.removeFromParent) == null || r.call(e), n.traverse((c) => {
-          s(c), l(c), i == null || i(c);
-        }), s(n), l(n), i == null || i(n);
+        (a = e.removeFromParent) == null || a.call(e), r.traverse((c) => {
+          n(c), l(c), s == null || s(c);
+        }), n(r), l(r), s == null || s(r);
       }
       (t = e.dispose) == null || t.call(e);
     }
   },
-  patchProp(e, r, t, n) {
-    var s, a, o, i;
+  patchProp(e, a, t, r) {
+    var n, o, u, s;
     if (e) {
-      let l = e, c = r;
+      let l = e, c = a;
       if (e.isObject3D && c === "blocks-pointer-events") {
-        n || n === "" ? (a = v == null ? void 0 : (s = v.userData).tres__registerBlockingObjectAtPointerEventHandler) == null || a.call(s, e) : (i = v == null ? void 0 : (o = v.userData).tres__deregisterBlockingObjectAtPointerEventHandler) == null || i.call(o, e);
+        r || r === "" ? (o = y == null ? void 0 : (n = y.userData).tres__registerBlockingObjectAtPointerEventHandler) == null || o.call(n, e) : (s = y == null ? void 0 : (u = y.userData).tres__deregisterBlockingObjectAtPointerEventHandler) == null || s.call(u, e);
         return;
       }
-      let p = I(c), d = l == null ? void 0 : l[p];
+      let p = j(c), f = l == null ? void 0 : l[p];
       if (c === "args") {
-        const m = e, y = t ?? [], f = n ?? [], h = e.userData.tres__name || e.type;
-        h && y.length && !nr(y, f) && (l = Object.assign(m, new X.value[h](...n)));
+        const v = e, w = t ?? [], m = r ?? [], h = e.userData.tres__name || e.type;
+        h && w.length && !nt(w, m) && (l = Object.assign(v, new U.value[h](...r)));
         return;
       }
       if (l.type === "BufferGeometry") {
         if (c === "args")
           return;
         l.setAttribute(
-          I(c),
-          new it(...n)
+          j(c),
+          new He(...r)
         );
         return;
       }
-      if (c.includes("-") && d === void 0) {
-        const m = c.split("-");
-        d = m.reduce((y, f) => y[I(f)], l), c = m.pop(), p = c.toLowerCase(), d != null && d.set || (l = m.reduce((y, f) => y[I(f)], l));
+      if (c.includes("-") && f === void 0) {
+        const v = c.split("-");
+        f = v.reduce((w, m) => w[j(m)], l), c = v.pop(), p = c.toLowerCase(), f != null && f.set || (l = v.reduce((w, m) => w[j(m)], l));
       }
-      let u = n;
-      if (u === "" && (u = !0), de(d)) {
-        Y.includes(r) || (Array.isArray(u) ? e[p](...u) : e[p](u));
+      let i = r;
+      if (i === "" && (i = !0), te(f)) {
+        V.includes(a) || (Array.isArray(i) ? e[p](...i) : e[p](i));
         return;
       }
-      !(d != null && d.set) && !de(d) ? l[p] = u : d.constructor === u.constructor && (d != null && d.copy) ? d == null || d.copy(u) : Array.isArray(u) ? d.set(...u) : !d.isColor && d.setScalar ? d.setScalar(u) : d.set(u);
+      !(f != null && f.set) && !te(f) ? l[p] = i : f.constructor === i.constructor && (f != null && f.copy) ? f == null || f.copy(i) : Array.isArray(i) ? f.set(...i) : !f.isColor && f.setScalar ? f.setScalar(i) : f.set(i);
     }
   },
   parentNode(e) {
@@ -763,288 +584,9 @@ const { logError: fe } = T(), Y = [
   setScopeId: () => void 0,
   cloneNode: () => void 0,
   insertStaticContent: () => void 0
-}, { render: hr } = Ie(vr);
-re(ve);
-function yr() {
-  return xe().__VUE_DEVTOOLS_GLOBAL_HOOK__;
-}
-function xe() {
-  return typeof navigator < "u" && typeof window < "u" ? window : typeof global < "u" ? global : {};
-}
-const wr = typeof Proxy == "function", br = "devtools-plugin:setup", _r = "plugin:settings:set";
-let L, Z;
-function Er() {
-  var e;
-  return L !== void 0 || (typeof window < "u" && window.performance ? (L = !0, Z = window.performance) : typeof global < "u" && (!((e = global.perf_hooks) === null || e === void 0) && e.performance) ? (L = !0, Z = global.perf_hooks.performance) : L = !1), L;
-}
-function Mr() {
-  return Er() ? Z.now() : Date.now();
-}
-class Cr {
-  constructor(r, t) {
-    this.target = null, this.targetQueue = [], this.onQueue = [], this.plugin = r, this.hook = t;
-    const n = {};
-    if (r.settings)
-      for (const o in r.settings) {
-        const i = r.settings[o];
-        n[o] = i.defaultValue;
-      }
-    const s = `__vue-devtools-plugin-settings__${r.id}`;
-    let a = Object.assign({}, n);
-    try {
-      const o = localStorage.getItem(s), i = JSON.parse(o);
-      Object.assign(a, i);
-    } catch {
-    }
-    this.fallbacks = {
-      getSettings() {
-        return a;
-      },
-      setSettings(o) {
-        try {
-          localStorage.setItem(s, JSON.stringify(o));
-        } catch {
-        }
-        a = o;
-      },
-      now() {
-        return Mr();
-      }
-    }, t && t.on(_r, (o, i) => {
-      o === this.plugin.id && this.fallbacks.setSettings(i);
-    }), this.proxiedOn = new Proxy({}, {
-      get: (o, i) => this.target ? this.target.on[i] : (...l) => {
-        this.onQueue.push({
-          method: i,
-          args: l
-        });
-      }
-    }), this.proxiedTarget = new Proxy({}, {
-      get: (o, i) => this.target ? this.target[i] : i === "on" ? this.proxiedOn : Object.keys(this.fallbacks).includes(i) ? (...l) => (this.targetQueue.push({
-        method: i,
-        args: l,
-        resolve: () => {
-        }
-      }), this.fallbacks[i](...l)) : (...l) => new Promise((c) => {
-        this.targetQueue.push({
-          method: i,
-          args: l,
-          resolve: c
-        });
-      })
-    });
-  }
-  async setRealTarget(r) {
-    this.target = r;
-    for (const t of this.onQueue)
-      this.target.on[t.method](...t.args);
-    for (const t of this.targetQueue)
-      t.resolve(await this.target[t.method](...t.args));
-  }
-}
-function Sr(e, r) {
-  const t = e, n = xe(), s = yr(), a = wr && t.enableEarlyProxy;
-  if (s && (n.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !a))
-    s.emit(br, e, r);
-  else {
-    const o = a ? new Cr(t, s) : null;
-    (n.__VUE_DEVTOOLS_PLUGINS__ = n.__VUE_DEVTOOLS_PLUGINS__ || []).push({
-      pluginDescriptor: t,
-      setupFn: r,
-      proxy: o
-    }), o && r(o.proxiedTarget);
-  }
-}
-function xr(e, r) {
-  const t = `▲ ■ ●${e}`;
-  typeof __VUE_DEVTOOLS_TOAST__ == "function" ? __VUE_DEVTOOLS_TOAST__(t, r) : r === "error" ? console.error(t) : r === "warn" ? console.warn(t) : console.log(t);
-}
-const Pe = (e) => {
-  const r = {
-    id: e.uuid,
-    label: e.type,
-    children: [],
-    tags: []
-  };
-  e.name !== "" && r.tags.push({
-    label: e.name,
-    textColor: 5750629,
-    backgroundColor: 15793395
-  });
-  const t = Se(e);
-  return t > 0 && r.tags.push({
-    label: `${pr(t)} KB`,
-    textColor: 15707189,
-    backgroundColor: 16775644,
-    tooltip: "Memory usage"
-  }), e.type.includes("Light") && (r.tags.push({
-    label: `${e.intensity}`,
-    textColor: 9738662,
-    backgroundColor: 16316922,
-    tooltip: "Intensity"
-  }), r.tags.push({
-    label: `#${e.color.getHexString()}`,
-    textColor: 9738662,
-    backgroundColor: 16316922,
-    tooltip: "Color"
-  })), e.type.includes("Camera") && (r.tags.push({
-    label: `${e.fov}°`,
-    textColor: 9738662,
-    backgroundColor: 16316922,
-    tooltip: "Field of view"
-  }), r.tags.push({
-    // eslint-disable-next-line max-len
-    label: `x: ${Math.round(e.position.x)} y: ${Math.round(e.position.y)} z: ${Math.round(e.position.z)}`,
-    textColor: 9738662,
-    backgroundColor: 16316922,
-    tooltip: "Position"
-  })), r;
-};
-function ke(e, r) {
-  e.children.forEach((t) => {
-    if (t.type === "HightlightMesh")
-      return;
-    const n = Pe(t);
-    r.children.push(n), ke(t, n);
-  });
-}
-const Pr = [], B = "tres:inspector", kr = ge({
-  sceneGraph: null
-});
-function Ar(e, r) {
-  Sr(
-    {
-      id: "dev.esm.tres",
-      label: "TresJS 🪐",
-      logo: "https://raw.githubusercontent.com/Tresjs/tres/main/public/favicon.svg",
-      packageName: "tresjs",
-      homepage: "https://tresjs.org",
-      componentStateTypes: Pr,
-      app: e
-    },
-    (t) => {
-      typeof t.now != "function" && xr(
-        // eslint-disable-next-line max-len
-        "You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html."
-      ), t.addInspector({
-        id: B,
-        label: "TresJS 🪐",
-        icon: "account_tree",
-        treeFilterPlaceholder: "Search instances"
-      }), setInterval(() => {
-        t.sendInspectorTree(B);
-      }, 1e3), setInterval(() => {
-        t.notifyComponentUpdate();
-      }, 5e3), t.on.getInspectorTree((a) => {
-        if (a.inspectorId === B) {
-          const o = Pe(r.scene.value);
-          ke(r.scene.value, o), kr.sceneGraph = o, a.rootNodes = [o];
-        }
-      });
-      let n = null, s = null;
-      t.on.getInspectorState((a) => {
-        if (a.inspectorId === B) {
-          const [o] = r.scene.value.getObjectsByProperty("uuid", a.nodeId);
-          if (!o)
-            return;
-          if (s && n && n.parent && s.remove(n), o.isMesh) {
-            const i = ir(o);
-            o.add(i), n = i, s = o;
-          }
-          a.state = {
-            object: [
-              {
-                key: "uuid",
-                editable: !0,
-                value: o.uuid
-              },
-              {
-                key: "name",
-                editable: !0,
-                value: o.name
-              },
-              {
-                key: "type",
-                editable: !0,
-                value: o.type
-              },
-              {
-                key: "position",
-                editable: !0,
-                value: o.position
-              },
-              {
-                key: "rotation",
-                editable: !0,
-                value: o.rotation
-              },
-              {
-                key: "scale",
-                editable: !0,
-                value: o.scale
-              },
-              {
-                key: "geometry",
-                value: o.geometry
-              },
-              {
-                key: "material",
-                value: o.material
-              },
-              {
-                key: "color",
-                editable: !0,
-                value: o.color
-              },
-              {
-                key: "intensity",
-                editable: !0,
-                value: o.intensity
-              },
-              {
-                key: "castShadow",
-                editable: !0,
-                value: o.castShadow
-              },
-              {
-                key: "receiveShadow",
-                editable: !0,
-                value: o.receiveShadow
-              },
-              {
-                key: "frustumCulled",
-                editable: !0,
-                value: o.frustumCulled
-              },
-              {
-                key: "matrixAutoUpdate",
-                editable: !0,
-                value: o.matrixAutoUpdate
-              },
-              {
-                key: "matrixWorldNeedsUpdate",
-                editable: !0,
-                value: o.matrixWorldNeedsUpdate
-              },
-              {
-                key: "matrixWorld",
-                value: o.matrixWorld
-              },
-              {
-                key: "visible",
-                editable: !0,
-                value: o.visible
-              }
-            ]
-          };
-        }
-      }), t.on.editInspectorState((a) => {
-        a.inspectorId === B && sr(r.scene.value, a.nodeId, a.path, a.state.value);
-      });
-    }
-  );
-}
-const Tr = ["data-scene", "data-tres"], Lr = /* @__PURE__ */ ne({
+}, { render: vt } = ye(dt);
+q(be);
+const gt = ["data-scene"], yt = /* @__PURE__ */ J({
   __name: "TresCanvas",
   props: {
     shadows: { type: Boolean, default: void 0 },
@@ -1070,205 +612,107 @@ const Tr = ["data-scene", "data-tres"], Lr = /* @__PURE__ */ ne({
     logarithmicDepthBuffer: { type: Boolean, default: void 0 },
     failIfMajorPerformanceCaveat: { type: Boolean, default: void 0 }
   },
-  setup(e, { expose: r }) {
-    var y;
-    const t = e, { logWarning: n } = T(), s = R(), a = D(new at()), { resume: o } = te(), i = ze(), l = (y = oe()) == null ? void 0 : y.appContext.app, c = (f) => ne({
+  setup(e, { expose: a }) {
+    var w;
+    const t = e, { logWarning: r } = x(), n = B(), o = L(new Fe()), { resume: u } = ie(), s = he(), l = (w = K()) == null ? void 0 : w.appContext.app, c = (m) => J({
       setup() {
-        var _;
-        const h = (_ = oe()) == null ? void 0 : _.appContext;
-        return h && (h.app = l), q("useTres", f), q("extend", re), typeof window < "u" && Ar(h.app, f), () => se(Je, null, i != null && i.default ? i.default() : []);
+        var d;
+        const h = (d = K()) == null ? void 0 : d.appContext;
+        return h && (h.app = l), G("useTres", m), G("extend", q), () => X(Pe, null, s != null && s.default ? s.default() : []);
       }
-    }), p = (f) => {
-      const h = c(f);
-      hr(se(h), a.value);
-    }, d = (f, h = !1) => {
-      a.value.children = [], h && (f.renderer.value.dispose(), f.renderer.value.renderLists.dispose(), f.renderer.value.forceContextLoss()), p(f), o();
-    }, u = P(() => t.disableRender), m = D(null);
-    return r({ context: m, dispose: () => d(m.value, !0) }), Ne(() => {
-      const f = s;
-      m.value = mr({
-        scene: a.value,
-        canvas: f,
+    }), p = (m) => {
+      const h = c(m);
+      vt(X(h), o.value);
+    }, f = (m, h = !1) => {
+      o.value.children = [], h && (m.renderer.value.dispose(), m.renderer.value.renderLists.dispose(), m.renderer.value.forceContextLoss()), p(m), u();
+    }, i = k(() => t.disableRender), v = L(null);
+    return a({ context: v, dispose: () => f(v.value, !0) }), we(() => {
+      const m = n;
+      v.value = mt({
+        scene: o.value,
+        canvas: m,
         windowSize: t.windowSize,
-        disableRender: u,
+        disableRender: i,
         rendererOptions: t
-      }), fr({ scene: a.value, contextParts: m.value });
-      const { registerCamera: h, camera: _, cameras: w, deregisterCamera: C } = m.value;
-      p(m.value);
-      const S = () => {
-        const b = new K(
+      }), ct({ scene: o.value, contextParts: v.value });
+      const { registerCamera: h, camera: d, cameras: M, deregisterCamera: P } = v.value;
+      p(v.value);
+      const b = () => {
+        const E = new W(
           45,
           window.innerWidth / window.innerHeight,
           0.1,
           1e3
         );
-        b.position.set(3, 3, 3), b.lookAt(0, 0, 0), h(b);
-        const x = O(() => {
-          w.value.length >= 2 && (b.removeFromParent(), C(b), x == null || x());
+        E.position.set(3, 3, 3), E.lookAt(0, 0, 0), h(E);
+        const A = D(() => {
+          M.value.length >= 2 && (E.removeFromParent(), P(E), A == null || A());
         });
       };
-      me(
+      ne(
         () => t.camera,
-        (b, x) => {
-          b && h(b), x && (x.removeFromParent(), C(x));
+        (E, A) => {
+          E && h(E), A && (A.removeFromParent(), P(A));
         },
         {
           immediate: !0
         }
-      ), _.value || (n(
+      ), d.value || (r(
         "No camera found. Creating a default perspective camera. To have full control over a camera, please add one to the scene."
-      ), S());
-    }), (f, h) => (Ve(), We("canvas", {
+      ), b());
+    }), (m, h) => (Ee(), _e("canvas", {
       ref_key: "canvas",
-      ref: s,
-      "data-scene": a.value.uuid,
-      class: Ue(f.$attrs.class),
-      "data-tres": `tresjs ${Fe(Ft).version}`,
-      style: Ge({
+      ref: n,
+      "data-scene": o.value.uuid,
+      class: Ce(m.$attrs.class),
+      style: Me({
         display: "block",
         width: "100%",
         height: "100%",
-        position: f.windowSize ? "fixed" : "relative",
+        position: m.windowSize ? "fixed" : "relative",
         top: 0,
         left: 0,
         pointerEvents: "auto",
         touchAction: "none",
-        ...f.$attrs.style
+        ...m.$attrs.style
       })
-    }, null, 14, Tr));
+    }, null, 14, gt));
   }
-}), Or = [
+}), ht = [
   "TresCanvas",
   "TresLeches",
   "TresScene"
-], Dr = {
+], wt = {
   template: {
     compilerOptions: {
-      isCustomElement: (e) => e.startsWith("Tres") && !Or.includes(e) || e === "primitive"
-    }
-  }
-}, Qr = Dr, Yr = {
-  mounted: (e, r) => {
-    if (r.arg) {
-      console.log(`v-log:${r.arg}`, e[r.arg]);
-      return;
-    }
-    console.log("v-log", e);
-  }
-};
-class Ae extends lt {
-  constructor(r, t) {
-    const n = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], s = new ie();
-    s.setAttribute("position", new ae(n, 3)), s.computeBoundingSphere();
-    const a = new ut({ fog: !1 });
-    super(s, a), this.light = r, this.color = t, this.type = "RectAreaLightHelper";
-    const o = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], i = new ie();
-    i.setAttribute("position", new ae(o, 3)), i.computeBoundingSphere(), this.add(new ct(i, new ye({ side: dt, fog: !1 })));
-  }
-  updateMatrixWorld() {
-    if (this.scale.set(0.5 * this.light.width, 0.5 * this.light.height, 1), this.color !== void 0)
-      this.material.color.set(this.color), this.children[0].material.color.set(this.color);
-    else {
-      this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
-      const r = this.material.color, t = Math.max(r.r, r.g, r.b);
-      t > 1 && r.multiplyScalar(1 / t), this.children[0].material.color.copy(this.material.color);
+      isCustomElement: (e) => e.startsWith("Tres") && !ht.includes(e) || e === "primitive"
     }
-    this.matrixWorld.extractRotation(this.light.matrixWorld).scale(this.scale).copyPosition(this.light.matrixWorld), this.children[0].matrixWorld.copy(this.matrixWorld);
-  }
-  dispose() {
-    this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
   }
-}
-const { logWarning: pe } = T();
-let N, A;
-const Br = {
-  DirectionalLight: ft,
-  PointLight: pt,
-  SpotLight: mt,
-  HemisphereLight: gt,
-  RectAreaLight: Ae
-}, qr = {
-  mounted: (e) => {
-    if (!e.isLight) {
-      pe(`${e.type} is not a light`);
-      return;
-    }
-    N = Br[e.type], e.parent.add(new N(e, 1, e.color.getHex()));
-  },
-  updated: (e) => {
-    A = e.parent.children.find((r) => r instanceof N), !(A instanceof Ae) && A.update();
-  },
-  unmounted: (e) => {
-    if (!e.isLight) {
-      pe(`${e.type} is not a light`);
-      return;
-    }
-    A = e.parent.children.find((r) => r instanceof N), A && A.dispose && A.dispose(), e.parent.remove(A);
-  }
-}, { logWarning: jr } = T(), Kr = {
-  updated: (e, r) => {
-    const t = Ce(r);
-    if (!t) {
-      jr(`v-always-look-at: problem with binding value: ${r.value}`);
-      return;
-    }
-    const { onLoop: n } = te();
-    n(() => {
-      e.lookAt(t);
-    });
-  }
-}, { logWarning: Hr } = T(), Xr = {
-  updated: (e, r) => {
-    var s;
-    const t = Ce(r);
-    if (!t) {
-      Hr(`v-distance-to: problem with binding value: ${r.value}`);
-      return;
-    }
-    k && (k.dispose(), e.parent.remove(k));
-    const n = t.clone().sub(e.position);
-    n.normalize(), k = new vt(n, e.position, e.position.distanceTo(t), 16776960), e.parent.add(k), console.table(
-      [
-        ["Distance:", e.position.distanceTo(t)],
-        [`origin: ${e.name || e.type}`, `x:${e.position.x}, y:${e.position.y}, z:${(s = e.position) == null ? void 0 : s.z}`],
-        [`Destiny: ${e.name || e.type}`, `x:${t.x}, y:${t.y}, z:${t == null ? void 0 : t.z}`]
-      ]
-    );
-  },
-  unmounted: (e) => {
-    k == null || k.dispose(), e.parent.remove(k);
-  }
-};
-let k = null;
-const Zr = {
+}, Lt = wt, St = {
   install(e) {
-    e.component("TresCanvas", Lr);
+    e.component("TresCanvas", yt);
   }
 };
 export {
-  Lr as TresCanvas,
-  X as catalogue,
-  Zr as default,
-  re as extend,
-  Vr as isProd,
-  qt as normalizeColor,
-  Wr as normalizeVectorFlexibleParam,
-  Qr as templateCompilerOptions,
-  cr as trasverseObjects,
-  Gt as useCamera,
-  Ur as useLoader,
-  T as useLogger,
-  fr as usePointerEventHandler,
-  dr as useRaycaster,
-  te as useRenderLoop,
-  lr as useRenderer,
-  Gr as useSeek,
-  Fr as useTexture,
-  Jr as useTres,
-  gr as useTresContext,
-  mr as useTresContextProvider,
-  Kr as vAlwaysLookAt,
-  Xr as vDistanceTo,
-  qr as vLightHelper,
-  Yr as vLog
+  yt as TresCanvas,
+  U as catalogue,
+  St as default,
+  q as extend,
+  Pt as isProd,
+  Xe as normalizeColor,
+  bt as normalizeVectorFlexibleParam,
+  Lt as templateCompilerOptions,
+  lt as trasverseObjects,
+  Ye as useCamera,
+  At as useLoader,
+  x as useLogger,
+  ct as usePointerEventHandler,
+  ut as useRaycaster,
+  ie as useRenderLoop,
+  st as useRenderer,
+  Dt as useSeek,
+  kt as useTexture,
+  Tt as useTres,
+  pt as useTresContext,
+  mt as useTresContextProvider
 };
diff --git a/node_modules/@tresjs/core/dist/tres.umd.cjs b/node_modules/@tresjs/core/dist/tres.umd.cjs
index 4039fc1..2ebbc15 100644
--- a/node_modules/@tresjs/core/dist/tres.umd.cjs
+++ b/node_modules/@tresjs/core/dist/tres.umd.cjs
@@ -1,8 +1,8 @@
 /**
  * name: @tresjs/core
- * version: v3.7.0
+ * version: v3.6.0
  * (c) 2024
  * description: Declarative ThreeJS using Vue Components
  * author: Alvaro Saburido <hola@alvarosaburido.dev> (https://github.com/alvarosabu/)
  */
-(function(h,u){typeof exports=="object"&&typeof module<"u"?u(exports,require("vue"),require("three"),require("@vueuse/core")):typeof define=="function"&&define.amd?define(["exports","vue","three","@vueuse/core"],u):(h=typeof globalThis<"u"?globalThis:h||self,u(h.tres={},h.Vue,h.Three,h.VueUseCore))})(this,function(h,u,f,v){"use strict";var _t=Object.defineProperty;var Ct=(h,u,f)=>u in h?_t(h,u,{enumerable:!0,configurable:!0,writable:!0,value:f}):h[u]=f;var Q=(h,u,f)=>(Ct(h,typeof u!="symbol"?u+"":u,f),f);function Ce(e){const r=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(e){for(const t in e)if(t!=="default"){const n=Object.getOwnPropertyDescriptor(e,t);Object.defineProperty(r,t,n.get?n:{enumerable:!0,get:()=>e[t]})}}return r.default=e,Object.freeze(r)}const Y=Ce(f),Me={name:"@tresjs/core",type:"module",version:"3.7.0",packageManager:"pnpm@8.10.2",description:"Declarative ThreeJS using Vue Components",author:"Alvaro Saburido <hola@alvarosaburido.dev> (https://github.com/alvarosabu/)",license:"MIT",keywords:["vue","3d","threejs","three","threejs-vue"],sideEffects:!1,exports:{".":{types:"./dist/index.d.ts",require:"./dist/tres.umd.cjs",import:"./dist/tres.js"},"./components":{types:"./dist/components/index.d.ts"},"./composables":{types:"./dist/composables/index.d.ts"},"./types":{types:"./dist/types/index.d.ts"},"./utils":{types:"./dist/utils/index.d.ts"},"./*":"./*"},main:"./dist/tres.js",module:"./dist/tres.js",types:"./dist/index.d.ts",files:["dist","*.d.ts"],publishConfig:{access:"public"},scripts:{dev:"cd playground && npm run dev",build:"vite build",playground:"cd playground && npm run dev",test:"vitest","test:ci":"vitest run","test:ui":"vitest --ui",release:"release-it",coverage:"vitest run --coverage",lint:"eslint . --ext .js,.jsx,.ts,.tsx,.vue","docs:dev":"vitepress dev docs","docs:build":"vitepress build docs","docs:serve":"vitepress serve docs","docs:preview":"vitepress preview docs","docs:contributors":"esno scripts/update-contributors.ts"},peerDependencies:{three:">=0.133",vue:">=3.3"},dependencies:{"@alvarosabu/utils":"^3.1.1","@vueuse/core":"^10.7.0"},devDependencies:{"@release-it/conventional-changelog":"^8.0.1","@stackblitz/sdk":"^1.9.0","@tresjs/cientos":"3.6.0","@tresjs/eslint-config-vue":"^0.2.1","@types/three":"^0.159.0","@typescript-eslint/eslint-plugin":"^6.14.0","@typescript-eslint/parser":"^6.14.0","@vitejs/plugin-vue":"^4.5.2","@vitest/coverage-c8":"^0.33.0","@vitest/ui":"^1.0.4","@vue/test-utils":"^2.4.3",eslint:"^8.55.0","eslint-plugin-vue":"^9.19.2",esno:"^4.0.0",gsap:"^3.12.3",jsdom:"^23.0.1",kolorist:"^1.8.0",ohmyfetch:"^0.4.21",pathe:"^1.1.1","release-it":"^17.0.1","rollup-plugin-analyzer":"^4.0.0","rollup-plugin-copy":"^3.5.0","rollup-plugin-visualizer":"^5.11.0",three:"^0.159.0",unocss:"^0.58.0",unplugin:"^1.5.1","unplugin-vue-components":"^0.26.0",vite:"^5.0.8","vite-plugin-banner":"^0.7.1","vite-plugin-dts":"3.6.4","vite-plugin-inspect":"^0.8.1","vite-plugin-require-transform":"^1.0.21","vite-svg-loader":"^5.1.0",vitepress:"1.0.0-rc.31",vitest:"^1.0.4",vue:"^3.3.11","vue-demi":"^0.14.6"}},K=({sizes:e,scene:r})=>{const t=u.ref([]),n=u.computed(()=>t.value[0]),s=(i,l=!1)=>{t.value.some(({uuid:d})=>d===i.uuid)||(l?o(i):t.value.push(i))},a=i=>{t.value=t.value.filter(({uuid:l})=>l!==i.uuid)},o=i=>{const l=i instanceof f.Camera?i:t.value.find(g=>g.uuid===i);if(!l)return;const d=t.value.filter(({uuid:g})=>g!==l.uuid);t.value=[l,...d]};return u.watchEffect(()=>{e.aspectRatio.value&&t.value.forEach(i=>{i instanceof f.PerspectiveCamera&&(i.aspect=e.aspectRatio.value),(i instanceof f.PerspectiveCamera||i instanceof f.OrthographicCamera)&&i.updateProjectionMatrix()})}),r.userData.tres__registerCamera=s,r.userData.tres__deregisterCamera=a,u.onUnmounted(()=>{t.value=[]}),{camera:n,cameras:t,registerCamera:s,deregisterCamera:a,setCameraActive:o}},X=v.createEventHook(),Z=v.createEventHook(),R=v.createEventHook(),j=new f.Clock;let $=0,I=0;const{pause:Se,resume:Pe,isActive:ke}=v.useRafFn(()=>{X.trigger({delta:$,elapsed:I,clock:j}),Z.trigger({delta:$,elapsed:I,clock:j}),R.trigger({delta:$,elapsed:I,clock:j})},{immediate:!1});R.on(()=>{$=j.getDelta(),I=j.getElapsedTime()});const E=()=>({onBeforeLoop:X.on,onLoop:Z.on,onAfterLoop:R.on,pause:Se,resume:Pe,isActive:ke}),Ae=!0,ee="[TresJS ▲ ■ ●] ";function x(){function e(n,s){console.error(`${ee} ${n}`,s||"")}function r(n){console.warn(`${ee} ${n}`)}function t(n,s){}return{logError:e,logWarning:r,logMessage:t}}function Le(e){return typeof e=="number"?[e,e,e]:e instanceof f.Vector3?[e.x,e.y,e.z]:e}function te(e){return e instanceof f.Color?e:Array.isArray(e)?new f.Color(...e):new f.Color(e)}class Oe extends Y.Mesh{constructor(...t){super(...t);Q(this,"type","HightlightMesh");Q(this,"createTime");this.createTime=Date.now()}onBeforeRender(){const n=(Date.now()-this.createTime)/1e3,o=1+.07*Math.sin(2.5*n);this.scale.set(o,o,o)}}const re=(e,r)=>{for(const t of Object.keys(r))r[t]instanceof Object&&Object.assign(r[t],re(e[t],r[t]));return Object.assign(e||{},r),e},xe=De("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot");function ne(e){return e&&e.nodeType===1}function z(e){return e.replace(/-([a-z])/g,(r,t)=>t.toUpperCase())}function De(e,r){const t=Object.create(null),n=e.split(",");for(let s=0;s<n.length;s++)t[n[s]]=!0;return r?s=>!!t[s.toLowerCase()]:s=>!!t[s]}const Be=(e,r)=>{const t=new Set,n=[];for(const s of e){const a=r(s);t.has(a)||(t.add(a),n.push(s))}return n},oe=(e,r)=>{if(!r)return;const t=Array.isArray(r)?r:r.match(/([^[.\]])+/g);return t==null?void 0:t.reduce((n,s)=>n&&n[s],e)},Te=(e,r,t)=>{const n=Array.isArray(r)?r:r.match(/([^[.\]])+/g);n&&n.reduce((s,a,o)=>(s[a]===void 0&&(s[a]={}),o===n.length-1&&(s[a]=t),s[a]),e)};function se(e,r){if(ne(e)&&ne(r)){const s=e.attributes,a=r.attributes;return s.length!==a.length?!1:Array.from(s).every(({name:o,value:i})=>r.getAttribute(o)===i)}if(e===r)return!0;if(e===null||typeof e!="object"||r===null||typeof r!="object")return!1;const t=Object.keys(e),n=Object.keys(r);if(t.length!==n.length)return!1;for(const s of t)if(!n.includes(s)||!se(e[s],r[s]))return!1;return!0}function je(e,r){if(!Array.isArray(e)||!Array.isArray(r)||e.length!==r.length)return!1;for(let t=0;t<e.length;t++)if(!se(e[t],r[t]))return!1;return!0}const Ve=Array.isArray;function $e(e,r,t,n){const s=l=>{if(l.uuid===r)return l;for(const d of l.children){const g=s(d);if(g)return g}},a=s(e);if(!a){console.warn("Object with UUID not found in the scene.");return}let o=a;for(let l=0;l<t.length-1;l++)if(o[t[l]]!==void 0)o=o[t[l]];else{console.warn(`Property path is not valid: ${t.join(".")}`);return}const i=t[t.length-1];o[i]!==void 0?o[i]=n:console.warn(`Property path is not valid: ${t.join(".")}`)}function Ie(e){const r=new f.MeshBasicMaterial({color:11003607,transparent:!0,opacity:.2,depthTest:!1,side:f.DoubleSide});return new Oe(e.geometry.clone(),r)}function ie(e){var t;let r=e.value;return e.value&&((t=e.value)!=null&&t.isMesh)&&(r=e.value.position),Array.isArray(e.value)&&(r=new f.Vector3(...r)),r}const Ee=Number.parseInt(f.REVISION.replace("dev","")),N={realistic:{shadows:!0,physicallyCorrectLights:!0,outputColorSpace:f.SRGBColorSpace,toneMapping:f.ACESFilmicToneMapping,toneMappingExposure:3,shadowMap:{enabled:!0,type:f.PCFSoftShadowMap}}};function ae({scene:e,canvas:r,options:t,disableRender:n,contextParts:{sizes:s,camera:a}}){const o=u.computed(()=>({alpha:v.toValue(t.alpha),depth:v.toValue(t.depth),canvas:v.unrefElement(r),context:v.toValue(t.context),stencil:v.toValue(t.stencil),antialias:v.toValue(t.antialias)===void 0?!0:v.toValue(t.antialias),precision:v.toValue(t.precision),powerPreference:v.toValue(t.powerPreference),premultipliedAlpha:v.toValue(t.premultipliedAlpha),preserveDrawingBuffer:v.toValue(t.preserveDrawingBuffer),logarithmicDepthBuffer:v.toValue(t.logarithmicDepthBuffer),failIfMajorPerformanceCaveat:v.toValue(t.failIfMajorPerformanceCaveat)})),i=u.shallowRef(new f.WebGLRenderer(o.value));u.watch(o,()=>{i.value.dispose(),i.value=new f.WebGLRenderer(o.value)}),u.watchEffect(()=>{i.value.setSize(s.width.value,s.height.value)});const{pixelRatio:l}=v.useDevicePixelRatio();u.watchEffect(()=>{i.value.setPixelRatio(l.value)});const{logError:d}=x(),p=(()=>{const m=new f.WebGLRenderer,_={shadowMap:{enabled:m.shadowMap.enabled,type:m.shadowMap.type},toneMapping:m.toneMapping,toneMappingExposure:m.toneMappingExposure,outputColorSpace:m.outputColorSpace};return m.dispose(),_})();u.watchEffect(()=>{const m=v.toValue(t.preset);m&&(m in N||d(`Renderer Preset must be one of these: ${Object.keys(N).join(", ")}`),re(i.value,N[m]));const _=(A,L)=>{const S=v.toValue(A),O=()=>{if(m)return oe(N[m],L)};if(S!==void 0)return S;const b=O();return b!==void 0?b:oe(p,L)},P=(A,L)=>Te(i.value,L,_(A,L));P(t.shadows,"shadowMap.enabled"),P(t.toneMapping,"toneMapping"),P(t.shadowMapType,"shadowMap.type"),Ee<150&&P(!t.useLegacyLights,"physicallyCorrectLights"),P(t.outputColorSpace,"outputColorSpace"),P(t.toneMappingExposure,"toneMappingExposure");const M=_(t.clearColor,"clearColor");M&&i.value.setClearColor(M?te(M):new f.Color(0))});const{pause:c,resume:w,onLoop:C}=E();return C(()=>{a.value&&!v.toValue(n)&&i.value.render(e,a.value)}),w(),u.onUnmounted(()=>{c(),i.value.dispose(),i.value.forceContextLoss()}),{renderer:i}}const le=e=>typeof e=="function",ze=e=>!!e&&e.constructor===Array;function ue(e){const r={nodes:{},materials:{}};return e&&e.traverse(t=>{t.name&&(r.nodes[t.name]=t),t.material&&!r.materials[t.material.name]&&(r.materials[t.material.name]=t.material)}),r}async function Ne(e,r,t,n,s){const{logError:a}=x(),o=new e;s&&s(o),t&&t(o);const l=(Array.isArray(r)?r:[r]).map(d=>new Promise((g,p)=>{o.load(d,c=>{c.scene&&Object.assign(c,ue(c.scene)),g(c)},n,c=>p(a("[useLoader] - Failed to load resource",c)))}));return ze(r)?await Promise.all(l):await l[0]}async function Ue(e){const r=new f.LoadingManager,t=new f.TextureLoader(r),n=s=>new Promise((a,o)=>{t.load(s,i=>a(i),()=>null,()=>{o(new Error("[useTextures] - Failed to load texture"))})});if(Ve(e)){const s=await Promise.all(e.map(a=>n(a)));return e.length>1?s:s[0]}else{const{map:s,displacementMap:a,normalMap:o,roughnessMap:i,metalnessMap:l,aoMap:d,alphaMap:g,matcap:p}=e;return{map:s?await n(s):null,displacementMap:a?await n(a):null,normalMap:o?await n(o):null,roughnessMap:i?await n(i):null,metalnessMap:l?await n(l):null,aoMap:d?await n(d):null,alphaMap:g?await n(g):null,matcap:p?await n(p):null}}}const ce=(e,{renderer:r,camera:t,raycaster:n})=>{const s=u.computed(()=>r.value.domElement),{x:a,y:o}=v.usePointer({target:s}),{width:i,height:l,top:d,left:g}=v.useElementBounding(s),p=({x:b,y:k})=>{if(s.value)return{x:(b-g.value)/i.value*2-1,y:-((k-d.value)/l.value)*2+1}},c=({x:b,y:k})=>{if(t.value)return n.value.setFromCamera(new f.Vector2(b,k),t.value),n.value.intersectObjects(e.value,!1)},w=b=>{const k=p({x:(b==null?void 0:b.clientX)??a.value,y:(b==null?void 0:b.clientY)??o.value});return k?c(k)||[]:[]},C=u.computed(()=>w()),m=v.createEventHook(),_=v.createEventHook(),P=(b,k)=>{b.trigger({event:k,intersects:w(k)})},M=b=>{P(_,b)};let A;const L=b=>{var k;A=(k=w(b)[0])==null?void 0:k.object},S=b=>{var k;b instanceof PointerEvent&&A===((k=w(b)[0])==null?void 0:k.object)&&P(m,b)},O=b=>_.trigger({event:b,intersects:[]});return s.value.addEventListener("pointerup",S),s.value.addEventListener("pointerdown",L),s.value.addEventListener("pointermove",M),s.value.addEventListener("pointerleave",O),u.onUnmounted(()=>{s!=null&&s.value&&(s.value.removeEventListener("pointerup",S),s.value.removeEventListener("pointerdown",L),s.value.removeEventListener("pointermove",M),s.value.removeEventListener("pointerleave",O))}),{intersects:C,onClick:b=>m.on(b).off,onPointerMove:b=>_.on(b).off}};function We(){const{logWarning:e}=x();function r(a,o,i){let l=null;return a.traverse(d=>{d[o]===i&&(l=d)}),l||e(`Child with ${o} '${i}' not found.`),l}function t(a,o,i){const l=[];return a.traverse(d=>{d[o].includes(i)&&l.push(d)}),l.length||e(`Children with ${o} '${i}' not found.`),l}function n(a,o){return r(a,"name",o)}function s(a,o){return t(a,"name",o)}return{seek:r,seekByName:n,seekAll:t,seekAllByName:s}}const de=({scene:e,contextParts:r})=>{const t=u.reactive({click:new Map,pointerMove:new Map,pointerEnter:new Map,pointerLeave:new Map}),n=u.ref(new Set),s=c=>{n.value.add(c)},a=c=>{n.value.delete(c)},o=c=>{Object.values(t).forEach(w=>w.delete(c)),a(c)},i=c=>{const{onClick:w,onPointerMove:C,onPointerEnter:m,onPointerLeave:_}=c;w&&t.click.set(c,w),C&&t.pointerMove.set(c,C),m&&t.pointerEnter.set(c,m),_&&t.pointerLeave.set(c,_)};e.userData.tres__registerAtPointerEventHandler=i,e.userData.tres__deregisterAtPointerEventHandler=o,e.userData.tres__registerBlockingObjectAtPointerEventHandler=s,e.userData.tres__deregisterBlockingObjectAtPointerEventHandler=a;const l=u.computed(()=>Be([...Array.from(n.value),...Object.values(t).map(c=>Array.from(c.keys())).flat()],({uuid:c})=>c)),{onClick:d,onPointerMove:g}=ce(l,r);d(({intersects:c,event:w})=>{var C;c.length&&((C=t.click.get(c[0].object))==null||C(c[0],w))});let p;return g(({intersects:c,event:w})=>{var M,A,L,S;const C=(M=c==null?void 0:c[0])==null?void 0:M.object,{pointerLeave:m,pointerEnter:_,pointerMove:P}=t;p&&p!==C&&((A=m.get(p))==null||A(p,w)),C&&(p!==C&&((L=_.get(C))==null||L(c[0],w)),(S=P.get(C))==null||S(c[0],w)),p=C||null}),{registerObject:i,deregisterObject:o}};function fe(e){let r=0;return e.traverse(t=>{if(t.isMesh&&t.geometry){const n=t.geometry,s=n.attributes.position.count*3*Float32Array.BYTES_PER_ELEMENT,a=n.index?n.index.count*Uint32Array.BYTES_PER_ELEMENT:0,o=n.attributes.normal?n.attributes.normal.count*3*Float32Array.BYTES_PER_ELEMENT:0,i=n.attributes.uv?n.attributes.uv.count*2*Float32Array.BYTES_PER_ELEMENT:0,l=s+a+o+i;r+=l}}),r}function Fe(e){return(e/1024).toFixed(2)}const U=u.ref({}),W=e=>Object.assign(U.value,e);function pe({scene:e,canvas:r,windowSize:t,disableRender:n,rendererOptions:s}){const a=u.computed(()=>v.toValue(t)?v.useWindowSize():v.useElementSize(v.toValue(r).parentElement)),o=u.shallowRef({width:0,height:0}),i=v.refDebounced(o,10),l=u.watchEffect(()=>{o.value={width:a.value.width.value,height:a.value.height.value}}),d=u.computed(()=>i.value.width/i.value.height),g={height:u.computed(()=>i.value.height),width:u.computed(()=>i.value.width),aspectRatio:d},p=u.shallowRef(e),{camera:c,cameras:w,registerCamera:C,deregisterCamera:m,setCameraActive:_}=K({sizes:g,scene:e}),{renderer:P}=ae({scene:e,canvas:r,options:s,contextParts:{sizes:g,camera:c},disableRender:n}),M={sizes:g,scene:p,camera:c,cameras:u.readonly(w),renderer:P,raycaster:u.shallowRef(new f.Raycaster),controls:u.ref(null),perf:{maxFrames:160,fps:{value:0,accumulator:[]},memory:{currentMem:0,allocatedMem:0,accumulator:[]}},extend:W,registerCamera:C,setCameraActive:_,deregisterCamera:m};u.provide("useTres",M);const A=100,L=v.useFps({every:A}),{isSupported:S,memory:O}=v.useMemory({interval:A}),b=160;let k=performance.now();const ht=({timestamp:G})=>{M.scene.value&&(M.perf.memory.allocatedMem=fe(M.scene.value)),G-k>=A&&(k=G,M.perf.fps.accumulator.push(L.value),M.perf.fps.accumulator.length>b&&M.perf.fps.accumulator.shift(),M.perf.fps.value=L.value,S.value&&O.value&&(M.perf.memory.accumulator.push(O.value.usedJSHeapSize/1024/1024),M.perf.memory.accumulator.length>b&&M.perf.memory.accumulator.shift(),M.perf.memory.currentMem=M.perf.memory.accumulator.reduce((wt,bt)=>wt+bt,0)/M.perf.memory.accumulator.length))};let J=0;const vt=1,{pause:yt,resume:Rt}=v.useRafFn(({delta:G})=>{window.__TRES__DEVTOOLS__&&(ht({timestamp:performance.now()}),J+=G,J>=vt&&(window.__TRES__DEVTOOLS__.cb(M),J=0))},{immediate:!0});return u.onUnmounted(()=>{l(),yt()}),M}function me(){const e=u.inject("useTres");if(!e)throw new Error("useTresContext must be used together with useTresContextProvider");return e}const Ge=me;function Ft(e){}let y=null;const{logError:ge}=x(),q=["onClick","onPointerMove","onPointerEnter","onPointerLeave"],Re={createElement(e,r,t,n){var o,i;if(n||(n={}),n.args||(n.args=[]),e==="template"||xe(e))return null;let s=e.replace("Tres",""),a;if(e==="primitive"){(n==null?void 0:n.object)===void 0&&ge("Tres primitives need a prop 'object'");const l=n.object;s=l.type,a=Object.assign(l,{type:s,attach:n.attach,primitive:!0})}else{const l=U.value[s];l||ge(`${s} is not defined on the THREE namespace. Use extend to add it to the catalog.`),a=new l(...n.args)}return a.isCamera&&(n!=null&&n.position||a.position.set(3,3,3),n!=null&&n.lookAt||a.lookAt(0,0,0)),(n==null?void 0:n.attach)===void 0&&(a.isMaterial?a.attach="material":a.isBufferGeometry&&(a.attach="geometry")),a.isObject3D&&((o=n==null?void 0:n.material)!=null&&o.isMaterial&&(a.userData.tres__materialViaProp=!0),(i=n==null?void 0:n.geometry)!=null&&i.isBufferGeometry&&(a.userData.tres__geometryViaProp=!0)),a.userData={...a.userData,tres__name:s},a},insert(e,r){var n,s,a,o;r&&r.isScene&&(y=r);const t=r||y;if(e!=null&&e.isObject3D){if(e!=null&&e.isCamera){if(!(y!=null&&y.userData.tres__registerCamera))throw"could not find tres__registerCamera on scene's userData";(s=y==null?void 0:(n=y.userData).tres__registerCamera)==null||s.call(n,e)}if(e&&q.some(i=>e[i])){if(!(y!=null&&y.userData.tres__registerAtPointerEventHandler))throw"could not find tres__registerAtPointerEventHandler on scene's userData";(o=y==null?void 0:(a=y.userData).tres__registerAtPointerEventHandler)==null||o.call(a,e)}}e!=null&&e.isObject3D&&(t!=null&&t.isObject3D)?(t.add(e),e.dispatchEvent({type:"added"})):e!=null&&e.isFog?t.fog=e:typeof(e==null?void 0:e.attach)=="string"&&(e.__previousAttach=e[t==null?void 0:t.attach],t&&(t[e.attach]=e))},remove(e){var r,t;if(e){if(e.isObject3D){const n=e,s=d=>{var p,c;const g=d;d.userData.tres__materialViaProp||((p=g.material)==null||p.dispose(),g.material=void 0),d.userData.tres__geometryViaProp||((c=g.geometry)==null||c.dispose(),g.geometry=void 0)},a=y==null?void 0:y.userData.tres__deregisterAtPointerEventHandler,o=y==null?void 0:y.userData.tres__deregisterBlockingObjectAtPointerEventHandler,i=d=>{var g,p;if(!o)throw"could not find tres__deregisterBlockingObjectAtPointerEventHandler on scene's userData";if((p=y==null?void 0:(g=y.userData).tres__deregisterBlockingObjectAtPointerEventHandler)==null||p.call(g,d),!a)throw"could not find tres__deregisterAtPointerEventHandler on scene's userData";d&&q.some(c=>d[c])&&(a==null||a(d))},l=d=>{const g=y==null?void 0:y.userData.tres__deregisterCamera;if(!g)throw"could not find tres__deregisterCamera on scene's userData";d.isCamera&&(g==null||g(d))};(r=e.removeFromParent)==null||r.call(e),n.traverse(d=>{s(d),l(d),i==null||i(d)}),s(n),l(n),i==null||i(n)}(t=e.dispose)==null||t.call(e)}},patchProp(e,r,t,n){var s,a,o,i;if(e){let l=e,d=r;if(e.isObject3D&&d==="blocks-pointer-events"){n||n===""?(a=y==null?void 0:(s=y.userData).tres__registerBlockingObjectAtPointerEventHandler)==null||a.call(s,e):(i=y==null?void 0:(o=y.userData).tres__deregisterBlockingObjectAtPointerEventHandler)==null||i.call(o,e);return}let g=z(d),p=l==null?void 0:l[g];if(d==="args"){const w=e,C=t??[],m=n??[],_=e.userData.tres__name||e.type;_&&C.length&&!je(C,m)&&(l=Object.assign(w,new U.value[_](...n)));return}if(l.type==="BufferGeometry"){if(d==="args")return;l.setAttribute(z(d),new f.BufferAttribute(...n));return}if(d.includes("-")&&p===void 0){const w=d.split("-");p=w.reduce((C,m)=>C[z(m)],l),d=w.pop(),g=d.toLowerCase(),p!=null&&p.set||(l=w.reduce((C,m)=>C[z(m)],l))}let c=n;if(c===""&&(c=!0),le(p)){q.includes(r)||(Array.isArray(c)?e[g](...c):e[g](c));return}!(p!=null&&p.set)&&!le(p)?l[g]=c:p.constructor===c.constructor&&(p!=null&&p.copy)?p==null||p.copy(c):Array.isArray(c)?p.set(...c):!p.isColor&&p.setScalar?p.setScalar(c):p.set(c)}},parentNode(e){return(e==null?void 0:e.parent)||null},createText:()=>void 0,createComment:()=>void 0,setText:()=>void 0,setElementText:()=>void 0,nextSibling:()=>void 0,querySelector:()=>void 0,setScopeId:()=>void 0,cloneNode:()=>void 0,insertStaticContent:()=>void 0},{render:qe}=u.createRenderer(Re);W(Y);function He(){return he().__VUE_DEVTOOLS_GLOBAL_HOOK__}function he(){return typeof navigator<"u"&&typeof window<"u"?window:typeof global<"u"?global:{}}const Je=typeof Proxy=="function",Qe="devtools-plugin:setup",Ye="plugin:settings:set";let T,H;function Ke(){var e;return T!==void 0||(typeof window<"u"&&window.performance?(T=!0,H=window.performance):typeof global<"u"&&(!((e=global.perf_hooks)===null||e===void 0)&&e.performance)?(T=!0,H=global.perf_hooks.performance):T=!1),T}function Xe(){return Ke()?H.now():Date.now()}class Ze{constructor(r,t){this.target=null,this.targetQueue=[],this.onQueue=[],this.plugin=r,this.hook=t;const n={};if(r.settings)for(const o in r.settings){const i=r.settings[o];n[o]=i.defaultValue}const s=`__vue-devtools-plugin-settings__${r.id}`;let a=Object.assign({},n);try{const o=localStorage.getItem(s),i=JSON.parse(o);Object.assign(a,i)}catch{}this.fallbacks={getSettings(){return a},setSettings(o){try{localStorage.setItem(s,JSON.stringify(o))}catch{}a=o},now(){return Xe()}},t&&t.on(Ye,(o,i)=>{o===this.plugin.id&&this.fallbacks.setSettings(i)}),this.proxiedOn=new Proxy({},{get:(o,i)=>this.target?this.target.on[i]:(...l)=>{this.onQueue.push({method:i,args:l})}}),this.proxiedTarget=new Proxy({},{get:(o,i)=>this.target?this.target[i]:i==="on"?this.proxiedOn:Object.keys(this.fallbacks).includes(i)?(...l)=>(this.targetQueue.push({method:i,args:l,resolve:()=>{}}),this.fallbacks[i](...l)):(...l)=>new Promise(d=>{this.targetQueue.push({method:i,args:l,resolve:d})})})}async setRealTarget(r){this.target=r;for(const t of this.onQueue)this.target.on[t.method](...t.args);for(const t of this.targetQueue)t.resolve(await this.target[t.method](...t.args))}}function et(e,r){const t=e,n=he(),s=He(),a=Je&&t.enableEarlyProxy;if(s&&(n.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__||!a))s.emit(Qe,e,r);else{const o=a?new Ze(t,s):null;(n.__VUE_DEVTOOLS_PLUGINS__=n.__VUE_DEVTOOLS_PLUGINS__||[]).push({pluginDescriptor:t,setupFn:r,proxy:o}),o&&r(o.proxiedTarget)}}function tt(e,r){const t=`▲ ■ ●${e}`;typeof __VUE_DEVTOOLS_TOAST__=="function"?__VUE_DEVTOOLS_TOAST__(t,r):r==="error"?console.error(t):r==="warn"?console.warn(t):console.log(t)}const ve=e=>{const r={id:e.uuid,label:e.type,children:[],tags:[]};e.name!==""&&r.tags.push({label:e.name,textColor:5750629,backgroundColor:15793395});const t=fe(e);return t>0&&r.tags.push({label:`${Fe(t)} KB`,textColor:15707189,backgroundColor:16775644,tooltip:"Memory usage"}),e.type.includes("Light")&&(r.tags.push({label:`${e.intensity}`,textColor:9738662,backgroundColor:16316922,tooltip:"Intensity"}),r.tags.push({label:`#${e.color.getHexString()}`,textColor:9738662,backgroundColor:16316922,tooltip:"Color"})),e.type.includes("Camera")&&(r.tags.push({label:`${e.fov}°`,textColor:9738662,backgroundColor:16316922,tooltip:"Field of view"}),r.tags.push({label:`x: ${Math.round(e.position.x)} y: ${Math.round(e.position.y)} z: ${Math.round(e.position.z)}`,textColor:9738662,backgroundColor:16316922,tooltip:"Position"})),r};function ye(e,r){e.children.forEach(t=>{if(t.type==="HightlightMesh")return;const n=ve(t);r.children.push(n),ye(t,n)})}const rt=[],V="tres:inspector",nt=u.reactive({sceneGraph:null});function ot(e,r){et({id:"dev.esm.tres",label:"TresJS 🪐",logo:"https://raw.githubusercontent.com/Tresjs/tres/main/public/favicon.svg",packageName:"tresjs",homepage:"https://tresjs.org",componentStateTypes:rt,app:e},t=>{typeof t.now!="function"&&tt("You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html."),t.addInspector({id:V,label:"TresJS 🪐",icon:"account_tree",treeFilterPlaceholder:"Search instances"}),setInterval(()=>{t.sendInspectorTree(V)},1e3),setInterval(()=>{t.notifyComponentUpdate()},5e3),t.on.getInspectorTree(a=>{if(a.inspectorId===V){const o=ve(r.scene.value);ye(r.scene.value,o),nt.sceneGraph=o,a.rootNodes=[o]}});let n=null,s=null;t.on.getInspectorState(a=>{if(a.inspectorId===V){const[o]=r.scene.value.getObjectsByProperty("uuid",a.nodeId);if(!o)return;if(s&&n&&n.parent&&s.remove(n),o.isMesh){const i=Ie(o);o.add(i),n=i,s=o}a.state={object:[{key:"uuid",editable:!0,value:o.uuid},{key:"name",editable:!0,value:o.name},{key:"type",editable:!0,value:o.type},{key:"position",editable:!0,value:o.position},{key:"rotation",editable:!0,value:o.rotation},{key:"scale",editable:!0,value:o.scale},{key:"geometry",value:o.geometry},{key:"material",value:o.material},{key:"color",editable:!0,value:o.color},{key:"intensity",editable:!0,value:o.intensity},{key:"castShadow",editable:!0,value:o.castShadow},{key:"receiveShadow",editable:!0,value:o.receiveShadow},{key:"frustumCulled",editable:!0,value:o.frustumCulled},{key:"matrixAutoUpdate",editable:!0,value:o.matrixAutoUpdate},{key:"matrixWorldNeedsUpdate",editable:!0,value:o.matrixWorldNeedsUpdate},{key:"matrixWorld",value:o.matrixWorld},{key:"visible",editable:!0,value:o.visible}]}}}),t.on.editInspectorState(a=>{a.inspectorId===V&&$e(r.scene.value,a.nodeId,a.path,a.state.value)})})}const st=["data-scene","data-tres"],we=u.defineComponent({__name:"TresCanvas",props:{shadows:{type:Boolean,default:void 0},clearColor:{},toneMapping:{},shadowMapType:{},useLegacyLights:{type:Boolean,default:void 0},outputColorSpace:{},toneMappingExposure:{},camera:{},preset:{},windowSize:{type:Boolean,default:void 0},disableRender:{type:Boolean,default:void 0},context:{},precision:{},alpha:{type:Boolean,default:void 0},premultipliedAlpha:{type:Boolean},antialias:{type:Boolean,default:void 0},stencil:{type:Boolean,default:void 0},preserveDrawingBuffer:{type:Boolean,default:void 0},powerPreference:{},depth:{type:Boolean,default:void 0},logarithmicDepthBuffer:{type:Boolean,default:void 0},failIfMajorPerformanceCaveat:{type:Boolean,default:void 0}},setup(e,{expose:r}){var C;const t=e,{logWarning:n}=x(),s=u.ref(),a=u.shallowRef(new f.Scene),{resume:o}=E(),i=u.useSlots(),l=(C=u.getCurrentInstance())==null?void 0:C.appContext.app,d=m=>u.defineComponent({setup(){var P;const _=(P=u.getCurrentInstance())==null?void 0:P.appContext;return _&&(_.app=l),u.provide("useTres",m),u.provide("extend",W),typeof window<"u"&&ot(_.app,m),()=>u.h(u.Fragment,null,i!=null&&i.default?i.default():[])}}),g=m=>{const _=d(m);qe(u.h(_),a.value)},p=(m,_=!1)=>{a.value.children=[],_&&(m.renderer.value.dispose(),m.renderer.value.renderLists.dispose(),m.renderer.value.forceContextLoss()),g(m),o()},c=u.computed(()=>t.disableRender),w=u.shallowRef(null);return r({context:w,dispose:()=>p(w.value,!0)}),u.onMounted(()=>{const m=s;w.value=pe({scene:a.value,canvas:m,windowSize:t.windowSize,disableRender:c,rendererOptions:t}),de({scene:a.value,contextParts:w.value});const{registerCamera:_,camera:P,cameras:M,deregisterCamera:A}=w.value;g(w.value);const L=()=>{const S=new f.PerspectiveCamera(45,window.innerWidth/window.innerHeight,.1,1e3);S.position.set(3,3,3),S.lookAt(0,0,0),_(S);const O=u.watchEffect(()=>{M.value.length>=2&&(S.removeFromParent(),A(S),O==null||O())})};u.watch(()=>t.camera,(S,O)=>{S&&_(S),O&&(O.removeFromParent(),A(O))},{immediate:!0}),P.value||(n("No camera found. Creating a default perspective camera. To have full control over a camera, please add one to the scene."),L())}),(m,_)=>(u.openBlock(),u.createElementBlock("canvas",{ref_key:"canvas",ref:s,"data-scene":a.value.uuid,class:u.normalizeClass(m.$attrs.class),"data-tres":`tresjs ${u.unref(Me).version}`,style:u.normalizeStyle({display:"block",width:"100%",height:"100%",position:m.windowSize?"fixed":"relative",top:0,left:0,pointerEvents:"auto",touchAction:"none",...m.$attrs.style})},null,14,st))}}),it=["TresCanvas","TresLeches","TresScene"],at={template:{compilerOptions:{isCustomElement:e=>e.startsWith("Tres")&&!it.includes(e)||e==="primitive"}}},lt={mounted:(e,r)=>{if(r.arg){console.log(`v-log:${r.arg}`,e[r.arg]);return}console.log("v-log",e)}};class be extends f.Line{constructor(r,t){const n=[1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],s=new f.BufferGeometry;s.setAttribute("position",new f.Float32BufferAttribute(n,3)),s.computeBoundingSphere();const a=new f.LineBasicMaterial({fog:!1});super(s,a),this.light=r,this.color=t,this.type="RectAreaLightHelper";const o=[1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],i=new f.BufferGeometry;i.setAttribute("position",new f.Float32BufferAttribute(o,3)),i.computeBoundingSphere(),this.add(new f.Mesh(i,new f.MeshBasicMaterial({side:f.BackSide,fog:!1})))}updateMatrixWorld(){if(this.scale.set(.5*this.light.width,.5*this.light.height,1),this.color!==void 0)this.material.color.set(this.color),this.children[0].material.color.set(this.color);else{this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);const r=this.material.color,t=Math.max(r.r,r.g,r.b);t>1&&r.multiplyScalar(1/t),this.children[0].material.color.copy(this.material.color)}this.matrixWorld.extractRotation(this.light.matrixWorld).scale(this.scale).copyPosition(this.light.matrixWorld),this.children[0].matrixWorld.copy(this.matrixWorld)}dispose(){this.geometry.dispose(),this.material.dispose(),this.children[0].geometry.dispose(),this.children[0].material.dispose()}}const{logWarning:_e}=x();let F,B;const ut={DirectionalLight:f.DirectionalLightHelper,PointLight:f.PointLightHelper,SpotLight:f.SpotLightHelper,HemisphereLight:f.HemisphereLightHelper,RectAreaLight:be},ct={mounted:e=>{if(!e.isLight){_e(`${e.type} is not a light`);return}F=ut[e.type],e.parent.add(new F(e,1,e.color.getHex()))},updated:e=>{B=e.parent.children.find(r=>r instanceof F),!(B instanceof be)&&B.update()},unmounted:e=>{if(!e.isLight){_e(`${e.type} is not a light`);return}B=e.parent.children.find(r=>r instanceof F),B&&B.dispose&&B.dispose(),e.parent.remove(B)}},{logWarning:dt}=x(),ft={updated:(e,r)=>{const t=ie(r);if(!t){dt(`v-always-look-at: problem with binding value: ${r.value}`);return}const{onLoop:n}=E();n(()=>{e.lookAt(t)})}},{logWarning:pt}=x(),mt={updated:(e,r)=>{var s;const t=ie(r);if(!t){pt(`v-distance-to: problem with binding value: ${r.value}`);return}D&&(D.dispose(),e.parent.remove(D));const n=t.clone().sub(e.position);n.normalize(),D=new f.ArrowHelper(n,e.position,e.position.distanceTo(t),16776960),e.parent.add(D),console.table([["Distance:",e.position.distanceTo(t)],[`origin: ${e.name||e.type}`,`x:${e.position.x}, y:${e.position.y}, z:${(s=e.position)==null?void 0:s.z}`],[`Destiny: ${e.name||e.type}`,`x:${t.x}, y:${t.y}, z:${t==null?void 0:t.z}`]])},unmounted:e=>{D==null||D.dispose(),e.parent.remove(D)}};let D=null;const gt={install(e){e.component("TresCanvas",we)}};h.TresCanvas=we,h.catalogue=U,h.default=gt,h.extend=W,h.isProd=Ae,h.normalizeColor=te,h.normalizeVectorFlexibleParam=Le,h.templateCompilerOptions=at,h.trasverseObjects=ue,h.useCamera=K,h.useLoader=Ne,h.useLogger=x,h.usePointerEventHandler=de,h.useRaycaster=ce,h.useRenderLoop=E,h.useRenderer=ae,h.useSeek=We,h.useTexture=Ue,h.useTres=Ge,h.useTresContext=me,h.useTresContextProvider=pe,h.vAlwaysLookAt=ft,h.vDistanceTo=mt,h.vLightHelper=ct,h.vLog=lt,Object.defineProperties(h,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
+(function(C,l){typeof exports=="object"&&typeof module<"u"?l(exports,require("vue"),require("three"),require("@vueuse/core")):typeof define=="function"&&define.amd?define(["exports","vue","three","@vueuse/core"],l):(C=typeof globalThis<"u"?globalThis:C||self,l(C.tres={},C.Vue,C.Three,C.VueUseCore))})(this,function(C,l,M,v){"use strict";function ie(e){const a=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(e){for(const t in e)if(t!=="default"){const r=Object.getOwnPropertyDescriptor(e,t);Object.defineProperty(a,t,r.get?r:{enumerable:!0,get:()=>e[t]})}}return a.default=e,Object.freeze(a)}const le=ie(M),I=({sizes:e,scene:a})=>{const t=l.ref([]),r=l.computed(()=>t.value[0]),n=(s,u=!1)=>{t.value.some(({uuid:f})=>f===s.uuid)||(u?c(s):t.value.push(s))},o=s=>{t.value=t.value.filter(({uuid:u})=>u!==s.uuid)},c=s=>{const u=s instanceof M.Camera?s:t.value.find(p=>p.uuid===s);if(!u)return;const f=t.value.filter(({uuid:p})=>p!==u.uuid);t.value=[u,...f]};return l.watchEffect(()=>{e.aspectRatio.value&&t.value.forEach(s=>{s instanceof M.PerspectiveCamera&&(s.aspect=e.aspectRatio.value),(s instanceof M.PerspectiveCamera||s instanceof M.OrthographicCamera)&&s.updateProjectionMatrix()})}),a.userData.tres__registerCamera=n,a.userData.tres__deregisterCamera=o,l.onUnmounted(()=>{t.value=[]}),{camera:r,cameras:t,registerCamera:n,deregisterCamera:o,setCameraActive:c}},W=v.createEventHook(),U=v.createEventHook(),z=v.createEventHook(),E=new M.Clock;let B=0,j=0;const{pause:ue,resume:ce,isActive:fe}=v.useRafFn(()=>{W.trigger({delta:B,elapsed:j,clock:E}),U.trigger({delta:B,elapsed:j,clock:E}),z.trigger({delta:B,elapsed:j,clock:E})},{immediate:!1});z.on(()=>{B=E.getDelta(),j=E.getElapsedTime()});const N=()=>({onBeforeLoop:W.on,onLoop:U.on,onAfterLoop:z.on,pause:ue,resume:ce,isActive:fe}),me=!0,q="[TresJS ▲ ■ ●] ";function S(){function e(r,n){console.error(`${q} ${r}`,n||"")}function a(r){console.warn(`${q} ${r}`)}function t(r,n){}return{logError:e,logWarning:a,logMessage:t}}function de(e){return typeof e=="number"?[e,e,e]:e instanceof M.Vector3?[e.x,e.y,e.z]:e}function H(e){return e instanceof M.Color?e:Array.isArray(e)?new M.Color(...e):new M.Color(e)}const Y=(e,a)=>{for(const t of Object.keys(a))a[t]instanceof Object&&Object.assign(a[t],Y(e[t],a[t]));return Object.assign(e||{},a),e},pe=ge("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot");function J(e){return e&&e.nodeType===1}function T(e){return e.replace(/-([a-z])/g,(a,t)=>t.toUpperCase())}function ge(e,a){const t=Object.create(null),r=e.split(",");for(let n=0;n<r.length;n++)t[r[n]]=!0;return a?n=>!!t[n.toLowerCase()]:n=>!!t[n]}const ve=(e,a)=>{const t=new Set,r=[];for(const n of e){const o=a(n);t.has(o)||(t.add(o),r.push(n))}return r},K=(e,a)=>{if(!a)return;const t=Array.isArray(a)?a:a.match(/([^[.\]])+/g);return t==null?void 0:t.reduce((r,n)=>r&&r[n],e)},ye=(e,a,t)=>{const r=Array.isArray(a)?a:a.match(/([^[.\]])+/g);r&&r.reduce((n,o,c)=>(n[o]===void 0&&(n[o]={}),c===r.length-1&&(n[o]=t),n[o]),e)};function X(e,a){if(J(e)&&J(a)){const n=e.attributes,o=a.attributes;return n.length!==o.length?!1:Array.from(n).every(({name:c,value:s})=>a.getAttribute(c)===s)}if(e===a)return!0;if(e===null||typeof e!="object"||a===null||typeof a!="object")return!1;const t=Object.keys(e),r=Object.keys(a);if(t.length!==r.length)return!1;for(const n of t)if(!r.includes(n)||!X(e[n],a[n]))return!1;return!0}function he(e,a){if(!Array.isArray(e)||!Array.isArray(a)||e.length!==a.length)return!1;for(let t=0;t<e.length;t++)if(!X(e[t],a[t]))return!1;return!0}const we=Array.isArray,Ce=Number.parseInt(M.REVISION.replace("dev","")),x={realistic:{shadows:!0,physicallyCorrectLights:!0,outputColorSpace:M.SRGBColorSpace,toneMapping:M.ACESFilmicToneMapping,toneMappingExposure:3,shadowMap:{enabled:!0,type:M.PCFSoftShadowMap}}};function Q({scene:e,canvas:a,options:t,disableRender:r,contextParts:{sizes:n,camera:o}}){const c=l.computed(()=>({alpha:v.toValue(t.alpha),depth:v.toValue(t.depth),canvas:v.unrefElement(a),context:v.toValue(t.context),stencil:v.toValue(t.stencil),antialias:v.toValue(t.antialias)===void 0?!0:v.toValue(t.antialias),precision:v.toValue(t.precision),powerPreference:v.toValue(t.powerPreference),premultipliedAlpha:v.toValue(t.premultipliedAlpha),preserveDrawingBuffer:v.toValue(t.preserveDrawingBuffer),logarithmicDepthBuffer:v.toValue(t.logarithmicDepthBuffer),failIfMajorPerformanceCaveat:v.toValue(t.failIfMajorPerformanceCaveat)})),s=l.shallowRef(new M.WebGLRenderer(c.value));l.watch(c,()=>{s.value.dispose(),s.value=new M.WebGLRenderer(c.value)}),l.watchEffect(()=>{s.value.setSize(n.width.value,n.height.value)});const{pixelRatio:u}=v.useDevicePixelRatio();l.watchEffect(()=>{s.value.setPixelRatio(u.value)});const{logError:f}=S(),m=(()=>{const d=new M.WebGLRenderer,_={shadowMap:{enabled:d.shadowMap.enabled,type:d.shadowMap.type},toneMapping:d.toneMapping,toneMappingExposure:d.toneMappingExposure,outputColorSpace:d.outputColorSpace};return d.dispose(),_})();l.watchEffect(()=>{const d=v.toValue(t.preset);d&&(d in x||f(`Renderer Preset must be one of these: ${Object.keys(x).join(", ")}`),Y(s.value,x[d]));const _=(L,D)=>{const b=v.toValue(L),O=()=>{if(d)return K(x[d],D)};if(b!==void 0)return b;const w=O();return w!==void 0?w:K(m,D)},g=(L,D)=>ye(s.value,D,_(L,D));g(t.shadows,"shadowMap.enabled"),g(t.toneMapping,"toneMapping"),g(t.shadowMapType,"shadowMap.type"),Ce<150&&g(!t.useLegacyLights,"physicallyCorrectLights"),g(t.outputColorSpace,"outputColorSpace"),g(t.toneMappingExposure,"toneMappingExposure");const k=_(t.clearColor,"clearColor");k&&s.value.setClearColor(k?H(k):new M.Color(0))});const{pause:i,resume:h,onLoop:P}=N();return P(()=>{o.value&&!v.toValue(r)&&s.value.render(e,o.value)}),h(),l.onUnmounted(()=>{i(),s.value.dispose(),s.value.forceContextLoss()}),{renderer:s}}const Z=e=>typeof e=="function",_e=e=>!!e&&e.constructor===Array;function ee(e){const a={nodes:{},materials:{}};return e&&e.traverse(t=>{t.name&&(a.nodes[t.name]=t),t.material&&!a.materials[t.material.name]&&(a.materials[t.material.name]=t.material)}),a}async function Pe(e,a,t,r,n){const{logError:o}=S(),c=new e;n&&n(c),t&&t(c);const u=(Array.isArray(a)?a:[a]).map(f=>new Promise((p,m)=>{c.load(f,i=>{i.scene&&Object.assign(i,ee(i.scene)),p(i)},r,i=>m(o("[useLoader] - Failed to load resource",i)))}));return _e(a)?await Promise.all(u):await u[0]}async function Me(e,a){const t=new M.TextureLoader(a),r=n=>new Promise((o,c)=>{t.load(n,s=>o(s),()=>null,()=>{c(new Error("[useTextures] - Failed to load texture"))})});if(we(e)){const n=await Promise.all(e.map(o=>r(o)));return e.length>1?n:n[0]}else{const{map:n,displacementMap:o,normalMap:c,roughnessMap:s,metalnessMap:u,aoMap:f,alphaMap:p,matcap:m}=e;return{map:n?await r(n):null,displacementMap:o?await r(o):null,normalMap:c?await r(c):null,roughnessMap:s?await r(s):null,metalnessMap:u?await r(u):null,aoMap:f?await r(f):null,alphaMap:p?await r(p):null,matcap:m?await r(m):null}}}const te=(e,{renderer:a,camera:t,raycaster:r})=>{const n=l.computed(()=>a.value.domElement),{x:o,y:c}=v.usePointer({target:n}),{width:s,height:u,top:f,left:p}=v.useElementBounding(n),m=({x:w,y:A})=>{if(n.value)return{x:(w-p.value)/s.value*2-1,y:-((A-f.value)/u.value)*2+1}},i=({x:w,y:A})=>{if(t.value)return r.value.setFromCamera(new M.Vector2(w,A),t.value),r.value.intersectObjects(e.value,!1)},h=w=>{const A=m({x:(w==null?void 0:w.clientX)??o.value,y:(w==null?void 0:w.clientY)??c.value});return A?i(A)||[]:[]},P=l.computed(()=>h()),d=v.createEventHook(),_=v.createEventHook(),g=(w,A)=>{w.trigger({event:A,intersects:h(A)})},k=w=>{g(_,w)};let L;const D=w=>{var A;L=(A=h(w)[0])==null?void 0:A.object},b=w=>{var A;w instanceof PointerEvent&&L===((A=h(w)[0])==null?void 0:A.object)&&g(d,w)},O=w=>_.trigger({event:w,intersects:[]});return n.value.addEventListener("pointerup",b),n.value.addEventListener("pointerdown",D),n.value.addEventListener("pointermove",k),n.value.addEventListener("pointerleave",O),l.onUnmounted(()=>{n!=null&&n.value&&(n.value.removeEventListener("pointerup",b),n.value.removeEventListener("pointerdown",D),n.value.removeEventListener("pointermove",k),n.value.removeEventListener("pointerleave",O))}),{intersects:P,onClick:w=>d.on(w).off,onPointerMove:w=>_.on(w).off}};function be(){const{logWarning:e}=S();function a(o,c,s){let u=null;return o.traverse(f=>{f[c]===s&&(u=f)}),u||e(`Child with ${c} '${s}' not found.`),u}function t(o,c,s){const u=[];return o.traverse(f=>{f[c].includes(s)&&u.push(f)}),u.length||e(`Children with ${c} '${s}' not found.`),u}function r(o,c){return a(o,"name",c)}function n(o,c){return t(o,"name",c)}return{seek:a,seekByName:r,seekAll:t,seekAllByName:n}}const re=({scene:e,contextParts:a})=>{const t=l.reactive({click:new Map,pointerMove:new Map,pointerEnter:new Map,pointerLeave:new Map}),r=l.ref(new Set),n=i=>{r.value.add(i)},o=i=>{r.value.delete(i)},c=i=>{Object.values(t).forEach(h=>h.delete(i)),o(i)},s=i=>{const{onClick:h,onPointerMove:P,onPointerEnter:d,onPointerLeave:_}=i;h&&t.click.set(i,h),P&&t.pointerMove.set(i,P),d&&t.pointerEnter.set(i,d),_&&t.pointerLeave.set(i,_)};e.userData.tres__registerAtPointerEventHandler=s,e.userData.tres__deregisterAtPointerEventHandler=c,e.userData.tres__registerBlockingObjectAtPointerEventHandler=n,e.userData.tres__deregisterBlockingObjectAtPointerEventHandler=o;const u=l.computed(()=>ve([...Array.from(r.value),...Object.values(t).map(i=>Array.from(i.keys())).flat()],({uuid:i})=>i)),{onClick:f,onPointerMove:p}=te(u,a);f(({intersects:i,event:h})=>{var P;i.length&&((P=t.click.get(i[0].object))==null||P(i[0],h))});let m;return p(({intersects:i,event:h})=>{var k,L,D,b;const P=(k=i==null?void 0:i[0])==null?void 0:k.object,{pointerLeave:d,pointerEnter:_,pointerMove:g}=t;m&&m!==P&&((L=d.get(m))==null||L(m,h)),P&&(m!==P&&((D=_.get(P))==null||D(i[0],h)),(b=g.get(P))==null||b(i[0],h)),m=P||null}),{registerObject:s,deregisterObject:c}};function Ae(e){let a=0;return e.traverse(t=>{if(t.isMesh&&t.geometry){const r=t.geometry,n=r.attributes.position.count*3*Float32Array.BYTES_PER_ELEMENT,o=r.index?r.index.count*Uint32Array.BYTES_PER_ELEMENT:0,c=r.attributes.normal?r.attributes.normal.count*3*Float32Array.BYTES_PER_ELEMENT:0,s=r.attributes.uv?r.attributes.uv.count*2*Float32Array.BYTES_PER_ELEMENT:0,u=n+o+c+s;a+=u}}),a}const V=l.ref({}),F=e=>Object.assign(V.value,e);function ne({scene:e,canvas:a,windowSize:t,disableRender:r,rendererOptions:n}){const o=l.computed(()=>v.toValue(t)?v.useWindowSize():v.useElementSize(v.toValue(a).parentElement)),c=l.computed(()=>o.value.width.value),s=l.computed(()=>o.value.height.value),u=l.computed(()=>c.value/s.value),f={height:s,width:c,aspectRatio:u},p=l.shallowRef(e),{camera:m,cameras:i,registerCamera:h,deregisterCamera:P,setCameraActive:d}=I({sizes:f,scene:e}),{renderer:_}=Q({scene:e,canvas:a,options:n,contextParts:{sizes:f,camera:m},disableRender:r}),g={sizes:f,scene:p,camera:m,cameras:l.readonly(i),renderer:_,raycaster:l.shallowRef(new M.Raycaster),controls:l.ref(null),perf:{maxFrames:160,fps:{value:0,accumulator:[]},memory:{currentMem:0,allocatedMem:0,accumulator:[]}},extend:F,registerCamera:h,setCameraActive:d,deregisterCamera:P};l.provide("useTres",g);const k=100,L=v.useFps({every:k}),{isSupported:D,memory:b}=v.useMemory({interval:k}),O=160;let w=performance.now();const A=({timestamp:R})=>{g.scene.value&&(g.perf.memory.allocatedMem=Ae(g.scene.value)),R-w>=k&&(w=R,g.perf.fps.accumulator.push(L.value),g.perf.fps.accumulator.length>O&&g.perf.fps.accumulator.shift(),g.perf.fps.value=L.value,D.value&&b.value&&(g.perf.memory.accumulator.push(b.value.usedJSHeapSize/1024/1024),g.perf.memory.accumulator.length>O&&g.perf.memory.accumulator.shift(),g.perf.memory.currentMem=g.perf.memory.accumulator.reduce((xe,Ve)=>xe+Ve,0)/g.perf.memory.accumulator.length))};let G=0;const je=1,{pause:Te,resume:Ne}=v.useRafFn(({delta:R})=>{window.__TRES__DEVTOOLS__&&(A({timestamp:performance.now()}),G+=R,G>=je&&(window.__TRES__DEVTOOLS__.cb(g),G=0))},{immediate:!0});return l.onUnmounted(()=>{Te()}),g}function ae(){const e=l.inject("useTres");if(!e)throw new Error("useTresContext must be used together with useTresContextProvider");return e}const ke=ae;function Re(e){}let y=null;const{logError:oe}=S(),$=["onClick","onPointerMove","onPointerEnter","onPointerLeave"],Le={createElement(e,a,t,r){var c,s;if(r||(r={}),r.args||(r.args=[]),e==="template"||pe(e))return null;let n=e.replace("Tres",""),o;if(e==="primitive"){(r==null?void 0:r.object)===void 0&&oe("Tres primitives need a prop 'object'");const u=r.object;n=u.type,o=Object.assign(u,{type:n,attach:r.attach,primitive:!0})}else{const u=V.value[n];u||oe(`${n} is not defined on the THREE namespace. Use extend to add it to the catalog.`),o=new u(...r.args)}return o.isCamera&&(r!=null&&r.position||o.position.set(3,3,3),r!=null&&r.lookAt||o.lookAt(0,0,0)),(r==null?void 0:r.attach)===void 0&&(o.isMaterial?o.attach="material":o.isBufferGeometry&&(o.attach="geometry")),o.isObject3D&&((c=r==null?void 0:r.material)!=null&&c.isMaterial&&(o.userData.tres__materialViaProp=!0),(s=r==null?void 0:r.geometry)!=null&&s.isBufferGeometry&&(o.userData.tres__geometryViaProp=!0)),o.userData={...o.userData,tres__name:n},o},insert(e,a){var r,n,o,c;a&&a.isScene&&(y=a);const t=a||y;if(e!=null&&e.isObject3D){if(e!=null&&e.isCamera){if(!(y!=null&&y.userData.tres__registerCamera))throw"could not find tres__registerCamera on scene's userData";(n=y==null?void 0:(r=y.userData).tres__registerCamera)==null||n.call(r,e)}if(e&&$.some(s=>e[s])){if(!(y!=null&&y.userData.tres__registerAtPointerEventHandler))throw"could not find tres__registerAtPointerEventHandler on scene's userData";(c=y==null?void 0:(o=y.userData).tres__registerAtPointerEventHandler)==null||c.call(o,e)}}e!=null&&e.isObject3D&&(t!=null&&t.isObject3D)?(t.add(e),e.dispatchEvent({type:"added"})):e!=null&&e.isFog?t.fog=e:typeof(e==null?void 0:e.attach)=="string"&&(e.__previousAttach=e[t==null?void 0:t.attach],t&&(t[e.attach]=e))},remove(e){var a,t;if(e){if(e.isObject3D){const r=e,n=f=>{var m,i;const p=f;f.userData.tres__materialViaProp||((m=p.material)==null||m.dispose(),p.material=void 0),f.userData.tres__geometryViaProp||((i=p.geometry)==null||i.dispose(),p.geometry=void 0)},o=y==null?void 0:y.userData.tres__deregisterAtPointerEventHandler,c=y==null?void 0:y.userData.tres__deregisterBlockingObjectAtPointerEventHandler,s=f=>{var p,m;if(!c)throw"could not find tres__deregisterBlockingObjectAtPointerEventHandler on scene's userData";if((m=y==null?void 0:(p=y.userData).tres__deregisterBlockingObjectAtPointerEventHandler)==null||m.call(p,f),!o)throw"could not find tres__deregisterAtPointerEventHandler on scene's userData";f&&$.some(i=>f[i])&&(o==null||o(f))},u=f=>{const p=y==null?void 0:y.userData.tres__deregisterCamera;if(!p)throw"could not find tres__deregisterCamera on scene's userData";f.isCamera&&(p==null||p(f))};(a=e.removeFromParent)==null||a.call(e),r.traverse(f=>{n(f),u(f),s==null||s(f)}),n(r),u(r),s==null||s(r)}(t=e.dispose)==null||t.call(e)}},patchProp(e,a,t,r){var n,o,c,s;if(e){let u=e,f=a;if(e.isObject3D&&f==="blocks-pointer-events"){r||r===""?(o=y==null?void 0:(n=y.userData).tres__registerBlockingObjectAtPointerEventHandler)==null||o.call(n,e):(s=y==null?void 0:(c=y.userData).tres__deregisterBlockingObjectAtPointerEventHandler)==null||s.call(c,e);return}let p=T(f),m=u==null?void 0:u[p];if(f==="args"){const h=e,P=t??[],d=r??[],_=e.userData.tres__name||e.type;_&&P.length&&!he(P,d)&&(u=Object.assign(h,new V.value[_](...r)));return}if(u.type==="BufferGeometry"){if(f==="args")return;u.setAttribute(T(f),new M.BufferAttribute(...r));return}if(f.includes("-")&&m===void 0){const h=f.split("-");m=h.reduce((P,d)=>P[T(d)],u),f=h.pop(),p=f.toLowerCase(),m!=null&&m.set||(u=h.reduce((P,d)=>P[T(d)],u))}let i=r;if(i===""&&(i=!0),Z(m)){$.includes(a)||(Array.isArray(i)?e[p](...i):e[p](i));return}!(m!=null&&m.set)&&!Z(m)?u[p]=i:m.constructor===i.constructor&&(m!=null&&m.copy)?m==null||m.copy(i):Array.isArray(i)?m.set(...i):!m.isColor&&m.setScalar?m.setScalar(i):m.set(i)}},parentNode(e){return(e==null?void 0:e.parent)||null},createText:()=>void 0,createComment:()=>void 0,setText:()=>void 0,setElementText:()=>void 0,nextSibling:()=>void 0,querySelector:()=>void 0,setScopeId:()=>void 0,cloneNode:()=>void 0,insertStaticContent:()=>void 0},{render:De}=l.createRenderer(Le);F(le);const Oe=["data-scene"],se=l.defineComponent({__name:"TresCanvas",props:{shadows:{type:Boolean,default:void 0},clearColor:{},toneMapping:{},shadowMapType:{},useLegacyLights:{type:Boolean,default:void 0},outputColorSpace:{},toneMappingExposure:{},camera:{},preset:{},windowSize:{type:Boolean,default:void 0},disableRender:{type:Boolean,default:void 0},context:{},precision:{},alpha:{type:Boolean,default:void 0},premultipliedAlpha:{type:Boolean},antialias:{type:Boolean,default:void 0},stencil:{type:Boolean,default:void 0},preserveDrawingBuffer:{type:Boolean,default:void 0},powerPreference:{},depth:{type:Boolean,default:void 0},logarithmicDepthBuffer:{type:Boolean,default:void 0},failIfMajorPerformanceCaveat:{type:Boolean,default:void 0}},setup(e,{expose:a}){var P;const t=e,{logWarning:r}=S(),n=l.ref(),o=l.shallowRef(new M.Scene),{resume:c}=N(),s=l.useSlots(),u=(P=l.getCurrentInstance())==null?void 0:P.appContext.app,f=d=>l.defineComponent({setup(){var g;const _=(g=l.getCurrentInstance())==null?void 0:g.appContext;return _&&(_.app=u),l.provide("useTres",d),l.provide("extend",F),()=>l.h(l.Fragment,null,s!=null&&s.default?s.default():[])}}),p=d=>{const _=f(d);De(l.h(_),o.value)},m=(d,_=!1)=>{o.value.children=[],_&&(d.renderer.value.dispose(),d.renderer.value.renderLists.dispose(),d.renderer.value.forceContextLoss()),p(d),c()},i=l.computed(()=>t.disableRender),h=l.shallowRef(null);return a({context:h,dispose:()=>m(h.value,!0)}),l.onMounted(()=>{const d=n;h.value=ne({scene:o.value,canvas:d,windowSize:t.windowSize,disableRender:i,rendererOptions:t}),re({scene:o.value,contextParts:h.value});const{registerCamera:_,camera:g,cameras:k,deregisterCamera:L}=h.value;p(h.value);const D=()=>{const b=new M.PerspectiveCamera(45,window.innerWidth/window.innerHeight,.1,1e3);b.position.set(3,3,3),b.lookAt(0,0,0),_(b);const O=l.watchEffect(()=>{k.value.length>=2&&(b.removeFromParent(),L(b),O==null||O())})};l.watch(()=>t.camera,(b,O)=>{b&&_(b),O&&(O.removeFromParent(),L(O))},{immediate:!0}),g.value||(r("No camera found. Creating a default perspective camera. To have full control over a camera, please add one to the scene."),D())}),(d,_)=>(l.openBlock(),l.createElementBlock("canvas",{ref_key:"canvas",ref:n,"data-scene":o.value.uuid,class:l.normalizeClass(d.$attrs.class),style:l.normalizeStyle({display:"block",width:"100%",height:"100%",position:d.windowSize?"fixed":"relative",top:0,left:0,pointerEvents:"auto",touchAction:"none",...d.$attrs.style})},null,14,Oe))}}),Se=["TresCanvas","TresLeches","TresScene"],Ee={template:{compilerOptions:{isCustomElement:e=>e.startsWith("Tres")&&!Se.includes(e)||e==="primitive"}}},Be={install(e){e.component("TresCanvas",se)}};C.TresCanvas=se,C.catalogue=V,C.default=Be,C.extend=F,C.isProd=me,C.normalizeColor=H,C.normalizeVectorFlexibleParam=de,C.templateCompilerOptions=Ee,C.trasverseObjects=ee,C.useCamera=I,C.useLoader=Pe,C.useLogger=S,C.usePointerEventHandler=re,C.useRaycaster=te,C.useRenderLoop=N,C.useRenderer=Q,C.useSeek=be,C.useTexture=Me,C.useTres=ke,C.useTresContext=ae,C.useTresContextProvider=ne,Object.defineProperties(C,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
