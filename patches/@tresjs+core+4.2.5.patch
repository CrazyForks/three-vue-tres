diff --git a/node_modules/@tresjs/core/README.md b/node_modules/@tresjs/core/README.md
index c0d03d3..ecefd08 100644
--- a/node_modules/@tresjs/core/README.md
+++ b/node_modules/@tresjs/core/README.md
@@ -4,6 +4,7 @@
   <a href="https://www.npmjs.com/package/@tresjs/core"><img src="https://img.shields.io/npm/v/@tresjs/core?color=%2382DBCA&logo=data:image/svg%2bxml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTExLjY4NTQgMy40MjkxNkMxMi4wNzM4IDIuNzgxODIgMTMuMDEyIDIuNzgxODIgMTMuNDAwNCAzLjQyOTE1TDE5LjE3NzEgMTMuMDU2OUMxOS41NzcgMTMuNzIzNSAxOS4wOTY5IDE0LjU3MTQgMTguMzE5NiAxNC41NzE0SDYuNzY2MjRDNS45ODg5NCAxNC41NzE0IDUuNTA4ODMgMTMuNzIzNSA1LjkwODc1IDEzLjA1NjlMMTEuNjg1NCAzLjQyOTE2WiIgZmlsbD0iIzgyREJDNSIvPgo8cGF0aCBkPSJNMTUuNjg1NyAxMC41NDI5QzE1LjY4NTcgOS45OTA1OSAxNi4xMzM0IDkuNTQyODggMTYuNjg1NyA5LjU0Mjg4SDI2QzI2LjU1MjIgOS41NDI4OCAyNyA5Ljk5MDU5IDI3IDEwLjU0MjlWMTkuODU3MkMyNyAyMC40MDk0IDI2LjU1MjIgMjAuODU3MiAyNiAyMC44NTcySDE2LjY4NTdDMTYuMTMzNCAyMC44NTcyIDE1LjY4NTcgMjAuNDA5NCAxNS42ODU3IDE5Ljg1NzJWMTAuNTQyOVoiIGZpbGw9IiM0RjRGNEYiLz4KPGNpcmNsZSBjeD0iMTYiIGN5PSIyMiIgcj0iNiIgZmlsbD0iI0VGQUMzNSIvPgo8L3N2Zz4K" alt="npm package"></a>
   <a href="https://www.npmjs.com/package/@tresjs/core"><img src="https://img.shields.io/npm/dm/@tresjs/core?color=%2382DBCA" alt="npm downloads"></a>
   <a href="https://discord.gg/UCr96AQmWn"><img src="https://img.shields.io/badge/chat-discord-purple?style=flat&logo=discord" alt="discord chat"></a>
+  <a href="https://app.netlify.com/sites/tresjs-docs/deploys"><img src="https://api.netlify.com/api/v1/badges/5a59eb67-67f1-4c9d-bdf4-2f9a5899a531/deploy-status" alt="netlify status"></a>
 </p>
 
 # TresJS `@tresjs/core`
@@ -91,4 +92,8 @@ pnpm run docs:build
 
 ## Sponsors
 
-Be the first to support this project [here](https://github.com/sponsors/alvarosabu) ☺️
+<p align="center">
+  <a target="_blank" href="https://github.com/sponsors/tresjs">
+    <img alt="sponsors" src="./sponsorkit/sponsors.png">
+  </a>
+</p>
diff --git a/node_modules/@tresjs/core/components.d.ts b/node_modules/@tresjs/core/components.d.ts
index 95e629e..eaae2ef 100644
--- a/node_modules/@tresjs/core/components.d.ts
+++ b/node_modules/@tresjs/core/components.d.ts
@@ -1 +1 @@
-export * from './dist/components/index.js'
+export * from './dist/src/components/index.js'
diff --git a/node_modules/@tresjs/core/composables.d.ts b/node_modules/@tresjs/core/composables.d.ts
index 0cfe53c..365506f 100644
--- a/node_modules/@tresjs/core/composables.d.ts
+++ b/node_modules/@tresjs/core/composables.d.ts
@@ -1 +1 @@
-export * from './dist/composables/index.js'
+export * from './dist/src/composables/index.js'
diff --git a/node_modules/@tresjs/core/dist/src/components/TresCanvas.vue.d.ts b/node_modules/@tresjs/core/dist/src/components/TresCanvas.vue.d.ts
index 6ac41cf..09b2bf2 100644
--- a/node_modules/@tresjs/core/dist/src/components/TresCanvas.vue.d.ts
+++ b/node_modules/@tresjs/core/dist/src/components/TresCanvas.vue.d.ts
@@ -1,7 +1,7 @@
-import { TresCamera } from '../types/';
-import { RendererPresetsType } from '../composables/useRenderer/const';
+import { ColorSpace, ShadowMapType, ToneMapping, WebGLRendererParameters } from 'three';
 import { TresContext } from '../composables';
-import { WebGLRendererParameters, ColorSpace, ShadowMapType, ToneMapping } from 'three';
+import { RendererPresetsType } from '../composables/useRenderer/const';
+import { TresCamera } from '../types/';
 
 export interface TresCanvasProps extends Omit<WebGLRendererParameters, 'canvas'> {
     shadows?: boolean;
@@ -11,12 +11,19 @@ export interface TresCanvasProps extends Omit<WebGLRendererParameters, 'canvas'>
     useLegacyLights?: boolean;
     outputColorSpace?: ColorSpace;
     toneMappingExposure?: number;
+    renderMode?: 'always' | 'on-demand' | 'manual';
+    dpr?: number | [number, number];
     camera?: TresCamera;
     preset?: RendererPresetsType;
     windowSize?: boolean;
     disableRender?: boolean;
 }
-declare const _default: __VLS_WithTemplateSlots<import('vue').DefineComponent<__VLS_WithDefaults<__VLS_TypePropsToRuntimeProps<TresCanvasProps>, {
+declare function __VLS_template(): Readonly<{
+    default: () => any;
+}> & {
+    default: () => any;
+};
+declare const __VLS_component: import('vue').DefineComponent<__VLS_WithDefaults<__VLS_TypePropsToRuntimeProps<TresCanvasProps>, {
     alpha: undefined;
     depth: undefined;
     shadows: undefined;
@@ -28,10 +35,26 @@ declare const _default: __VLS_WithTemplateSlots<import('vue').DefineComponent<__
     preserveDrawingBuffer: undefined;
     logarithmicDepthBuffer: undefined;
     failIfMajorPerformanceCaveat: undefined;
+    renderMode: string;
 }>, {
-    context: import("vue").ShallowRef<TresContext | null>;
+    context: import('vue').ShallowRef<TresContext | null>;
     dispose: () => void;
-}, unknown, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, {}, string, import("vue").PublicProps, Readonly<import("vue").ExtractPropTypes<__VLS_WithDefaults<__VLS_TypePropsToRuntimeProps<TresCanvasProps>, {
+}, unknown, {}, {}, import('vue').ComponentOptionsMixin, import('vue').ComponentOptionsMixin, {
+    render: (...args: any[]) => void;
+    click: (...args: any[]) => void;
+    wheel: (...args: any[]) => void;
+    ready: (...args: any[]) => void;
+    "double-click": (...args: any[]) => void;
+    "context-menu": (...args: any[]) => void;
+    "pointer-move": (...args: any[]) => void;
+    "pointer-up": (...args: any[]) => void;
+    "pointer-down": (...args: any[]) => void;
+    "pointer-enter": (...args: any[]) => void;
+    "pointer-leave": (...args: any[]) => void;
+    "pointer-over": (...args: any[]) => void;
+    "pointer-out": (...args: any[]) => void;
+    "pointer-missed": (...args: any[]) => void;
+}, string, import('vue').PublicProps, Readonly<import('vue').ExtractPropTypes<__VLS_WithDefaults<__VLS_TypePropsToRuntimeProps<TresCanvasProps>, {
     alpha: undefined;
     depth: undefined;
     shadows: undefined;
@@ -43,7 +66,23 @@ declare const _default: __VLS_WithTemplateSlots<import('vue').DefineComponent<__
     preserveDrawingBuffer: undefined;
     logarithmicDepthBuffer: undefined;
     failIfMajorPerformanceCaveat: undefined;
-}>>>, {
+    renderMode: string;
+}>>> & {
+    onClick?: ((...args: any[]) => any) | undefined;
+    onWheel?: ((...args: any[]) => any) | undefined;
+    onRender?: ((...args: any[]) => any) | undefined;
+    onReady?: ((...args: any[]) => any) | undefined;
+    "onDouble-click"?: ((...args: any[]) => any) | undefined;
+    "onContext-menu"?: ((...args: any[]) => any) | undefined;
+    "onPointer-move"?: ((...args: any[]) => any) | undefined;
+    "onPointer-up"?: ((...args: any[]) => any) | undefined;
+    "onPointer-down"?: ((...args: any[]) => any) | undefined;
+    "onPointer-enter"?: ((...args: any[]) => any) | undefined;
+    "onPointer-leave"?: ((...args: any[]) => any) | undefined;
+    "onPointer-over"?: ((...args: any[]) => any) | undefined;
+    "onPointer-out"?: ((...args: any[]) => any) | undefined;
+    "onPointer-missed"?: ((...args: any[]) => any) | undefined;
+}, {
     alpha: boolean;
     antialias: boolean;
     stencil: boolean;
@@ -54,12 +93,10 @@ declare const _default: __VLS_WithTemplateSlots<import('vue').DefineComponent<__
     shadows: boolean;
     useLegacyLights: boolean;
     windowSize: boolean;
+    renderMode: "always" | "on-demand" | "manual";
     disableRender: boolean;
-}, {}>, Readonly<{
-    default(): any;
-}> & {
-    default(): any;
-}>;
+}, {}>;
+declare const _default: __VLS_WithTemplateSlots<typeof __VLS_component, ReturnType<typeof __VLS_template>>;
 export default _default;
 type __VLS_NonUndefinedable<T> = T extends undefined ? never : T;
 type __VLS_TypePropsToRuntimeProps<T> = {
diff --git a/node_modules/@tresjs/core/dist/src/composables/index.d.ts b/node_modules/@tresjs/core/dist/src/composables/index.d.ts
index 69f9c75..e702348 100644
--- a/node_modules/@tresjs/core/dist/src/composables/index.d.ts
+++ b/node_modules/@tresjs/core/dist/src/composables/index.d.ts
@@ -1,10 +1,12 @@
 export * from './useCamera/';
-export * from './useRenderLoop/';
+export * from './useRenderLoop';
 export * from './useRenderer/';
 export * from './useLoader';
 export * from './useTexture';
 export * from './useRaycaster';
 export * from './useLogger';
 export * from './useSeek';
-export * from './usePointerEventHandler';
 export * from './useTresContextProvider';
+export * from './useLoop';
+export * from './useTresEventManager';
+export { onTresReady } from './useTresReady';
diff --git a/node_modules/@tresjs/core/dist/src/composables/useCamera/index.d.ts b/node_modules/@tresjs/core/dist/src/composables/useCamera/index.d.ts
index 849abcc..d5b63f8 100644
--- a/node_modules/@tresjs/core/dist/src/composables/useCamera/index.d.ts
+++ b/node_modules/@tresjs/core/dist/src/composables/useCamera/index.d.ts
@@ -1,14 +1,14 @@
-import { TresContext } from '../useTresContextProvider';
-import { TresScene } from '../../types';
 import { Camera } from 'three';
+import { TresScene } from '../../types';
+import { TresContext } from '../useTresContextProvider';
 
-export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> & {
+export declare const useCamera: ({ sizes }: Pick<TresContext, "sizes"> & {
     scene: TresScene;
 }) => {
     camera: import('vue').ComputedRef<Camera | undefined>;
     cameras: import('vue').Ref<{
         readonly isCamera: true;
-        readonly type: string;
+        readonly type: string | "Camera";
         layers: {
             mask: number;
             set: (layer: number) => void;
@@ -17,187 +17,190 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
             toggle: (layer: number) => void;
             disable: (layer: number) => void;
             disableAll: () => void;
-            test: (layers: import("three").Layers) => boolean;
+            test: (layers: import('three').Layers) => boolean;
             isEnabled: (layer: number) => boolean;
         };
         matrixWorldInverse: {
+            readonly isMatrix4: true;
             elements: number[];
-            set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import("three").Matrix4;
-            identity: () => import("three").Matrix4;
-            clone: () => import("three").Matrix4;
-            copy: (m: import("three").Matrix4) => import("three").Matrix4;
-            copyPosition: (m: import("three").Matrix4) => import("three").Matrix4;
-            extractBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
-            makeBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
-            extractRotation: (m: import("three").Matrix4) => import("three").Matrix4;
-            makeRotationFromEuler: (euler: import("three").Euler) => import("three").Matrix4;
-            makeRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
-            lookAt: (eye: import("three").Vector3, target: import("three").Vector3, up: import("three").Vector3) => import("three").Matrix4;
-            multiply: (m: import("three").Matrix4) => import("three").Matrix4;
-            premultiply: (m: import("three").Matrix4) => import("three").Matrix4;
-            multiplyMatrices: (a: import("three").Matrix4, b: import("three").Matrix4) => import("three").Matrix4;
-            multiplyToArray: (a: import("three").Matrix4, b: import("three").Matrix4, r: number[]) => import("three").Matrix4;
-            multiplyScalar: (s: number) => import("three").Matrix4;
+            set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
+            identity: () => import('three').Matrix4;
+            clone: () => import('three').Matrix4;
+            copy: (m: import('three').Matrix4) => import('three').Matrix4;
+            copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
+            extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
+            makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
+            extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
+            makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
+            makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
+            lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
+            multiply: (m: import('three').Matrix4) => import('three').Matrix4;
+            premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
+            multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
+            multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
+            multiplyScalar: (s: number) => import('three').Matrix4;
             determinant: () => number;
-            transpose: () => import("three").Matrix4;
+            transpose: () => import('three').Matrix4;
             setPosition: {
-                (v: import("three").Vector3): import("three").Matrix4;
-                (x: number, y: number, z: number): import("three").Matrix4;
+                (v: import('three').Vector3): import('three').Matrix4;
+                (x: number, y: number, z: number): import('three').Matrix4;
             };
-            invert: () => import("three").Matrix4;
-            scale: (v: import("three").Vector3) => import("three").Matrix4;
+            invert: () => import('three').Matrix4;
+            scale: (v: import('three').Vector3) => import('three').Matrix4;
             getMaxScaleOnAxis: () => number;
             makeTranslation: {
-                (v: import("three").Vector3): import("three").Matrix4;
-                (x: number, y: number, z: number): import("three").Matrix4;
+                (v: import('three').Vector3): import('three').Matrix4;
+                (x: number, y: number, z: number): import('three').Matrix4;
             };
-            makeRotationX: (theta: number) => import("three").Matrix4;
-            makeRotationY: (theta: number) => import("three").Matrix4;
-            makeRotationZ: (theta: number) => import("three").Matrix4;
-            makeRotationAxis: (axis: import("three").Vector3, angle: number) => import("three").Matrix4;
-            makeScale: (x: number, y: number, z: number) => import("three").Matrix4;
-            makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import("three").Matrix4;
-            compose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
-            decompose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
-            makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => import("three").Matrix4;
-            makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => import("three").Matrix4;
-            equals: (matrix: import("three").Matrix4) => boolean;
-            fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Matrix4;
+            makeRotationX: (theta: number) => import('three').Matrix4;
+            makeRotationY: (theta: number) => import('three').Matrix4;
+            makeRotationZ: (theta: number) => import('three').Matrix4;
+            makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
+            makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
+            makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
+            compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
+            decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
+            makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
+            makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
+            equals: (matrix: import('three').Matrix4) => boolean;
+            fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Matrix4;
             toArray: {
-                (array?: number[] | undefined, offset?: number | undefined): number[];
-                (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
-                (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
+                (array?: number[], offset?: number): number[];
+                (array?: import('three').Matrix4Tuple, offset?: 0): import('three').Matrix4Tuple;
+                (array?: ArrayLike<number>, offset?: number): ArrayLike<number>;
             };
-            setFromMatrix3: (m: import("three").Matrix3) => import("three").Matrix4;
-            extractPosition: (m: import("three").Matrix4) => import("three").Matrix4;
-            setRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
+            setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
+            extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
+            setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
             multiplyVector3: (v: any) => any;
             multiplyVector4: (v: any) => any;
             multiplyVector3Array: (array: number[]) => number[];
             rotateAxis: (v: any) => void;
             crossVector: (v: any) => void;
             flattenToArrayOffset: (array: number[], offset: number) => number[];
-            getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
+            getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
         };
         projectionMatrix: {
+            readonly isMatrix4: true;
             elements: number[];
-            set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import("three").Matrix4;
-            identity: () => import("three").Matrix4;
-            clone: () => import("three").Matrix4;
-            copy: (m: import("three").Matrix4) => import("three").Matrix4;
-            copyPosition: (m: import("three").Matrix4) => import("three").Matrix4;
-            extractBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
-            makeBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
-            extractRotation: (m: import("three").Matrix4) => import("three").Matrix4;
-            makeRotationFromEuler: (euler: import("three").Euler) => import("three").Matrix4;
-            makeRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
-            lookAt: (eye: import("three").Vector3, target: import("three").Vector3, up: import("three").Vector3) => import("three").Matrix4;
-            multiply: (m: import("three").Matrix4) => import("three").Matrix4;
-            premultiply: (m: import("three").Matrix4) => import("three").Matrix4;
-            multiplyMatrices: (a: import("three").Matrix4, b: import("three").Matrix4) => import("three").Matrix4;
-            multiplyToArray: (a: import("three").Matrix4, b: import("three").Matrix4, r: number[]) => import("three").Matrix4;
-            multiplyScalar: (s: number) => import("three").Matrix4;
+            set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
+            identity: () => import('three').Matrix4;
+            clone: () => import('three').Matrix4;
+            copy: (m: import('three').Matrix4) => import('three').Matrix4;
+            copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
+            extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
+            makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
+            extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
+            makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
+            makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
+            lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
+            multiply: (m: import('three').Matrix4) => import('three').Matrix4;
+            premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
+            multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
+            multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
+            multiplyScalar: (s: number) => import('three').Matrix4;
             determinant: () => number;
-            transpose: () => import("three").Matrix4;
+            transpose: () => import('three').Matrix4;
             setPosition: {
-                (v: import("three").Vector3): import("three").Matrix4;
-                (x: number, y: number, z: number): import("three").Matrix4;
+                (v: import('three').Vector3): import('three').Matrix4;
+                (x: number, y: number, z: number): import('three').Matrix4;
             };
-            invert: () => import("three").Matrix4;
-            scale: (v: import("three").Vector3) => import("three").Matrix4;
+            invert: () => import('three').Matrix4;
+            scale: (v: import('three').Vector3) => import('three').Matrix4;
             getMaxScaleOnAxis: () => number;
             makeTranslation: {
-                (v: import("three").Vector3): import("three").Matrix4;
-                (x: number, y: number, z: number): import("three").Matrix4;
+                (v: import('three').Vector3): import('three').Matrix4;
+                (x: number, y: number, z: number): import('three').Matrix4;
             };
-            makeRotationX: (theta: number) => import("three").Matrix4;
-            makeRotationY: (theta: number) => import("three").Matrix4;
-            makeRotationZ: (theta: number) => import("three").Matrix4;
-            makeRotationAxis: (axis: import("three").Vector3, angle: number) => import("three").Matrix4;
-            makeScale: (x: number, y: number, z: number) => import("three").Matrix4;
-            makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import("three").Matrix4;
-            compose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
-            decompose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
-            makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => import("three").Matrix4;
-            makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => import("three").Matrix4;
-            equals: (matrix: import("three").Matrix4) => boolean;
-            fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Matrix4;
+            makeRotationX: (theta: number) => import('three').Matrix4;
+            makeRotationY: (theta: number) => import('three').Matrix4;
+            makeRotationZ: (theta: number) => import('three').Matrix4;
+            makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
+            makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
+            makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
+            compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
+            decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
+            makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
+            makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
+            equals: (matrix: import('three').Matrix4) => boolean;
+            fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Matrix4;
             toArray: {
-                (array?: number[] | undefined, offset?: number | undefined): number[];
-                (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
-                (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
+                (array?: number[], offset?: number): number[];
+                (array?: import('three').Matrix4Tuple, offset?: 0): import('three').Matrix4Tuple;
+                (array?: ArrayLike<number>, offset?: number): ArrayLike<number>;
             };
-            setFromMatrix3: (m: import("three").Matrix3) => import("three").Matrix4;
-            extractPosition: (m: import("three").Matrix4) => import("three").Matrix4;
-            setRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
+            setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
+            extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
+            setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
             multiplyVector3: (v: any) => any;
             multiplyVector4: (v: any) => any;
             multiplyVector3Array: (array: number[]) => number[];
             rotateAxis: (v: any) => void;
             crossVector: (v: any) => void;
             flattenToArrayOffset: (array: number[], offset: number) => number[];
-            getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
+            getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
         };
         projectionMatrixInverse: {
+            readonly isMatrix4: true;
             elements: number[];
-            set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import("three").Matrix4;
-            identity: () => import("three").Matrix4;
-            clone: () => import("three").Matrix4;
-            copy: (m: import("three").Matrix4) => import("three").Matrix4;
-            copyPosition: (m: import("three").Matrix4) => import("three").Matrix4;
-            extractBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
-            makeBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
-            extractRotation: (m: import("three").Matrix4) => import("three").Matrix4;
-            makeRotationFromEuler: (euler: import("three").Euler) => import("three").Matrix4;
-            makeRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
-            lookAt: (eye: import("three").Vector3, target: import("three").Vector3, up: import("three").Vector3) => import("three").Matrix4;
-            multiply: (m: import("three").Matrix4) => import("three").Matrix4;
-            premultiply: (m: import("three").Matrix4) => import("three").Matrix4;
-            multiplyMatrices: (a: import("three").Matrix4, b: import("three").Matrix4) => import("three").Matrix4;
-            multiplyToArray: (a: import("three").Matrix4, b: import("three").Matrix4, r: number[]) => import("three").Matrix4;
-            multiplyScalar: (s: number) => import("three").Matrix4;
+            set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
+            identity: () => import('three').Matrix4;
+            clone: () => import('three').Matrix4;
+            copy: (m: import('three').Matrix4) => import('three').Matrix4;
+            copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
+            extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
+            makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
+            extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
+            makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
+            makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
+            lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
+            multiply: (m: import('three').Matrix4) => import('three').Matrix4;
+            premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
+            multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
+            multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
+            multiplyScalar: (s: number) => import('three').Matrix4;
             determinant: () => number;
-            transpose: () => import("three").Matrix4;
+            transpose: () => import('three').Matrix4;
             setPosition: {
-                (v: import("three").Vector3): import("three").Matrix4;
-                (x: number, y: number, z: number): import("three").Matrix4;
+                (v: import('three').Vector3): import('three').Matrix4;
+                (x: number, y: number, z: number): import('three').Matrix4;
             };
-            invert: () => import("three").Matrix4;
-            scale: (v: import("three").Vector3) => import("three").Matrix4;
+            invert: () => import('three').Matrix4;
+            scale: (v: import('three').Vector3) => import('three').Matrix4;
             getMaxScaleOnAxis: () => number;
             makeTranslation: {
-                (v: import("three").Vector3): import("three").Matrix4;
-                (x: number, y: number, z: number): import("three").Matrix4;
+                (v: import('three').Vector3): import('three').Matrix4;
+                (x: number, y: number, z: number): import('three').Matrix4;
             };
-            makeRotationX: (theta: number) => import("three").Matrix4;
-            makeRotationY: (theta: number) => import("three").Matrix4;
-            makeRotationZ: (theta: number) => import("three").Matrix4;
-            makeRotationAxis: (axis: import("three").Vector3, angle: number) => import("three").Matrix4;
-            makeScale: (x: number, y: number, z: number) => import("three").Matrix4;
-            makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import("three").Matrix4;
-            compose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
-            decompose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
-            makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => import("three").Matrix4;
-            makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => import("three").Matrix4;
-            equals: (matrix: import("three").Matrix4) => boolean;
-            fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Matrix4;
+            makeRotationX: (theta: number) => import('three').Matrix4;
+            makeRotationY: (theta: number) => import('three').Matrix4;
+            makeRotationZ: (theta: number) => import('three').Matrix4;
+            makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
+            makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
+            makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
+            compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
+            decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
+            makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
+            makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
+            equals: (matrix: import('three').Matrix4) => boolean;
+            fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Matrix4;
             toArray: {
-                (array?: number[] | undefined, offset?: number | undefined): number[];
-                (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
-                (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
+                (array?: number[], offset?: number): number[];
+                (array?: import('three').Matrix4Tuple, offset?: 0): import('three').Matrix4Tuple;
+                (array?: ArrayLike<number>, offset?: number): ArrayLike<number>;
             };
-            setFromMatrix3: (m: import("three").Matrix3) => import("three").Matrix4;
-            extractPosition: (m: import("three").Matrix4) => import("three").Matrix4;
-            setRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
+            setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
+            extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
+            setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
             multiplyVector3: (v: any) => any;
             multiplyVector4: (v: any) => any;
             multiplyVector3Array: (array: number[]) => number[];
             rotateAxis: (v: any) => void;
             crossVector: (v: any) => void;
             flattenToArrayOffset: (array: number[], offset: number) => number[];
-            getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
+            getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
         };
-        coordinateSystem: import("three").CoordinateSystem;
+        coordinateSystem: import('three').CoordinateSystem;
         viewport?: {
             x: number;
             y: number;
@@ -206,58 +209,59 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
             width: number;
             height: number;
             readonly isVector4: true;
-            set: (x: number, y: number, z: number, w: number) => import("three").Vector4;
-            setScalar: (scalar: number) => import("three").Vector4;
-            setX: (x: number) => import("three").Vector4;
-            setY: (y: number) => import("three").Vector4;
-            setZ: (z: number) => import("three").Vector4;
-            setW: (w: number) => import("three").Vector4;
-            setComponent: (index: number, value: number) => import("three").Vector4;
+            set: (x: number, y: number, z: number, w: number) => import('three').Vector4;
+            setScalar: (scalar: number) => import('three').Vector4;
+            setX: (x: number) => import('three').Vector4;
+            setY: (y: number) => import('three').Vector4;
+            setZ: (z: number) => import('three').Vector4;
+            setW: (w: number) => import('three').Vector4;
+            setComponent: (index: number, value: number) => import('three').Vector4;
             getComponent: (index: number) => number;
-            clone: () => import("three").Vector4;
-            copy: (v: import("three").Vector4Like) => import("three").Vector4;
-            add: (v: import("three").Vector4Like) => import("three").Vector4;
-            addScalar: (scalar: number) => import("three").Vector4;
-            addVectors: (a: import("three").Vector4Like, b: import("three").Vector4Like) => import("three").Vector4;
-            addScaledVector: (v: import("three").Vector4Like, s: number) => import("three").Vector4;
-            sub: (v: import("three").Vector4Like) => import("three").Vector4;
-            subScalar: (s: number) => import("three").Vector4;
-            subVectors: (a: import("three").Vector4Like, b: import("three").Vector4Like) => import("three").Vector4;
-            multiply: (v: import("three").Vector4Like) => import("three").Vector4;
-            multiplyScalar: (s: number) => import("three").Vector4;
-            applyMatrix4: (m: import("three").Matrix4) => import("three").Vector4;
-            divideScalar: (s: number) => import("three").Vector4;
-            setAxisAngleFromQuaternion: (q: import("three").QuaternionLike) => import("three").Vector4;
-            setAxisAngleFromRotationMatrix: (m: import("three").Matrix4) => import("three").Vector4;
-            min: (v: import("three").Vector4Like) => import("three").Vector4;
-            max: (v: import("three").Vector4Like) => import("three").Vector4;
-            clamp: (min: import("three").Vector4Like, max: import("three").Vector4Like) => import("three").Vector4;
-            clampScalar: (min: number, max: number) => import("three").Vector4;
-            floor: () => import("three").Vector4;
-            ceil: () => import("three").Vector4;
-            round: () => import("three").Vector4;
-            roundToZero: () => import("three").Vector4;
-            negate: () => import("three").Vector4;
-            dot: (v: import("three").Vector4Like) => number;
+            clone: () => import('three').Vector4;
+            copy: (v: import('three').Vector4Like) => import('three').Vector4;
+            add: (v: import('three').Vector4Like) => import('three').Vector4;
+            addScalar: (scalar: number) => import('three').Vector4;
+            addVectors: (a: import('three').Vector4Like, b: import('three').Vector4Like) => import('three').Vector4;
+            addScaledVector: (v: import('three').Vector4Like, s: number) => import('three').Vector4;
+            sub: (v: import('three').Vector4Like) => import('three').Vector4;
+            subScalar: (s: number) => import('three').Vector4;
+            subVectors: (a: import('three').Vector4Like, b: import('three').Vector4Like) => import('three').Vector4;
+            multiply: (v: import('three').Vector4Like) => import('three').Vector4;
+            multiplyScalar: (s: number) => import('three').Vector4;
+            applyMatrix4: (m: import('three').Matrix4) => import('three').Vector4;
+            divideScalar: (s: number) => import('three').Vector4;
+            setAxisAngleFromQuaternion: (q: import('three').QuaternionLike) => import('three').Vector4;
+            setAxisAngleFromRotationMatrix: (m: import('three').Matrix4) => import('three').Vector4;
+            setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector4;
+            min: (v: import('three').Vector4Like) => import('three').Vector4;
+            max: (v: import('three').Vector4Like) => import('three').Vector4;
+            clamp: (min: import('three').Vector4Like, max: import('three').Vector4Like) => import('three').Vector4;
+            clampScalar: (min: number, max: number) => import('three').Vector4;
+            floor: () => import('three').Vector4;
+            ceil: () => import('three').Vector4;
+            round: () => import('three').Vector4;
+            roundToZero: () => import('three').Vector4;
+            negate: () => import('three').Vector4;
+            dot: (v: import('three').Vector4Like) => number;
             lengthSq: () => number;
             length: () => number;
             manhattanLength: () => number;
-            normalize: () => import("three").Vector4;
-            setLength: (length: number) => import("three").Vector4;
-            lerp: (v: import("three").Vector4Like, alpha: number) => import("three").Vector4;
-            lerpVectors: (v1: import("three").Vector4Like, v2: import("three").Vector4Like, alpha: number) => import("three").Vector4;
-            equals: (v: import("three").Vector4Like) => boolean;
-            fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector4;
+            normalize: () => import('three').Vector4;
+            setLength: (length: number) => import('three').Vector4;
+            lerp: (v: import('three').Vector4Like, alpha: number) => import('three').Vector4;
+            lerpVectors: (v1: import('three').Vector4Like, v2: import('three').Vector4Like, alpha: number) => import('three').Vector4;
+            equals: (v: import('three').Vector4Like) => boolean;
+            fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector4;
             toArray: {
-                (array?: number[] | undefined, offset?: number | undefined): number[];
-                (array?: import("three").Vector4Tuple | undefined, offset?: 0 | undefined): import("three").Vector4Tuple;
-                (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
+                (array?: number[], offset?: number): number[];
+                (array?: import('three').Vector4Tuple, offset?: 0): import('three').Vector4Tuple;
+                (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
             };
-            fromBufferAttribute: (attribute: import("three").BufferAttribute, index: number) => import("three").Vector4;
-            random: () => import("three").Vector4;
-            [Symbol.iterator]: () => Iterator<number, any, undefined>;
+            fromBufferAttribute: (attribute: import('three').BufferAttribute, index: number) => import('three').Vector4;
+            random: () => import('three').Vector4;
+            [Symbol.iterator]: () => Iterator<number>;
         } | undefined;
-        getWorldDirection: (target: import("three").Vector3) => import("three").Vector3;
+        getWorldDirection: (target: import('three').Vector3) => import('three').Vector3;
         readonly isObject3D: true;
         readonly id: number;
         uuid: string;
@@ -267,7 +271,7 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
             readonly id: number;
             uuid: string;
             name: string;
-            readonly type: string;
+            readonly type: string | "Object3D";
             parent: any | null;
             children: any[];
             up: {
@@ -275,188 +279,188 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                 y: number;
                 z: number;
                 readonly isVector3: true;
-                set: (x: number, y: number, z: number) => import("three").Vector3;
-                setScalar: (scalar: number) => import("three").Vector3;
-                setX: (x: number) => import("three").Vector3;
-                setY: (y: number) => import("three").Vector3;
-                setZ: (z: number) => import("three").Vector3;
-                setComponent: (index: number, value: number) => import("three").Vector3;
+                set: (x: number, y: number, z: number) => import('three').Vector3;
+                setScalar: (scalar: number) => import('three').Vector3;
+                setX: (x: number) => import('three').Vector3;
+                setY: (y: number) => import('three').Vector3;
+                setZ: (z: number) => import('three').Vector3;
+                setComponent: (index: number, value: number) => import('three').Vector3;
                 getComponent: (index: number) => number;
-                clone: () => import("three").Vector3;
-                copy: (v: import("three").Vector3Like) => import("three").Vector3;
-                add: (v: import("three").Vector3Like) => import("three").Vector3;
-                addScalar: (s: number) => import("three").Vector3;
-                addVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                addScaledVector: (v: import("three").Vector3, s: number) => import("three").Vector3;
-                sub: (a: import("three").Vector3Like) => import("three").Vector3;
-                subScalar: (s: number) => import("three").Vector3;
-                subVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                multiply: (v: import("three").Vector3Like) => import("three").Vector3;
-                multiplyScalar: (s: number) => import("three").Vector3;
-                multiplyVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                applyEuler: (euler: import("three").Euler) => import("three").Vector3;
-                applyAxisAngle: (axis: import("three").Vector3, angle: number) => import("three").Vector3;
-                applyMatrix3: (m: import("three").Matrix3) => import("three").Vector3;
-                applyNormalMatrix: (m: import("three").Matrix3) => import("three").Vector3;
-                applyMatrix4: (m: import("three").Matrix4) => import("three").Vector3;
-                applyQuaternion: (q: import("three").QuaternionLike) => import("three").Vector3;
-                project: (camera: Camera) => import("three").Vector3;
-                unproject: (camera: Camera) => import("three").Vector3;
-                transformDirection: (m: import("three").Matrix4) => import("three").Vector3;
-                divide: (v: import("three").Vector3Like) => import("three").Vector3;
-                divideScalar: (s: number) => import("three").Vector3;
-                min: (v: import("three").Vector3Like) => import("three").Vector3;
-                max: (v: import("three").Vector3Like) => import("three").Vector3;
-                clamp: (min: import("three").Vector3Like, max: import("three").Vector3Like) => import("three").Vector3;
-                clampScalar: (min: number, max: number) => import("three").Vector3;
-                clampLength: (min: number, max: number) => import("three").Vector3;
-                floor: () => import("three").Vector3;
-                ceil: () => import("three").Vector3;
-                round: () => import("three").Vector3;
-                roundToZero: () => import("three").Vector3;
-                negate: () => import("three").Vector3;
-                dot: (v: import("three").Vector3Like) => number;
+                clone: () => import('three').Vector3;
+                copy: (v: import('three').Vector3Like) => import('three').Vector3;
+                add: (v: import('three').Vector3Like) => import('three').Vector3;
+                addScalar: (s: number) => import('three').Vector3;
+                addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
+                sub: (a: import('three').Vector3Like) => import('three').Vector3;
+                subScalar: (s: number) => import('three').Vector3;
+                subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                multiply: (v: import('three').Vector3Like) => import('three').Vector3;
+                multiplyScalar: (s: number) => import('three').Vector3;
+                multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                applyEuler: (euler: import('three').Euler) => import('three').Vector3;
+                applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
+                applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
+                applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
+                applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
+                applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
+                project: (camera: Camera) => import('three').Vector3;
+                unproject: (camera: Camera) => import('three').Vector3;
+                transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
+                divide: (v: import('three').Vector3Like) => import('three').Vector3;
+                divideScalar: (s: number) => import('three').Vector3;
+                min: (v: import('three').Vector3Like) => import('three').Vector3;
+                max: (v: import('three').Vector3Like) => import('three').Vector3;
+                clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
+                clampScalar: (min: number, max: number) => import('three').Vector3;
+                clampLength: (min: number, max: number) => import('three').Vector3;
+                floor: () => import('three').Vector3;
+                ceil: () => import('three').Vector3;
+                round: () => import('three').Vector3;
+                roundToZero: () => import('three').Vector3;
+                negate: () => import('three').Vector3;
+                dot: (v: import('three').Vector3Like) => number;
                 lengthSq: () => number;
                 length: () => number;
                 manhattanLength: () => number;
-                normalize: () => import("three").Vector3;
-                setLength: (l: number) => import("three").Vector3;
-                lerp: (v: import("three").Vector3Like, alpha: number) => import("three").Vector3;
-                lerpVectors: (v1: import("three").Vector3Like, v2: import("three").Vector3Like, alpha: number) => import("three").Vector3;
-                cross: (a: import("three").Vector3Like) => import("three").Vector3;
-                crossVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                projectOnVector: (v: import("three").Vector3) => import("three").Vector3;
-                projectOnPlane: (planeNormal: import("three").Vector3) => import("three").Vector3;
-                reflect: (vector: import("three").Vector3Like) => import("three").Vector3;
-                angleTo: (v: import("three").Vector3) => number;
-                distanceTo: (v: import("three").Vector3Like) => number;
-                distanceToSquared: (v: import("three").Vector3Like) => number;
-                manhattanDistanceTo: (v: import("three").Vector3Like) => number;
-                setFromSpherical: (s: import("three").Spherical) => import("three").Vector3;
-                setFromSphericalCoords: (r: number, phi: number, theta: number) => import("three").Vector3;
-                setFromCylindrical: (s: import("three").Cylindrical) => import("three").Vector3;
-                setFromCylindricalCoords: (radius: number, theta: number, y: number) => import("three").Vector3;
-                setFromMatrixPosition: (m: import("three").Matrix4) => import("three").Vector3;
-                setFromMatrixScale: (m: import("three").Matrix4) => import("three").Vector3;
-                setFromMatrixColumn: (matrix: import("three").Matrix4, index: number) => import("three").Vector3;
-                setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => import("three").Vector3;
-                setFromEuler: (e: import("three").Euler) => import("three").Vector3;
-                setFromColor: (color: import("three").RGB) => import("three").Vector3;
-                equals: (v: import("three").Vector3Like) => boolean;
-                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector3;
+                normalize: () => import('three').Vector3;
+                setLength: (l: number) => import('three').Vector3;
+                lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
+                lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
+                cross: (a: import('three').Vector3Like) => import('three').Vector3;
+                crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
+                projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
+                reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
+                angleTo: (v: import('three').Vector3) => number;
+                distanceTo: (v: import('three').Vector3Like) => number;
+                distanceToSquared: (v: import('three').Vector3Like) => number;
+                manhattanDistanceTo: (v: import('three').Vector3Like) => number;
+                setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
+                setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
+                setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
+                setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
+                setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
+                setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
+                setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
+                setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
+                setFromEuler: (e: import('three').Euler) => import('three').Vector3;
+                setFromColor: (color: import('three').RGB) => import('three').Vector3;
+                equals: (v: import('three').Vector3Like) => boolean;
+                fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector3;
                 toArray: {
-                    (array?: number[] | undefined, offset?: number | undefined): number[];
-                    (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
-                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
+                    (array?: number[], offset?: number): number[];
+                    (array?: import('three').Vector3Tuple, offset?: 0): import('three').Vector3Tuple;
+                    (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                 };
-                fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => import("three").Vector3;
-                random: () => import("three").Vector3;
-                randomDirection: () => import("three").Vector3;
-                [Symbol.iterator]: () => Iterator<number, any, undefined>;
+                fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
+                random: () => import('three').Vector3;
+                randomDirection: () => import('three').Vector3;
+                [Symbol.iterator]: () => Iterator<number>;
             };
             readonly position: {
                 x: number;
                 y: number;
                 z: number;
                 readonly isVector3: true;
-                set: (x: number, y: number, z: number) => import("three").Vector3;
-                setScalar: (scalar: number) => import("three").Vector3;
-                setX: (x: number) => import("three").Vector3;
-                setY: (y: number) => import("three").Vector3;
-                setZ: (z: number) => import("three").Vector3;
-                setComponent: (index: number, value: number) => import("three").Vector3;
+                set: (x: number, y: number, z: number) => import('three').Vector3;
+                setScalar: (scalar: number) => import('three').Vector3;
+                setX: (x: number) => import('three').Vector3;
+                setY: (y: number) => import('three').Vector3;
+                setZ: (z: number) => import('three').Vector3;
+                setComponent: (index: number, value: number) => import('three').Vector3;
                 getComponent: (index: number) => number;
-                clone: () => import("three").Vector3;
-                copy: (v: import("three").Vector3Like) => import("three").Vector3;
-                add: (v: import("three").Vector3Like) => import("three").Vector3;
-                addScalar: (s: number) => import("three").Vector3;
-                addVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                addScaledVector: (v: import("three").Vector3, s: number) => import("three").Vector3;
-                sub: (a: import("three").Vector3Like) => import("three").Vector3;
-                subScalar: (s: number) => import("three").Vector3;
-                subVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                multiply: (v: import("three").Vector3Like) => import("three").Vector3;
-                multiplyScalar: (s: number) => import("three").Vector3;
-                multiplyVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                applyEuler: (euler: import("three").Euler) => import("three").Vector3;
-                applyAxisAngle: (axis: import("three").Vector3, angle: number) => import("three").Vector3;
-                applyMatrix3: (m: import("three").Matrix3) => import("three").Vector3;
-                applyNormalMatrix: (m: import("three").Matrix3) => import("three").Vector3;
-                applyMatrix4: (m: import("three").Matrix4) => import("three").Vector3;
-                applyQuaternion: (q: import("three").QuaternionLike) => import("three").Vector3;
-                project: (camera: Camera) => import("three").Vector3;
-                unproject: (camera: Camera) => import("three").Vector3;
-                transformDirection: (m: import("three").Matrix4) => import("three").Vector3;
-                divide: (v: import("three").Vector3Like) => import("three").Vector3;
-                divideScalar: (s: number) => import("three").Vector3;
-                min: (v: import("three").Vector3Like) => import("three").Vector3;
-                max: (v: import("three").Vector3Like) => import("three").Vector3;
-                clamp: (min: import("three").Vector3Like, max: import("three").Vector3Like) => import("three").Vector3;
-                clampScalar: (min: number, max: number) => import("three").Vector3;
-                clampLength: (min: number, max: number) => import("three").Vector3;
-                floor: () => import("three").Vector3;
-                ceil: () => import("three").Vector3;
-                round: () => import("three").Vector3;
-                roundToZero: () => import("three").Vector3;
-                negate: () => import("three").Vector3;
-                dot: (v: import("three").Vector3Like) => number;
+                clone: () => import('three').Vector3;
+                copy: (v: import('three').Vector3Like) => import('three').Vector3;
+                add: (v: import('three').Vector3Like) => import('three').Vector3;
+                addScalar: (s: number) => import('three').Vector3;
+                addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
+                sub: (a: import('three').Vector3Like) => import('three').Vector3;
+                subScalar: (s: number) => import('three').Vector3;
+                subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                multiply: (v: import('three').Vector3Like) => import('three').Vector3;
+                multiplyScalar: (s: number) => import('three').Vector3;
+                multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                applyEuler: (euler: import('three').Euler) => import('three').Vector3;
+                applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
+                applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
+                applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
+                applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
+                applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
+                project: (camera: Camera) => import('three').Vector3;
+                unproject: (camera: Camera) => import('three').Vector3;
+                transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
+                divide: (v: import('three').Vector3Like) => import('three').Vector3;
+                divideScalar: (s: number) => import('three').Vector3;
+                min: (v: import('three').Vector3Like) => import('three').Vector3;
+                max: (v: import('three').Vector3Like) => import('three').Vector3;
+                clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
+                clampScalar: (min: number, max: number) => import('three').Vector3;
+                clampLength: (min: number, max: number) => import('three').Vector3;
+                floor: () => import('three').Vector3;
+                ceil: () => import('three').Vector3;
+                round: () => import('three').Vector3;
+                roundToZero: () => import('three').Vector3;
+                negate: () => import('three').Vector3;
+                dot: (v: import('three').Vector3Like) => number;
                 lengthSq: () => number;
                 length: () => number;
                 manhattanLength: () => number;
-                normalize: () => import("three").Vector3;
-                setLength: (l: number) => import("three").Vector3;
-                lerp: (v: import("three").Vector3Like, alpha: number) => import("three").Vector3;
-                lerpVectors: (v1: import("three").Vector3Like, v2: import("three").Vector3Like, alpha: number) => import("three").Vector3;
-                cross: (a: import("three").Vector3Like) => import("three").Vector3;
-                crossVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                projectOnVector: (v: import("three").Vector3) => import("three").Vector3;
-                projectOnPlane: (planeNormal: import("three").Vector3) => import("three").Vector3;
-                reflect: (vector: import("three").Vector3Like) => import("three").Vector3;
-                angleTo: (v: import("three").Vector3) => number;
-                distanceTo: (v: import("three").Vector3Like) => number;
-                distanceToSquared: (v: import("three").Vector3Like) => number;
-                manhattanDistanceTo: (v: import("three").Vector3Like) => number;
-                setFromSpherical: (s: import("three").Spherical) => import("three").Vector3;
-                setFromSphericalCoords: (r: number, phi: number, theta: number) => import("three").Vector3;
-                setFromCylindrical: (s: import("three").Cylindrical) => import("three").Vector3;
-                setFromCylindricalCoords: (radius: number, theta: number, y: number) => import("three").Vector3;
-                setFromMatrixPosition: (m: import("three").Matrix4) => import("three").Vector3;
-                setFromMatrixScale: (m: import("three").Matrix4) => import("three").Vector3;
-                setFromMatrixColumn: (matrix: import("three").Matrix4, index: number) => import("three").Vector3;
-                setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => import("three").Vector3;
-                setFromEuler: (e: import("three").Euler) => import("three").Vector3;
-                setFromColor: (color: import("three").RGB) => import("three").Vector3;
-                equals: (v: import("three").Vector3Like) => boolean;
-                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector3;
+                normalize: () => import('three').Vector3;
+                setLength: (l: number) => import('three').Vector3;
+                lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
+                lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
+                cross: (a: import('three').Vector3Like) => import('three').Vector3;
+                crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
+                projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
+                reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
+                angleTo: (v: import('three').Vector3) => number;
+                distanceTo: (v: import('three').Vector3Like) => number;
+                distanceToSquared: (v: import('three').Vector3Like) => number;
+                manhattanDistanceTo: (v: import('three').Vector3Like) => number;
+                setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
+                setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
+                setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
+                setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
+                setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
+                setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
+                setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
+                setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
+                setFromEuler: (e: import('three').Euler) => import('three').Vector3;
+                setFromColor: (color: import('three').RGB) => import('three').Vector3;
+                equals: (v: import('three').Vector3Like) => boolean;
+                fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector3;
                 toArray: {
-                    (array?: number[] | undefined, offset?: number | undefined): number[];
-                    (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
-                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
+                    (array?: number[], offset?: number): number[];
+                    (array?: import('three').Vector3Tuple, offset?: 0): import('three').Vector3Tuple;
+                    (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                 };
-                fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => import("three").Vector3;
-                random: () => import("three").Vector3;
-                randomDirection: () => import("three").Vector3;
-                [Symbol.iterator]: () => Iterator<number, any, undefined>;
+                fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
+                random: () => import('three').Vector3;
+                randomDirection: () => import('three').Vector3;
+                [Symbol.iterator]: () => Iterator<number>;
             };
             readonly rotation: {
                 x: number;
                 y: number;
                 z: number;
-                order: import("three").EulerOrder;
+                order: import('three').EulerOrder;
                 readonly isEuler: true;
                 _onChangeCallback: () => void;
-                set: (x: number, y: number, z: number, order?: import("three").EulerOrder | undefined) => import("three").Euler;
-                clone: () => import("three").Euler;
-                copy: (euler: import("three").Euler) => import("three").Euler;
-                setFromRotationMatrix: (m: import("three").Matrix4, order?: import("three").EulerOrder | undefined, update?: boolean | undefined) => import("three").Euler;
-                setFromQuaternion: (q: import("three").Quaternion, order?: import("three").EulerOrder | undefined, update?: boolean | undefined) => import("three").Euler;
-                setFromVector3: (v: import("three").Vector3, order?: import("three").EulerOrder | undefined) => import("three").Euler;
-                reorder: (newOrder: import("three").EulerOrder) => import("three").Euler;
-                equals: (euler: import("three").Euler) => boolean;
-                fromArray: (xyzo: [number, number, number, (import("three").EulerOrder | undefined)?, ...any[]]) => import("three").Euler;
-                toArray: (array?: (string | number | undefined)[] | undefined, offset?: number | undefined) => (string | number | undefined)[];
-                _onChange: (callback: () => void) => import("three").Euler;
-                [Symbol.iterator]: () => Generator<string | number, void, unknown>;
+                set: (x: number, y: number, z: number, order?: import('three').EulerOrder) => import('three').Euler;
+                clone: () => import('three').Euler;
+                copy: (euler: import('three').Euler) => import('three').Euler;
+                setFromRotationMatrix: (m: import('three').Matrix4, order?: import('three').EulerOrder, update?: boolean) => import('three').Euler;
+                setFromQuaternion: (q: import('three').Quaternion, order?: import('three').EulerOrder, update?: boolean) => import('three').Euler;
+                setFromVector3: (v: import('three').Vector3, order?: import('three').EulerOrder) => import('three').Euler;
+                reorder: (newOrder: import('three').EulerOrder) => import('three').Euler;
+                equals: (euler: import('three').Euler) => boolean;
+                fromArray: (xyzo: [number, number, number, import('three').EulerOrder?, ...any[]]) => import('three').Euler;
+                toArray: (array?: Array<number | string | undefined>, offset?: number) => Array<number | string | undefined>;
+                _onChange: (callback: () => void) => import('three').Euler;
+                [Symbol.iterator]: () => Generator<string | number, void>;
             };
             readonly quaternion: {
                 x: number;
@@ -464,348 +468,352 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                 z: number;
                 w: number;
                 readonly isQuaternion: true;
-                set: (x: number, y: number, z: number, w: number) => import("three").Quaternion;
-                clone: () => import("three").Quaternion;
-                copy: (q: import("three").QuaternionLike) => import("three").Quaternion;
-                setFromEuler: (euler: import("three").Euler, update?: boolean | undefined) => import("three").Quaternion;
-                setFromAxisAngle: (axis: import("three").Vector3Like, angle: number) => import("three").Quaternion;
-                setFromRotationMatrix: (m: import("three").Matrix4) => import("three").Quaternion;
-                setFromUnitVectors: (vFrom: import("three").Vector3, vTo: import("three").Vector3Like) => import("three").Quaternion;
-                angleTo: (q: import("three").Quaternion) => number;
-                rotateTowards: (q: import("three").Quaternion, step: number) => import("three").Quaternion;
-                identity: () => import("three").Quaternion;
-                invert: () => import("three").Quaternion;
-                conjugate: () => import("three").Quaternion;
-                dot: (v: import("three").Quaternion) => number;
+                set: (x: number, y: number, z: number, w: number) => import('three').Quaternion;
+                clone: () => import('three').Quaternion;
+                copy: (q: import('three').QuaternionLike) => import('three').Quaternion;
+                setFromEuler: (euler: import('three').Euler, update?: boolean) => import('three').Quaternion;
+                setFromAxisAngle: (axis: import('three').Vector3Like, angle: number) => import('three').Quaternion;
+                setFromRotationMatrix: (m: import('three').Matrix4) => import('three').Quaternion;
+                setFromUnitVectors: (vFrom: import('three').Vector3, vTo: import('three').Vector3Like) => import('three').Quaternion;
+                angleTo: (q: import('three').Quaternion) => number;
+                rotateTowards: (q: import('three').Quaternion, step: number) => import('three').Quaternion;
+                identity: () => import('three').Quaternion;
+                invert: () => import('three').Quaternion;
+                conjugate: () => import('three').Quaternion;
+                dot: (v: import('three').Quaternion) => number;
                 lengthSq: () => number;
                 length: () => number;
-                normalize: () => import("three").Quaternion;
-                multiply: (q: import("three").Quaternion) => import("three").Quaternion;
-                premultiply: (q: import("three").Quaternion) => import("three").Quaternion;
-                multiplyQuaternions: (a: import("three").Quaternion, b: import("three").Quaternion) => import("three").Quaternion;
-                slerp: (qb: import("three").Quaternion, t: number) => import("three").Quaternion;
-                slerpQuaternions: (qa: import("three").Quaternion, qb: import("three").Quaternion, t: number) => import("three").Quaternion;
-                equals: (v: import("three").Quaternion) => boolean;
-                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Quaternion;
+                normalize: () => import('three').Quaternion;
+                multiply: (q: import('three').Quaternion) => import('three').Quaternion;
+                premultiply: (q: import('three').Quaternion) => import('three').Quaternion;
+                multiplyQuaternions: (a: import('three').Quaternion, b: import('three').Quaternion) => import('three').Quaternion;
+                slerp: (qb: import('three').Quaternion, t: number) => import('three').Quaternion;
+                slerpQuaternions: (qa: import('three').Quaternion, qb: import('three').Quaternion, t: number) => import('three').Quaternion;
+                equals: (v: import('three').Quaternion) => boolean;
+                fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Quaternion;
                 toArray: {
-                    (array?: number[] | undefined, offset?: number | undefined): number[];
-                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
+                    (array?: number[], offset?: number): number[];
+                    (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                 };
                 toJSON: () => [number, number, number, number];
-                fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => import("three").Quaternion;
-                _onChange: (callback: () => void) => import("three").Quaternion;
+                fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Quaternion;
+                _onChange: (callback: () => void) => import('three').Quaternion;
                 _onChangeCallback: () => void;
-                random: () => import("three").Quaternion;
-                [Symbol.iterator]: () => Generator<number, void, unknown>;
+                random: () => import('three').Quaternion;
+                [Symbol.iterator]: () => Generator<number, void>;
             };
             readonly scale: {
                 x: number;
                 y: number;
                 z: number;
                 readonly isVector3: true;
-                set: (x: number, y: number, z: number) => import("three").Vector3;
-                setScalar: (scalar: number) => import("three").Vector3;
-                setX: (x: number) => import("three").Vector3;
-                setY: (y: number) => import("three").Vector3;
-                setZ: (z: number) => import("three").Vector3;
-                setComponent: (index: number, value: number) => import("three").Vector3;
+                set: (x: number, y: number, z: number) => import('three').Vector3;
+                setScalar: (scalar: number) => import('three').Vector3;
+                setX: (x: number) => import('three').Vector3;
+                setY: (y: number) => import('three').Vector3;
+                setZ: (z: number) => import('three').Vector3;
+                setComponent: (index: number, value: number) => import('three').Vector3;
                 getComponent: (index: number) => number;
-                clone: () => import("three").Vector3;
-                copy: (v: import("three").Vector3Like) => import("three").Vector3;
-                add: (v: import("three").Vector3Like) => import("three").Vector3;
-                addScalar: (s: number) => import("three").Vector3;
-                addVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                addScaledVector: (v: import("three").Vector3, s: number) => import("three").Vector3;
-                sub: (a: import("three").Vector3Like) => import("three").Vector3;
-                subScalar: (s: number) => import("three").Vector3;
-                subVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                multiply: (v: import("three").Vector3Like) => import("three").Vector3;
-                multiplyScalar: (s: number) => import("three").Vector3;
-                multiplyVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                applyEuler: (euler: import("three").Euler) => import("three").Vector3;
-                applyAxisAngle: (axis: import("three").Vector3, angle: number) => import("three").Vector3;
-                applyMatrix3: (m: import("three").Matrix3) => import("three").Vector3;
-                applyNormalMatrix: (m: import("three").Matrix3) => import("three").Vector3;
-                applyMatrix4: (m: import("three").Matrix4) => import("three").Vector3;
-                applyQuaternion: (q: import("three").QuaternionLike) => import("three").Vector3;
-                project: (camera: Camera) => import("three").Vector3;
-                unproject: (camera: Camera) => import("three").Vector3;
-                transformDirection: (m: import("three").Matrix4) => import("three").Vector3;
-                divide: (v: import("three").Vector3Like) => import("three").Vector3;
-                divideScalar: (s: number) => import("three").Vector3;
-                min: (v: import("three").Vector3Like) => import("three").Vector3;
-                max: (v: import("three").Vector3Like) => import("three").Vector3;
-                clamp: (min: import("three").Vector3Like, max: import("three").Vector3Like) => import("three").Vector3;
-                clampScalar: (min: number, max: number) => import("three").Vector3;
-                clampLength: (min: number, max: number) => import("three").Vector3;
-                floor: () => import("three").Vector3;
-                ceil: () => import("three").Vector3;
-                round: () => import("three").Vector3;
-                roundToZero: () => import("three").Vector3;
-                negate: () => import("three").Vector3;
-                dot: (v: import("three").Vector3Like) => number;
+                clone: () => import('three').Vector3;
+                copy: (v: import('three').Vector3Like) => import('three').Vector3;
+                add: (v: import('three').Vector3Like) => import('three').Vector3;
+                addScalar: (s: number) => import('three').Vector3;
+                addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
+                sub: (a: import('three').Vector3Like) => import('three').Vector3;
+                subScalar: (s: number) => import('three').Vector3;
+                subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                multiply: (v: import('three').Vector3Like) => import('three').Vector3;
+                multiplyScalar: (s: number) => import('three').Vector3;
+                multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                applyEuler: (euler: import('three').Euler) => import('three').Vector3;
+                applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
+                applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
+                applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
+                applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
+                applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
+                project: (camera: Camera) => import('three').Vector3;
+                unproject: (camera: Camera) => import('three').Vector3;
+                transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
+                divide: (v: import('three').Vector3Like) => import('three').Vector3;
+                divideScalar: (s: number) => import('three').Vector3;
+                min: (v: import('three').Vector3Like) => import('three').Vector3;
+                max: (v: import('three').Vector3Like) => import('three').Vector3;
+                clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
+                clampScalar: (min: number, max: number) => import('three').Vector3;
+                clampLength: (min: number, max: number) => import('three').Vector3;
+                floor: () => import('three').Vector3;
+                ceil: () => import('three').Vector3;
+                round: () => import('three').Vector3;
+                roundToZero: () => import('three').Vector3;
+                negate: () => import('three').Vector3;
+                dot: (v: import('three').Vector3Like) => number;
                 lengthSq: () => number;
                 length: () => number;
                 manhattanLength: () => number;
-                normalize: () => import("three").Vector3;
-                setLength: (l: number) => import("three").Vector3;
-                lerp: (v: import("three").Vector3Like, alpha: number) => import("three").Vector3;
-                lerpVectors: (v1: import("three").Vector3Like, v2: import("three").Vector3Like, alpha: number) => import("three").Vector3;
-                cross: (a: import("three").Vector3Like) => import("three").Vector3;
-                crossVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                projectOnVector: (v: import("three").Vector3) => import("three").Vector3;
-                projectOnPlane: (planeNormal: import("three").Vector3) => import("three").Vector3;
-                reflect: (vector: import("three").Vector3Like) => import("three").Vector3;
-                angleTo: (v: import("three").Vector3) => number;
-                distanceTo: (v: import("three").Vector3Like) => number;
-                distanceToSquared: (v: import("three").Vector3Like) => number;
-                manhattanDistanceTo: (v: import("three").Vector3Like) => number;
-                setFromSpherical: (s: import("three").Spherical) => import("three").Vector3;
-                setFromSphericalCoords: (r: number, phi: number, theta: number) => import("three").Vector3;
-                setFromCylindrical: (s: import("three").Cylindrical) => import("three").Vector3;
-                setFromCylindricalCoords: (radius: number, theta: number, y: number) => import("three").Vector3;
-                setFromMatrixPosition: (m: import("three").Matrix4) => import("three").Vector3;
-                setFromMatrixScale: (m: import("three").Matrix4) => import("three").Vector3;
-                setFromMatrixColumn: (matrix: import("three").Matrix4, index: number) => import("three").Vector3;
-                setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => import("three").Vector3;
-                setFromEuler: (e: import("three").Euler) => import("three").Vector3;
-                setFromColor: (color: import("three").RGB) => import("three").Vector3;
-                equals: (v: import("three").Vector3Like) => boolean;
-                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector3;
+                normalize: () => import('three').Vector3;
+                setLength: (l: number) => import('three').Vector3;
+                lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
+                lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
+                cross: (a: import('three').Vector3Like) => import('three').Vector3;
+                crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
+                projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
+                reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
+                angleTo: (v: import('three').Vector3) => number;
+                distanceTo: (v: import('three').Vector3Like) => number;
+                distanceToSquared: (v: import('three').Vector3Like) => number;
+                manhattanDistanceTo: (v: import('three').Vector3Like) => number;
+                setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
+                setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
+                setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
+                setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
+                setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
+                setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
+                setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
+                setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
+                setFromEuler: (e: import('three').Euler) => import('three').Vector3;
+                setFromColor: (color: import('three').RGB) => import('three').Vector3;
+                equals: (v: import('three').Vector3Like) => boolean;
+                fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector3;
                 toArray: {
-                    (array?: number[] | undefined, offset?: number | undefined): number[];
-                    (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
-                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
+                    (array?: number[], offset?: number): number[];
+                    (array?: import('three').Vector3Tuple, offset?: 0): import('three').Vector3Tuple;
+                    (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                 };
-                fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => import("three").Vector3;
-                random: () => import("three").Vector3;
-                randomDirection: () => import("three").Vector3;
-                [Symbol.iterator]: () => Iterator<number, any, undefined>;
+                fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
+                random: () => import('three').Vector3;
+                randomDirection: () => import('three').Vector3;
+                [Symbol.iterator]: () => Iterator<number>;
             };
             readonly modelViewMatrix: {
+                readonly isMatrix4: true;
                 elements: number[];
-                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import("three").Matrix4;
-                identity: () => import("three").Matrix4;
-                clone: () => import("three").Matrix4;
-                copy: (m: import("three").Matrix4) => import("three").Matrix4;
-                copyPosition: (m: import("three").Matrix4) => import("three").Matrix4;
-                extractBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
-                makeBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
-                extractRotation: (m: import("three").Matrix4) => import("three").Matrix4;
-                makeRotationFromEuler: (euler: import("three").Euler) => import("three").Matrix4;
-                makeRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
-                lookAt: (eye: import("three").Vector3, target: import("three").Vector3, up: import("three").Vector3) => import("three").Matrix4;
-                multiply: (m: import("three").Matrix4) => import("three").Matrix4;
-                premultiply: (m: import("three").Matrix4) => import("three").Matrix4;
-                multiplyMatrices: (a: import("three").Matrix4, b: import("three").Matrix4) => import("three").Matrix4;
-                multiplyToArray: (a: import("three").Matrix4, b: import("three").Matrix4, r: number[]) => import("three").Matrix4;
-                multiplyScalar: (s: number) => import("three").Matrix4;
+                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
+                identity: () => import('three').Matrix4;
+                clone: () => import('three').Matrix4;
+                copy: (m: import('three').Matrix4) => import('three').Matrix4;
+                copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
+                extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
+                makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
+                extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
+                makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
+                makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
+                lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
+                multiply: (m: import('three').Matrix4) => import('three').Matrix4;
+                premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
+                multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
+                multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
+                multiplyScalar: (s: number) => import('three').Matrix4;
                 determinant: () => number;
-                transpose: () => import("three").Matrix4;
+                transpose: () => import('three').Matrix4;
                 setPosition: {
-                    (v: import("three").Vector3): import("three").Matrix4;
-                    (x: number, y: number, z: number): import("three").Matrix4;
+                    (v: import('three').Vector3): import('three').Matrix4;
+                    (x: number, y: number, z: number): import('three').Matrix4;
                 };
-                invert: () => import("three").Matrix4;
-                scale: (v: import("three").Vector3) => import("three").Matrix4;
+                invert: () => import('three').Matrix4;
+                scale: (v: import('three').Vector3) => import('three').Matrix4;
                 getMaxScaleOnAxis: () => number;
                 makeTranslation: {
-                    (v: import("three").Vector3): import("three").Matrix4;
-                    (x: number, y: number, z: number): import("three").Matrix4;
+                    (v: import('three').Vector3): import('three').Matrix4;
+                    (x: number, y: number, z: number): import('three').Matrix4;
                 };
-                makeRotationX: (theta: number) => import("three").Matrix4;
-                makeRotationY: (theta: number) => import("three").Matrix4;
-                makeRotationZ: (theta: number) => import("three").Matrix4;
-                makeRotationAxis: (axis: import("three").Vector3, angle: number) => import("three").Matrix4;
-                makeScale: (x: number, y: number, z: number) => import("three").Matrix4;
-                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import("three").Matrix4;
-                compose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
-                decompose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
-                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => import("three").Matrix4;
-                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => import("three").Matrix4;
-                equals: (matrix: import("three").Matrix4) => boolean;
-                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Matrix4;
+                makeRotationX: (theta: number) => import('three').Matrix4;
+                makeRotationY: (theta: number) => import('three').Matrix4;
+                makeRotationZ: (theta: number) => import('three').Matrix4;
+                makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
+                makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
+                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
+                compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
+                decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
+                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
+                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
+                equals: (matrix: import('three').Matrix4) => boolean;
+                fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Matrix4;
                 toArray: {
-                    (array?: number[] | undefined, offset?: number | undefined): number[];
-                    (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
-                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
+                    (array?: number[], offset?: number): number[];
+                    (array?: import('three').Matrix4Tuple, offset?: 0): import('three').Matrix4Tuple;
+                    (array?: ArrayLike<number>, offset?: number): ArrayLike<number>;
                 };
-                setFromMatrix3: (m: import("three").Matrix3) => import("three").Matrix4;
-                extractPosition: (m: import("three").Matrix4) => import("three").Matrix4;
-                setRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
+                setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
+                extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
+                setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                 multiplyVector3: (v: any) => any;
                 multiplyVector4: (v: any) => any;
                 multiplyVector3Array: (array: number[]) => number[];
                 rotateAxis: (v: any) => void;
                 crossVector: (v: any) => void;
                 flattenToArrayOffset: (array: number[], offset: number) => number[];
-                getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
+                getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
             };
             readonly normalMatrix: {
+                readonly isMatrix3: true;
                 elements: number[];
-                set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => import("three").Matrix3;
-                identity: () => import("three").Matrix3;
-                clone: () => import("three").Matrix3;
-                copy: (m: import("three").Matrix3) => import("three").Matrix3;
-                extractBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix3;
-                setFromMatrix4: (m: import("three").Matrix4) => import("three").Matrix3;
-                multiplyScalar: (s: number) => import("three").Matrix3;
+                set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => import('three').Matrix3;
+                identity: () => import('three').Matrix3;
+                clone: () => import('three').Matrix3;
+                copy: (m: import('three').Matrix3) => import('three').Matrix3;
+                extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix3;
+                setFromMatrix4: (m: import('three').Matrix4) => import('three').Matrix3;
+                multiplyScalar: (s: number) => import('three').Matrix3;
                 determinant: () => number;
-                invert: () => import("three").Matrix3;
-                transpose: () => import("three").Matrix3;
-                getNormalMatrix: (matrix4: import("three").Matrix4) => import("three").Matrix3;
-                transposeIntoArray: (r: number[]) => import("three").Matrix3;
-                setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => import("three").Matrix3;
-                scale: (sx: number, sy: number) => import("three").Matrix3;
+                invert: () => import('three').Matrix3;
+                transpose: () => import('three').Matrix3;
+                getNormalMatrix: (matrix4: import('three').Matrix4) => import('three').Matrix3;
+                transposeIntoArray: (r: number[]) => import('three').Matrix3;
+                setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => import('three').Matrix3;
+                scale: (sx: number, sy: number) => import('three').Matrix3;
                 makeTranslation: {
-                    (v: import("three").Vector2): import("three").Matrix3;
-                    (x: number, y: number): import("three").Matrix3;
+                    (v: import('three').Vector2): import('three').Matrix3;
+                    (x: number, y: number): import('three').Matrix3;
                 };
                 makeRotation: {
-                    (theta: number): import("three").Matrix3;
-                    (theta: number): import("three").Matrix3;
+                    (theta: number): import('three').Matrix3;
+                    (theta: number): import('three').Matrix3;
                 };
                 makeScale: {
-                    (x: number, y: number): import("three").Matrix3;
-                    (x: number, y: number): import("three").Matrix3;
+                    (x: number, y: number): import('three').Matrix3;
+                    (x: number, y: number): import('three').Matrix3;
                 };
-                rotate: (theta: number) => import("three").Matrix3;
-                translate: (tx: number, ty: number) => import("three").Matrix3;
-                equals: (matrix: import("three").Matrix3) => boolean;
-                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Matrix3;
+                rotate: (theta: number) => import('three').Matrix3;
+                translate: (tx: number, ty: number) => import('three').Matrix3;
+                equals: (matrix: import('three').Matrix3) => boolean;
+                fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Matrix3;
                 toArray: {
-                    (array?: number[] | undefined, offset?: number | undefined): number[];
-                    (array?: import("three").Matrix3Tuple | undefined, offset?: 0 | undefined): import("three").Matrix3Tuple;
-                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
+                    (array?: number[], offset?: number): number[];
+                    (array?: import('three').Matrix3Tuple, offset?: 0): import('three').Matrix3Tuple;
+                    (array?: ArrayLike<number>, offset?: number): ArrayLike<number>;
                 };
-                multiply: (m: import("three").Matrix3) => import("three").Matrix3;
-                premultiply: (m: import("three").Matrix3) => import("three").Matrix3;
-                multiplyMatrices: (a: import("three").Matrix3, b: import("three").Matrix3) => import("three").Matrix3;
-                multiplyVector3: (vector: import("three").Vector3) => any;
+                multiply: (m: import('three').Matrix3) => import('three').Matrix3;
+                premultiply: (m: import('three').Matrix3) => import('three').Matrix3;
+                multiplyMatrices: (a: import('three').Matrix3, b: import('three').Matrix3) => import('three').Matrix3;
+                multiplyVector3: (vector: import('three').Vector3) => any;
                 multiplyVector3Array: (a: any) => any;
                 getInverse: {
-                    (matrix: import("three").Matrix4, throwOnDegenerate?: boolean | undefined): import("three").Matrix3;
-                    (matrix: import("three").Matrix): import("three").Matrix;
+                    (matrix: import('three').Matrix4, throwOnDegenerate?: boolean): import('three').Matrix3;
+                    (matrix: import('three').Matrix): import('three').Matrix;
                 };
                 flattenToArrayOffset: (array: number[], offset: number) => number[];
             };
             matrix: {
+                readonly isMatrix4: true;
                 elements: number[];
-                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import("three").Matrix4;
-                identity: () => import("three").Matrix4;
-                clone: () => import("three").Matrix4;
-                copy: (m: import("three").Matrix4) => import("three").Matrix4;
-                copyPosition: (m: import("three").Matrix4) => import("three").Matrix4;
-                extractBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
-                makeBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
-                extractRotation: (m: import("three").Matrix4) => import("three").Matrix4;
-                makeRotationFromEuler: (euler: import("three").Euler) => import("three").Matrix4;
-                makeRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
-                lookAt: (eye: import("three").Vector3, target: import("three").Vector3, up: import("three").Vector3) => import("three").Matrix4;
-                multiply: (m: import("three").Matrix4) => import("three").Matrix4;
-                premultiply: (m: import("three").Matrix4) => import("three").Matrix4;
-                multiplyMatrices: (a: import("three").Matrix4, b: import("three").Matrix4) => import("three").Matrix4;
-                multiplyToArray: (a: import("three").Matrix4, b: import("three").Matrix4, r: number[]) => import("three").Matrix4;
-                multiplyScalar: (s: number) => import("three").Matrix4;
+                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
+                identity: () => import('three').Matrix4;
+                clone: () => import('three').Matrix4;
+                copy: (m: import('three').Matrix4) => import('three').Matrix4;
+                copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
+                extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
+                makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
+                extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
+                makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
+                makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
+                lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
+                multiply: (m: import('three').Matrix4) => import('three').Matrix4;
+                premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
+                multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
+                multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
+                multiplyScalar: (s: number) => import('three').Matrix4;
                 determinant: () => number;
-                transpose: () => import("three").Matrix4;
+                transpose: () => import('three').Matrix4;
                 setPosition: {
-                    (v: import("three").Vector3): import("three").Matrix4;
-                    (x: number, y: number, z: number): import("three").Matrix4;
+                    (v: import('three').Vector3): import('three').Matrix4;
+                    (x: number, y: number, z: number): import('three').Matrix4;
                 };
-                invert: () => import("three").Matrix4;
-                scale: (v: import("three").Vector3) => import("three").Matrix4;
+                invert: () => import('three').Matrix4;
+                scale: (v: import('three').Vector3) => import('three').Matrix4;
                 getMaxScaleOnAxis: () => number;
                 makeTranslation: {
-                    (v: import("three").Vector3): import("three").Matrix4;
-                    (x: number, y: number, z: number): import("three").Matrix4;
+                    (v: import('three').Vector3): import('three').Matrix4;
+                    (x: number, y: number, z: number): import('three').Matrix4;
                 };
-                makeRotationX: (theta: number) => import("three").Matrix4;
-                makeRotationY: (theta: number) => import("three").Matrix4;
-                makeRotationZ: (theta: number) => import("three").Matrix4;
-                makeRotationAxis: (axis: import("three").Vector3, angle: number) => import("three").Matrix4;
-                makeScale: (x: number, y: number, z: number) => import("three").Matrix4;
-                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import("three").Matrix4;
-                compose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
-                decompose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
-                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => import("three").Matrix4;
-                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => import("three").Matrix4;
-                equals: (matrix: import("three").Matrix4) => boolean;
-                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Matrix4;
+                makeRotationX: (theta: number) => import('three').Matrix4;
+                makeRotationY: (theta: number) => import('three').Matrix4;
+                makeRotationZ: (theta: number) => import('three').Matrix4;
+                makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
+                makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
+                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
+                compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
+                decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
+                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
+                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
+                equals: (matrix: import('three').Matrix4) => boolean;
+                fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Matrix4;
                 toArray: {
-                    (array?: number[] | undefined, offset?: number | undefined): number[];
-                    (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
-                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
+                    (array?: number[], offset?: number): number[];
+                    (array?: import('three').Matrix4Tuple, offset?: 0): import('three').Matrix4Tuple;
+                    (array?: ArrayLike<number>, offset?: number): ArrayLike<number>;
                 };
-                setFromMatrix3: (m: import("three").Matrix3) => import("three").Matrix4;
-                extractPosition: (m: import("three").Matrix4) => import("three").Matrix4;
-                setRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
+                setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
+                extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
+                setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                 multiplyVector3: (v: any) => any;
                 multiplyVector4: (v: any) => any;
                 multiplyVector3Array: (array: number[]) => number[];
                 rotateAxis: (v: any) => void;
                 crossVector: (v: any) => void;
                 flattenToArrayOffset: (array: number[], offset: number) => number[];
-                getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
+                getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
             };
             matrixWorld: {
+                readonly isMatrix4: true;
                 elements: number[];
-                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import("three").Matrix4;
-                identity: () => import("three").Matrix4;
-                clone: () => import("three").Matrix4;
-                copy: (m: import("three").Matrix4) => import("three").Matrix4;
-                copyPosition: (m: import("three").Matrix4) => import("three").Matrix4;
-                extractBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
-                makeBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
-                extractRotation: (m: import("three").Matrix4) => import("three").Matrix4;
-                makeRotationFromEuler: (euler: import("three").Euler) => import("three").Matrix4;
-                makeRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
-                lookAt: (eye: import("three").Vector3, target: import("three").Vector3, up: import("three").Vector3) => import("three").Matrix4;
-                multiply: (m: import("three").Matrix4) => import("three").Matrix4;
-                premultiply: (m: import("three").Matrix4) => import("three").Matrix4;
-                multiplyMatrices: (a: import("three").Matrix4, b: import("three").Matrix4) => import("three").Matrix4;
-                multiplyToArray: (a: import("three").Matrix4, b: import("three").Matrix4, r: number[]) => import("three").Matrix4;
-                multiplyScalar: (s: number) => import("three").Matrix4;
+                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
+                identity: () => import('three').Matrix4;
+                clone: () => import('three').Matrix4;
+                copy: (m: import('three').Matrix4) => import('three').Matrix4;
+                copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
+                extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
+                makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
+                extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
+                makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
+                makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
+                lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
+                multiply: (m: import('three').Matrix4) => import('three').Matrix4;
+                premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
+                multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
+                multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
+                multiplyScalar: (s: number) => import('three').Matrix4;
                 determinant: () => number;
-                transpose: () => import("three").Matrix4;
+                transpose: () => import('three').Matrix4;
                 setPosition: {
-                    (v: import("three").Vector3): import("three").Matrix4;
-                    (x: number, y: number, z: number): import("three").Matrix4;
+                    (v: import('three').Vector3): import('three').Matrix4;
+                    (x: number, y: number, z: number): import('three').Matrix4;
                 };
-                invert: () => import("three").Matrix4;
-                scale: (v: import("three").Vector3) => import("three").Matrix4;
+                invert: () => import('three').Matrix4;
+                scale: (v: import('three').Vector3) => import('three').Matrix4;
                 getMaxScaleOnAxis: () => number;
                 makeTranslation: {
-                    (v: import("three").Vector3): import("three").Matrix4;
-                    (x: number, y: number, z: number): import("three").Matrix4;
+                    (v: import('three').Vector3): import('three').Matrix4;
+                    (x: number, y: number, z: number): import('three').Matrix4;
                 };
-                makeRotationX: (theta: number) => import("three").Matrix4;
-                makeRotationY: (theta: number) => import("three").Matrix4;
-                makeRotationZ: (theta: number) => import("three").Matrix4;
-                makeRotationAxis: (axis: import("three").Vector3, angle: number) => import("three").Matrix4;
-                makeScale: (x: number, y: number, z: number) => import("three").Matrix4;
-                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import("three").Matrix4;
-                compose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
-                decompose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
-                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => import("three").Matrix4;
-                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => import("three").Matrix4;
-                equals: (matrix: import("three").Matrix4) => boolean;
-                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Matrix4;
+                makeRotationX: (theta: number) => import('three').Matrix4;
+                makeRotationY: (theta: number) => import('three').Matrix4;
+                makeRotationZ: (theta: number) => import('three').Matrix4;
+                makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
+                makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
+                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
+                compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
+                decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
+                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
+                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
+                equals: (matrix: import('three').Matrix4) => boolean;
+                fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Matrix4;
                 toArray: {
-                    (array?: number[] | undefined, offset?: number | undefined): number[];
-                    (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
-                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
+                    (array?: number[], offset?: number): number[];
+                    (array?: import('three').Matrix4Tuple, offset?: 0): import('three').Matrix4Tuple;
+                    (array?: ArrayLike<number>, offset?: number): ArrayLike<number>;
                 };
-                setFromMatrix3: (m: import("three").Matrix3) => import("three").Matrix4;
-                extractPosition: (m: import("three").Matrix4) => import("three").Matrix4;
-                setRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
+                setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
+                extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
+                setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                 multiplyVector3: (v: any) => any;
                 multiplyVector4: (v: any) => any;
                 multiplyVector3Array: (array: number[]) => number[];
                 rotateAxis: (v: any) => void;
                 crossVector: (v: any) => void;
                 flattenToArrayOffset: (array: number[], offset: number) => number[];
-                getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
+                getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
             };
             matrixAutoUpdate: boolean;
             matrixWorldAutoUpdate: boolean;
@@ -818,7 +826,7 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                 toggle: (layer: number) => void;
                 disable: (layer: number) => void;
                 disableAll: () => void;
-                test: (layers: import("three").Layers) => boolean;
+                test: (layers: import('three').Layers) => boolean;
                 isEnabled: (layer: number) => boolean;
             };
             visible: boolean;
@@ -835,26 +843,26 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                         readonly BYTES_PER_ELEMENT: number;
                         readonly buffer: {
                             readonly byteLength: number;
-                            slice: (begin: number, end?: number | undefined) => ArrayBuffer;
+                            slice: (begin: number, end?: number) => ArrayBuffer;
                             readonly [Symbol.toStringTag]: string;
                         } | {
                             readonly byteLength: number;
-                            slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
+                            slice: (begin: number, end?: number) => SharedArrayBuffer;
                             readonly [Symbol.species]: SharedArrayBuffer;
                             readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                         };
                         readonly byteLength: number;
                         readonly byteOffset: number;
-                        copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
+                        copyWithin: (target: number, start: number, end?: number) => Float32Array;
                         every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
-                        fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
+                        fill: (value: number, start?: number, end?: number) => Float32Array;
                         filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                         find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                         findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                         forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
-                        indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
-                        join: (separator?: string | undefined) => string;
-                        lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
+                        indexOf: (searchElement: number, fromIndex?: number) => number;
+                        join: (separator?: string) => string;
+                        lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                         readonly length: number;
                         map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                         reduce: {
@@ -865,21 +873,24 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                         reduceRight: {
                             (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                             (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
-                            <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
+                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                         };
                         reverse: () => Float32Array;
-                        set: (array: ArrayLike<number>, offset?: number | undefined) => void;
-                        slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
+                        set: (array: ArrayLike<number>, offset?: number) => void;
+                        slice: (start?: number, end?: number) => Float32Array;
                         some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                         sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
-                        subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
-                        toLocaleString: () => string;
+                        subarray: (begin?: number, end?: number) => Float32Array;
+                        toLocaleString: {
+                            (): string;
+                            (locales: string | string[], options?: Intl.NumberFormatOptions): string;
+                        };
                         toString: () => string;
                         valueOf: () => Float32Array;
                         entries: () => IterableIterator<[number, number]>;
                         keys: () => IterableIterator<number>;
                         values: () => IterableIterator<number>;
-                        includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
+                        includes: (searchElement: number, fromIndex?: number) => boolean;
                         at: (index: number) => number | undefined;
                         findLast: {
                             <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
@@ -897,26 +908,26 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                         readonly BYTES_PER_ELEMENT: number;
                         readonly buffer: {
                             readonly byteLength: number;
-                            slice: (begin: number, end?: number | undefined) => ArrayBuffer;
+                            slice: (begin: number, end?: number) => ArrayBuffer;
                             readonly [Symbol.toStringTag]: string;
                         } | {
                             readonly byteLength: number;
-                            slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
+                            slice: (begin: number, end?: number) => SharedArrayBuffer;
                             readonly [Symbol.species]: SharedArrayBuffer;
                             readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                         };
                         readonly byteLength: number;
                         readonly byteOffset: number;
-                        copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
+                        copyWithin: (target: number, start: number, end?: number) => Float32Array;
                         every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
-                        fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
+                        fill: (value: number, start?: number, end?: number) => Float32Array;
                         filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                         find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                         findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                         forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
-                        indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
-                        join: (separator?: string | undefined) => string;
-                        lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
+                        indexOf: (searchElement: number, fromIndex?: number) => number;
+                        join: (separator?: string) => string;
+                        lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                         readonly length: number;
                         map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                         reduce: {
@@ -927,21 +938,24 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                         reduceRight: {
                             (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                             (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
-                            <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
+                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                         };
                         reverse: () => Float32Array;
-                        set: (array: ArrayLike<number>, offset?: number | undefined) => void;
-                        slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
+                        set: (array: ArrayLike<number>, offset?: number) => void;
+                        slice: (start?: number, end?: number) => Float32Array;
                         some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                         sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
-                        subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
-                        toLocaleString: () => string;
+                        subarray: (begin?: number, end?: number) => Float32Array;
+                        toLocaleString: {
+                            (): string;
+                            (locales: string | string[], options?: Intl.NumberFormatOptions): string;
+                        };
                         toString: () => string;
                         valueOf: () => Float32Array;
                         entries: () => IterableIterator<[number, number]>;
                         keys: () => IterableIterator<number>;
                         values: () => IterableIterator<number>;
-                        includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
+                        includes: (searchElement: number, fromIndex?: number) => boolean;
                         at: (index: number) => number | undefined;
                         findLast: {
                             <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
@@ -960,26 +974,26 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                         readonly BYTES_PER_ELEMENT: number;
                         readonly buffer: {
                             readonly byteLength: number;
-                            slice: (begin: number, end?: number | undefined) => ArrayBuffer;
+                            slice: (begin: number, end?: number) => ArrayBuffer;
                             readonly [Symbol.toStringTag]: string;
                         } | {
                             readonly byteLength: number;
-                            slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
+                            slice: (begin: number, end?: number) => SharedArrayBuffer;
                             readonly [Symbol.species]: SharedArrayBuffer;
                             readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                         };
                         readonly byteLength: number;
                         readonly byteOffset: number;
-                        copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
+                        copyWithin: (target: number, start: number, end?: number) => Float32Array;
                         every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
-                        fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
+                        fill: (value: number, start?: number, end?: number) => Float32Array;
                         filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                         find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                         findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                         forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
-                        indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
-                        join: (separator?: string | undefined) => string;
-                        lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
+                        indexOf: (searchElement: number, fromIndex?: number) => number;
+                        join: (separator?: string) => string;
+                        lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                         readonly length: number;
                         map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                         reduce: {
@@ -990,21 +1004,24 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                         reduceRight: {
                             (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                             (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
-                            <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
+                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                         };
                         reverse: () => Float32Array;
-                        set: (array: ArrayLike<number>, offset?: number | undefined) => void;
-                        slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
+                        set: (array: ArrayLike<number>, offset?: number) => void;
+                        slice: (start?: number, end?: number) => Float32Array;
                         some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                         sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
-                        subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
-                        toLocaleString: () => string;
+                        subarray: (begin?: number, end?: number) => Float32Array;
+                        toLocaleString: {
+                            (): string;
+                            (locales: string | string[], options?: Intl.NumberFormatOptions): string;
+                        };
                         toString: () => string;
                         valueOf: () => Float32Array;
                         entries: () => IterableIterator<[number, number]>;
                         keys: () => IterableIterator<number>;
                         values: () => IterableIterator<number>;
-                        includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
+                        includes: (searchElement: number, fromIndex?: number) => boolean;
                         at: (index: number) => number | undefined;
                         findLast: {
                             <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
@@ -1022,26 +1039,26 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                         readonly BYTES_PER_ELEMENT: number;
                         readonly buffer: {
                             readonly byteLength: number;
-                            slice: (begin: number, end?: number | undefined) => ArrayBuffer;
+                            slice: (begin: number, end?: number) => ArrayBuffer;
                             readonly [Symbol.toStringTag]: string;
                         } | {
                             readonly byteLength: number;
-                            slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
+                            slice: (begin: number, end?: number) => SharedArrayBuffer;
                             readonly [Symbol.species]: SharedArrayBuffer;
                             readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                         };
                         readonly byteLength: number;
                         readonly byteOffset: number;
-                        copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
+                        copyWithin: (target: number, start: number, end?: number) => Float32Array;
                         every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
-                        fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
+                        fill: (value: number, start?: number, end?: number) => Float32Array;
                         filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                         find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                         findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                         forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
-                        indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
-                        join: (separator?: string | undefined) => string;
-                        lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
+                        indexOf: (searchElement: number, fromIndex?: number) => number;
+                        join: (separator?: string) => string;
+                        lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                         readonly length: number;
                         map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                         reduce: {
@@ -1052,21 +1069,24 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                         reduceRight: {
                             (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                             (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
-                            <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
+                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                         };
                         reverse: () => Float32Array;
-                        set: (array: ArrayLike<number>, offset?: number | undefined) => void;
-                        slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
+                        set: (array: ArrayLike<number>, offset?: number) => void;
+                        slice: (start?: number, end?: number) => Float32Array;
                         some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                         sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
-                        subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
-                        toLocaleString: () => string;
+                        subarray: (begin?: number, end?: number) => Float32Array;
+                        toLocaleString: {
+                            (): string;
+                            (locales: string | string[], options?: Intl.NumberFormatOptions): string;
+                        };
                         toString: () => string;
                         valueOf: () => Float32Array;
                         entries: () => IterableIterator<[number, number]>;
                         keys: () => IterableIterator<number>;
                         values: () => IterableIterator<number>;
-                        includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
+                        includes: (searchElement: number, fromIndex?: number) => boolean;
                         at: (index: number) => number | undefined;
                         findLast: {
                             <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
@@ -1079,31 +1099,31 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                         [Symbol.iterator]: () => IterableIterator<number>;
                         readonly [Symbol.toStringTag]: "Float32Array";
                     };
-                    DefaultInterpolation: import("three").InterpolationModes;
-                    InterpolantFactoryMethodDiscrete: (result: any) => import("three").DiscreteInterpolant;
-                    InterpolantFactoryMethodLinear: (result: any) => import("three").LinearInterpolant;
-                    InterpolantFactoryMethodSmooth: (result: any) => import("three").CubicInterpolant;
-                    setInterpolation: (interpolation: import("three").InterpolationModes) => import("three").KeyframeTrack;
-                    getInterpolation: () => import("three").InterpolationModes;
-                    createInterpolant: () => import("three").Interpolant;
+                    DefaultInterpolation: import('three').InterpolationModes;
+                    InterpolantFactoryMethodDiscrete: (result: any) => import('three').DiscreteInterpolant;
+                    InterpolantFactoryMethodLinear: (result: any) => import('three').LinearInterpolant;
+                    InterpolantFactoryMethodSmooth: (result: any) => import('three').CubicInterpolant;
+                    setInterpolation: (interpolation: import('three').InterpolationModes) => import('three').KeyframeTrack;
+                    getInterpolation: () => import('three').InterpolationModes;
+                    createInterpolant: () => import('three').Interpolant;
                     getValueSize: () => number;
-                    shift: (timeOffset: number) => import("three").KeyframeTrack;
-                    scale: (timeScale: number) => import("three").KeyframeTrack;
-                    trim: (startTime: number, endTime: number) => import("three").KeyframeTrack;
+                    shift: (timeOffset: number) => import('three').KeyframeTrack;
+                    scale: (timeScale: number) => import('three').KeyframeTrack;
+                    trim: (startTime: number, endTime: number) => import('three').KeyframeTrack;
                     validate: () => boolean;
-                    optimize: () => import("three").KeyframeTrack;
-                    clone: () => import("three").KeyframeTrack;
+                    optimize: () => import('three').KeyframeTrack;
+                    clone: () => import('three').KeyframeTrack;
                 }[];
-                blendMode: import("three").AnimationBlendMode;
+                blendMode: import('three').AnimationBlendMode;
                 duration: number;
                 uuid: string;
                 results: any[];
-                resetDuration: () => import("three").AnimationClip;
-                trim: () => import("three").AnimationClip;
+                resetDuration: () => import('three').AnimationClip;
+                trim: () => import('three').AnimationClip;
                 validate: () => boolean;
-                optimize: () => import("three").AnimationClip;
-                clone: () => import("three").AnimationClip;
-                toJSON: (clip: import("three").AnimationClip) => any;
+                optimize: () => import('three').AnimationClip;
+                clone: () => import('three').AnimationClip;
+                toJSON: (clip: import('three').AnimationClip) => any;
             }[];
             userData: Record<string, any>;
             customDepthMaterial?: {
@@ -1116,52 +1136,52 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                     r: number;
                     g: number;
                     b: number;
-                    set: (...args: [color: import("three").ColorRepresentation] | [r: number, g: number, b: number]) => import("three").Color;
-                    setFromVector3: (vector: import("three").Vector3) => import("three").Color;
-                    setScalar: (scalar: number) => import("three").Color;
-                    setHex: (hex: number, colorSpace?: import("three").ColorSpace | undefined) => import("three").Color;
-                    setRGB: (r: number, g: number, b: number, colorSpace?: import("three").ColorSpace | undefined) => import("three").Color;
-                    setHSL: (h: number, s: number, l: number, colorSpace?: import("three").ColorSpace | undefined) => import("three").Color;
-                    setStyle: (style: string, colorSpace?: import("three").ColorSpace | undefined) => import("three").Color;
-                    setColorName: (style: string, colorSpace?: import("three").ColorSpace | undefined) => import("three").Color;
-                    clone: () => import("three").Color;
-                    copy: (color: import("three").Color) => import("three").Color;
-                    copySRGBToLinear: (color: import("three").Color) => import("three").Color;
-                    copyLinearToSRGB: (color: import("three").Color) => import("three").Color;
-                    convertSRGBToLinear: () => import("three").Color;
-                    convertLinearToSRGB: () => import("three").Color;
-                    getHex: (colorSpace?: import("three").ColorSpace | undefined) => number;
-                    getHexString: (colorSpace?: import("three").ColorSpace | undefined) => string;
-                    getHSL: (target: import("three").HSL, colorSpace?: import("three").ColorSpace | undefined) => import("three").HSL;
-                    getRGB: (target: import("three").RGB, colorSpace?: import("three").ColorSpace | undefined) => import("three").RGB;
-                    getStyle: (colorSpace?: import("three").ColorSpace | undefined) => string;
-                    offsetHSL: (h: number, s: number, l: number) => import("three").Color;
-                    add: (color: import("three").Color) => import("three").Color;
-                    addColors: (color1: import("three").Color, color2: import("three").Color) => import("three").Color;
-                    addScalar: (s: number) => import("three").Color;
-                    applyMatrix3: (m: import("three").Matrix3) => import("three").Color;
-                    sub: (color: import("three").Color) => import("three").Color;
-                    multiply: (color: import("three").Color) => import("three").Color;
-                    multiplyScalar: (s: number) => import("three").Color;
-                    lerp: (color: import("three").Color, alpha: number) => import("three").Color;
-                    lerpColors: (color1: import("three").Color, color2: import("three").Color, alpha: number) => import("three").Color;
-                    lerpHSL: (color: import("three").Color, alpha: number) => import("three").Color;
-                    equals: (color: import("three").Color) => boolean;
-                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Color;
+                    set: (...args: [color: import('three').ColorRepresentation] | [r: number, g: number, b: number]) => import('three').Color;
+                    setFromVector3: (vector: import('three').Vector3) => import('three').Color;
+                    setScalar: (scalar: number) => import('three').Color;
+                    setHex: (hex: number, colorSpace?: import('three').ColorSpace) => import('three').Color;
+                    setRGB: (r: number, g: number, b: number, colorSpace?: import('three').ColorSpace) => import('three').Color;
+                    setHSL: (h: number, s: number, l: number, colorSpace?: import('three').ColorSpace) => import('three').Color;
+                    setStyle: (style: string, colorSpace?: import('three').ColorSpace) => import('three').Color;
+                    setColorName: (style: string, colorSpace?: import('three').ColorSpace) => import('three').Color;
+                    clone: () => import('three').Color;
+                    copy: (color: import('three').Color) => import('three').Color;
+                    copySRGBToLinear: (color: import('three').Color) => import('three').Color;
+                    copyLinearToSRGB: (color: import('three').Color) => import('three').Color;
+                    convertSRGBToLinear: () => import('three').Color;
+                    convertLinearToSRGB: () => import('three').Color;
+                    getHex: (colorSpace?: import('three').ColorSpace) => number;
+                    getHexString: (colorSpace?: import('three').ColorSpace) => string;
+                    getHSL: (target: import('three').HSL, colorSpace?: import('three').ColorSpace) => import('three').HSL;
+                    getRGB: (target: import('three').RGB, colorSpace?: import('three').ColorSpace) => import('three').RGB;
+                    getStyle: (colorSpace?: import('three').ColorSpace) => string;
+                    offsetHSL: (h: number, s: number, l: number) => import('three').Color;
+                    add: (color: import('three').Color) => import('three').Color;
+                    addColors: (color1: import('three').Color, color2: import('three').Color) => import('three').Color;
+                    addScalar: (s: number) => import('three').Color;
+                    applyMatrix3: (m: import('three').Matrix3) => import('three').Color;
+                    sub: (color: import('three').Color) => import('three').Color;
+                    multiply: (color: import('three').Color) => import('three').Color;
+                    multiplyScalar: (s: number) => import('three').Color;
+                    lerp: (color: import('three').Color, alpha: number) => import('three').Color;
+                    lerpColors: (color1: import('three').Color, color2: import('three').Color, alpha: number) => import('three').Color;
+                    lerpHSL: (color: import('three').Color, alpha: number) => import('three').Color;
+                    equals: (color: import('three').Color) => boolean;
+                    fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Color;
                     toArray: {
-                        (array?: number[] | undefined, offset?: number | undefined): number[];
-                        (xyz: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
+                        (array?: number[], offset?: number): number[];
+                        (xyz: ArrayLike<number>, offset?: number): ArrayLike<number>;
                     };
                     toJSON: () => number;
-                    fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => import("three").Color;
-                    [Symbol.iterator]: () => Generator<number, void, unknown>;
+                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Color;
+                    [Symbol.iterator]: () => Generator<number, void>;
                 };
-                blendDst: import("three").BlendingDstFactor;
+                blendDst: import('three').BlendingDstFactor;
                 blendDstAlpha: number | null;
-                blendEquation: import("three").BlendingEquation;
+                blendEquation: import('three').BlendingEquation;
                 blendEquationAlpha: number | null;
-                blending: import("three").Blending;
-                blendSrc: 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207 | 208 | 209 | 211 | 212 | 213 | 214 | 210;
+                blending: import('three').Blending;
+                blendSrc: import('three').BlendingSrcFactor | import('three').BlendingDstFactor;
                 blendSrcAlpha: number | null;
                 clipIntersection: boolean;
                 clippingPlanes: {
@@ -1170,125 +1190,125 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                         y: number;
                         z: number;
                         readonly isVector3: true;
-                        set: (x: number, y: number, z: number) => import("three").Vector3;
-                        setScalar: (scalar: number) => import("three").Vector3;
-                        setX: (x: number) => import("three").Vector3;
-                        setY: (y: number) => import("three").Vector3;
-                        setZ: (z: number) => import("three").Vector3;
-                        setComponent: (index: number, value: number) => import("three").Vector3;
+                        set: (x: number, y: number, z: number) => import('three').Vector3;
+                        setScalar: (scalar: number) => import('three').Vector3;
+                        setX: (x: number) => import('three').Vector3;
+                        setY: (y: number) => import('three').Vector3;
+                        setZ: (z: number) => import('three').Vector3;
+                        setComponent: (index: number, value: number) => import('three').Vector3;
                         getComponent: (index: number) => number;
-                        clone: () => import("three").Vector3;
-                        copy: (v: import("three").Vector3Like) => import("three").Vector3;
-                        add: (v: import("three").Vector3Like) => import("three").Vector3;
-                        addScalar: (s: number) => import("three").Vector3;
-                        addVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                        addScaledVector: (v: import("three").Vector3, s: number) => import("three").Vector3;
-                        sub: (a: import("three").Vector3Like) => import("three").Vector3;
-                        subScalar: (s: number) => import("three").Vector3;
-                        subVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                        multiply: (v: import("three").Vector3Like) => import("three").Vector3;
-                        multiplyScalar: (s: number) => import("three").Vector3;
-                        multiplyVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                        applyEuler: (euler: import("three").Euler) => import("three").Vector3;
-                        applyAxisAngle: (axis: import("three").Vector3, angle: number) => import("three").Vector3;
-                        applyMatrix3: (m: import("three").Matrix3) => import("three").Vector3;
-                        applyNormalMatrix: (m: import("three").Matrix3) => import("three").Vector3;
-                        applyMatrix4: (m: import("three").Matrix4) => import("three").Vector3;
-                        applyQuaternion: (q: import("three").QuaternionLike) => import("three").Vector3;
-                        project: (camera: Camera) => import("three").Vector3;
-                        unproject: (camera: Camera) => import("three").Vector3;
-                        transformDirection: (m: import("three").Matrix4) => import("three").Vector3;
-                        divide: (v: import("three").Vector3Like) => import("three").Vector3;
-                        divideScalar: (s: number) => import("three").Vector3;
-                        min: (v: import("three").Vector3Like) => import("three").Vector3;
-                        max: (v: import("three").Vector3Like) => import("three").Vector3;
-                        clamp: (min: import("three").Vector3Like, max: import("three").Vector3Like) => import("three").Vector3;
-                        clampScalar: (min: number, max: number) => import("three").Vector3;
-                        clampLength: (min: number, max: number) => import("three").Vector3;
-                        floor: () => import("three").Vector3;
-                        ceil: () => import("three").Vector3;
-                        round: () => import("three").Vector3;
-                        roundToZero: () => import("three").Vector3;
-                        negate: () => import("three").Vector3;
-                        dot: (v: import("three").Vector3Like) => number;
+                        clone: () => import('three').Vector3;
+                        copy: (v: import('three').Vector3Like) => import('three').Vector3;
+                        add: (v: import('three').Vector3Like) => import('three').Vector3;
+                        addScalar: (s: number) => import('three').Vector3;
+                        addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                        addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
+                        sub: (a: import('three').Vector3Like) => import('three').Vector3;
+                        subScalar: (s: number) => import('three').Vector3;
+                        subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                        multiply: (v: import('three').Vector3Like) => import('three').Vector3;
+                        multiplyScalar: (s: number) => import('three').Vector3;
+                        multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                        applyEuler: (euler: import('three').Euler) => import('three').Vector3;
+                        applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
+                        applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
+                        applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
+                        applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
+                        applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
+                        project: (camera: Camera) => import('three').Vector3;
+                        unproject: (camera: Camera) => import('three').Vector3;
+                        transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
+                        divide: (v: import('three').Vector3Like) => import('three').Vector3;
+                        divideScalar: (s: number) => import('three').Vector3;
+                        min: (v: import('three').Vector3Like) => import('three').Vector3;
+                        max: (v: import('three').Vector3Like) => import('three').Vector3;
+                        clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
+                        clampScalar: (min: number, max: number) => import('three').Vector3;
+                        clampLength: (min: number, max: number) => import('three').Vector3;
+                        floor: () => import('three').Vector3;
+                        ceil: () => import('three').Vector3;
+                        round: () => import('three').Vector3;
+                        roundToZero: () => import('three').Vector3;
+                        negate: () => import('three').Vector3;
+                        dot: (v: import('three').Vector3Like) => number;
                         lengthSq: () => number;
                         length: () => number;
                         manhattanLength: () => number;
-                        normalize: () => import("three").Vector3;
-                        setLength: (l: number) => import("three").Vector3;
-                        lerp: (v: import("three").Vector3Like, alpha: number) => import("three").Vector3;
-                        lerpVectors: (v1: import("three").Vector3Like, v2: import("three").Vector3Like, alpha: number) => import("three").Vector3;
-                        cross: (a: import("three").Vector3Like) => import("three").Vector3;
-                        crossVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                        projectOnVector: (v: import("three").Vector3) => import("three").Vector3;
-                        projectOnPlane: (planeNormal: import("three").Vector3) => import("three").Vector3;
-                        reflect: (vector: import("three").Vector3Like) => import("three").Vector3;
-                        angleTo: (v: import("three").Vector3) => number;
-                        distanceTo: (v: import("three").Vector3Like) => number;
-                        distanceToSquared: (v: import("three").Vector3Like) => number;
-                        manhattanDistanceTo: (v: import("three").Vector3Like) => number;
-                        setFromSpherical: (s: import("three").Spherical) => import("three").Vector3;
-                        setFromSphericalCoords: (r: number, phi: number, theta: number) => import("three").Vector3;
-                        setFromCylindrical: (s: import("three").Cylindrical) => import("three").Vector3;
-                        setFromCylindricalCoords: (radius: number, theta: number, y: number) => import("three").Vector3;
-                        setFromMatrixPosition: (m: import("three").Matrix4) => import("three").Vector3;
-                        setFromMatrixScale: (m: import("three").Matrix4) => import("three").Vector3;
-                        setFromMatrixColumn: (matrix: import("three").Matrix4, index: number) => import("three").Vector3;
-                        setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => import("three").Vector3;
-                        setFromEuler: (e: import("three").Euler) => import("three").Vector3;
-                        setFromColor: (color: import("three").RGB) => import("three").Vector3;
-                        equals: (v: import("three").Vector3Like) => boolean;
-                        fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector3;
+                        normalize: () => import('three').Vector3;
+                        setLength: (l: number) => import('three').Vector3;
+                        lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
+                        lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
+                        cross: (a: import('three').Vector3Like) => import('three').Vector3;
+                        crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                        projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
+                        projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
+                        reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
+                        angleTo: (v: import('three').Vector3) => number;
+                        distanceTo: (v: import('three').Vector3Like) => number;
+                        distanceToSquared: (v: import('three').Vector3Like) => number;
+                        manhattanDistanceTo: (v: import('three').Vector3Like) => number;
+                        setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
+                        setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
+                        setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
+                        setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
+                        setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
+                        setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
+                        setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
+                        setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
+                        setFromEuler: (e: import('three').Euler) => import('three').Vector3;
+                        setFromColor: (color: import('three').RGB) => import('three').Vector3;
+                        equals: (v: import('three').Vector3Like) => boolean;
+                        fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector3;
                         toArray: {
-                            (array?: number[] | undefined, offset?: number | undefined): number[];
-                            (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
-                            (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
+                            (array?: number[], offset?: number): number[];
+                            (array?: import('three').Vector3Tuple, offset?: 0): import('three').Vector3Tuple;
+                            (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                         };
-                        fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => import("three").Vector3;
-                        random: () => import("three").Vector3;
-                        randomDirection: () => import("three").Vector3;
-                        [Symbol.iterator]: () => Iterator<number, any, undefined>;
+                        fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
+                        random: () => import('three').Vector3;
+                        randomDirection: () => import('three').Vector3;
+                        [Symbol.iterator]: () => Iterator<number>;
                     };
                     constant: number;
                     readonly isPlane: true;
-                    set: (normal: import("three").Vector3, constant: number) => import("three").Plane;
-                    setComponents: (x: number, y: number, z: number, w: number) => import("three").Plane;
-                    setFromNormalAndCoplanarPoint: (normal: import("three").Vector3, point: import("three").Vector3) => import("three").Plane;
-                    setFromCoplanarPoints: (a: import("three").Vector3, b: import("three").Vector3, c: import("three").Vector3) => import("three").Plane;
-                    clone: () => import("three").Plane;
-                    copy: (plane: import("three").Plane) => import("three").Plane;
-                    normalize: () => import("three").Plane;
-                    negate: () => import("three").Plane;
-                    distanceToPoint: (point: import("three").Vector3) => number;
-                    distanceToSphere: (sphere: import("three").Sphere) => number;
-                    projectPoint: (point: import("three").Vector3, target: import("three").Vector3) => import("three").Vector3;
-                    intersectLine: (line: import("three").Line3, target: import("three").Vector3) => import("three").Vector3 | null;
-                    intersectsLine: (line: import("three").Line3) => boolean;
-                    intersectsBox: (box: import("three").Box3) => boolean;
-                    intersectsSphere: (sphere: import("three").Sphere) => boolean;
-                    coplanarPoint: (target: import("three").Vector3) => import("three").Vector3;
-                    applyMatrix4: (matrix: import("three").Matrix4, optionalNormalMatrix?: import("three").Matrix3 | undefined) => import("three").Plane;
-                    translate: (offset: import("three").Vector3) => import("three").Plane;
-                    equals: (plane: import("three").Plane) => boolean;
+                    set: (normal: import('three').Vector3, constant: number) => import('three').Plane;
+                    setComponents: (x: number, y: number, z: number, w: number) => import('three').Plane;
+                    setFromNormalAndCoplanarPoint: (normal: import('three').Vector3, point: import('three').Vector3) => import('three').Plane;
+                    setFromCoplanarPoints: (a: import('three').Vector3, b: import('three').Vector3, c: import('three').Vector3) => import('three').Plane;
+                    clone: () => import('three').Plane;
+                    copy: (plane: import('three').Plane) => import('three').Plane;
+                    normalize: () => import('three').Plane;
+                    negate: () => import('three').Plane;
+                    distanceToPoint: (point: import('three').Vector3) => number;
+                    distanceToSphere: (sphere: import('three').Sphere) => number;
+                    projectPoint: (point: import('three').Vector3, target: import('three').Vector3) => import('three').Vector3;
+                    intersectLine: (line: import('three').Line3, target: import('three').Vector3) => import('three').Vector3 | null;
+                    intersectsLine: (line: import('three').Line3) => boolean;
+                    intersectsBox: (box: import('three').Box3) => boolean;
+                    intersectsSphere: (sphere: import('three').Sphere) => boolean;
+                    coplanarPoint: (target: import('three').Vector3) => import('three').Vector3;
+                    applyMatrix4: (matrix: import('three').Matrix4, optionalNormalMatrix?: import('three').Matrix3) => import('three').Plane;
+                    translate: (offset: import('three').Vector3) => import('three').Plane;
+                    equals: (plane: import('three').Plane) => boolean;
                     isIntersectionLine: (l: any) => any;
                 }[] | null;
                 clipShadows: boolean;
                 colorWrite: boolean;
-                defines: {
+                defines: undefined | {
                     [key: string]: any;
-                } | undefined;
-                depthFunc: import("three").DepthModes;
+                };
+                depthFunc: import('three').DepthModes;
                 depthTest: boolean;
                 depthWrite: boolean;
                 id: number;
                 stencilWrite: boolean;
-                stencilFunc: import("three").StencilFunc;
+                stencilFunc: import('three').StencilFunc;
                 stencilRef: number;
                 stencilWriteMask: number;
                 stencilFuncMask: number;
-                stencilFail: import("three").StencilOp;
-                stencilZFail: import("three").StencilOp;
-                stencilZPass: import("three").StencilOp;
+                stencilFail: import('three').StencilOp;
+                stencilZFail: import('three').StencilOp;
+                stencilZPass: import('three').StencilOp;
                 name: string;
                 opacity: number;
                 polygonOffset: boolean;
@@ -1298,8 +1318,8 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                 premultipliedAlpha: boolean;
                 forceSinglePass: boolean;
                 dithering: boolean;
-                side: import("three").Side;
-                shadowSide: import("three").Side | null;
+                side: import('three').Side;
+                shadowSide: import('three').Side | null;
                 toneMapped: boolean;
                 transparent: boolean;
                 type: string;
@@ -1309,37 +1329,37 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                 userData: Record<string, any>;
                 version: number;
                 alphaTest: number;
-                onBuild: (object: import("three").Object3D<import("three").Object3DEventMap>, parameters: import("three").WebGLProgramParametersWithUniforms, renderer: import("three").WebGLRenderer) => void;
-                onBeforeRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: Camera, geometry: import("three").BufferGeometry<import("three").NormalBufferAttributes>, object: import("three").Object3D<import("three").Object3DEventMap>, group: import("three").Group<import("three").Object3DEventMap>) => void;
-                onBeforeCompile: (parameters: import("three").WebGLProgramParametersWithUniforms, renderer: import("three").WebGLRenderer) => void;
+                onBeforeCompile: (parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                 customProgramCacheKey: () => string;
-                setValues: (values: import("three").MaterialParameters) => void;
+                setValues: (values: import('three').MaterialParameters) => void;
                 toJSON: (meta?: any) => any;
-                clone: () => import("three").Material;
-                copy: (material: import("three").Material) => import("three").Material;
+                clone: () => import('three').Material;
+                copy: (material: import('three').Material) => import('three').Material;
                 dispose: () => void;
                 needsUpdate: boolean;
+                onBuild: (object: import('three').Object3D, parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
+                onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry, object: import('three').Object3D, group: import('three').Group) => void;
                 addEventListener: {
-                    <T extends "dispose">(type: T, listener: import("three").EventListener<{
+                    <T extends "dispose">(type: T, listener: import('three').EventListener<{
                         dispose: {};
-                    }[T], T, import("three").Material>): void;
-                    <T_1 extends string>(type: T_1, listener: import("three").EventListener<{}, T_1, import("three").Material>): void;
+                    }[T], T, import('three').Material>): void;
+                    <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Material>): void;
                 };
                 hasEventListener: {
-                    <T_2 extends "dispose">(type: T_2, listener: import("three").EventListener<{
+                    <T extends "dispose">(type: T, listener: import('three').EventListener<{
                         dispose: {};
-                    }[T_2], T_2, import("three").Material>): boolean;
-                    <T_3 extends string>(type: T_3, listener: import("three").EventListener<{}, T_3, import("three").Material>): boolean;
+                    }[T], T, import('three').Material>): boolean;
+                    <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Material>): boolean;
                 };
                 removeEventListener: {
-                    <T_4 extends "dispose">(type: T_4, listener: import("three").EventListener<{
+                    <T extends "dispose">(type: T, listener: import('three').EventListener<{
                         dispose: {};
-                    }[T_4], T_4, import("three").Material>): void;
-                    <T_5 extends string>(type: T_5, listener: import("three").EventListener<{}, T_5, import("three").Material>): void;
+                    }[T], T, import('three').Material>): void;
+                    <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Material>): void;
                 };
-                dispatchEvent: <T_6 extends "dispose">(event: import("three").BaseEvent<T_6> & {
+                dispatchEvent: <T extends "dispose">(event: import('three').BaseEvent<T> & {
                     dispose: {};
-                }[T_6]) => void;
+                }[T]) => void;
             } | undefined;
             customDistanceMaterial?: {
                 readonly isMaterial: true;
@@ -1351,52 +1371,52 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                     r: number;
                     g: number;
                     b: number;
-                    set: (...args: [color: import("three").ColorRepresentation] | [r: number, g: number, b: number]) => import("three").Color;
-                    setFromVector3: (vector: import("three").Vector3) => import("three").Color;
-                    setScalar: (scalar: number) => import("three").Color;
-                    setHex: (hex: number, colorSpace?: import("three").ColorSpace | undefined) => import("three").Color;
-                    setRGB: (r: number, g: number, b: number, colorSpace?: import("three").ColorSpace | undefined) => import("three").Color;
-                    setHSL: (h: number, s: number, l: number, colorSpace?: import("three").ColorSpace | undefined) => import("three").Color;
-                    setStyle: (style: string, colorSpace?: import("three").ColorSpace | undefined) => import("three").Color;
-                    setColorName: (style: string, colorSpace?: import("three").ColorSpace | undefined) => import("three").Color;
-                    clone: () => import("three").Color;
-                    copy: (color: import("three").Color) => import("three").Color;
-                    copySRGBToLinear: (color: import("three").Color) => import("three").Color;
-                    copyLinearToSRGB: (color: import("three").Color) => import("three").Color;
-                    convertSRGBToLinear: () => import("three").Color;
-                    convertLinearToSRGB: () => import("three").Color;
-                    getHex: (colorSpace?: import("three").ColorSpace | undefined) => number;
-                    getHexString: (colorSpace?: import("three").ColorSpace | undefined) => string;
-                    getHSL: (target: import("three").HSL, colorSpace?: import("three").ColorSpace | undefined) => import("three").HSL;
-                    getRGB: (target: import("three").RGB, colorSpace?: import("three").ColorSpace | undefined) => import("three").RGB;
-                    getStyle: (colorSpace?: import("three").ColorSpace | undefined) => string;
-                    offsetHSL: (h: number, s: number, l: number) => import("three").Color;
-                    add: (color: import("three").Color) => import("three").Color;
-                    addColors: (color1: import("three").Color, color2: import("three").Color) => import("three").Color;
-                    addScalar: (s: number) => import("three").Color;
-                    applyMatrix3: (m: import("three").Matrix3) => import("three").Color;
-                    sub: (color: import("three").Color) => import("three").Color;
-                    multiply: (color: import("three").Color) => import("three").Color;
-                    multiplyScalar: (s: number) => import("three").Color;
-                    lerp: (color: import("three").Color, alpha: number) => import("three").Color;
-                    lerpColors: (color1: import("three").Color, color2: import("three").Color, alpha: number) => import("three").Color;
-                    lerpHSL: (color: import("three").Color, alpha: number) => import("three").Color;
-                    equals: (color: import("three").Color) => boolean;
-                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Color;
+                    set: (...args: [color: import('three').ColorRepresentation] | [r: number, g: number, b: number]) => import('three').Color;
+                    setFromVector3: (vector: import('three').Vector3) => import('three').Color;
+                    setScalar: (scalar: number) => import('three').Color;
+                    setHex: (hex: number, colorSpace?: import('three').ColorSpace) => import('three').Color;
+                    setRGB: (r: number, g: number, b: number, colorSpace?: import('three').ColorSpace) => import('three').Color;
+                    setHSL: (h: number, s: number, l: number, colorSpace?: import('three').ColorSpace) => import('three').Color;
+                    setStyle: (style: string, colorSpace?: import('three').ColorSpace) => import('three').Color;
+                    setColorName: (style: string, colorSpace?: import('three').ColorSpace) => import('three').Color;
+                    clone: () => import('three').Color;
+                    copy: (color: import('three').Color) => import('three').Color;
+                    copySRGBToLinear: (color: import('three').Color) => import('three').Color;
+                    copyLinearToSRGB: (color: import('three').Color) => import('three').Color;
+                    convertSRGBToLinear: () => import('three').Color;
+                    convertLinearToSRGB: () => import('three').Color;
+                    getHex: (colorSpace?: import('three').ColorSpace) => number;
+                    getHexString: (colorSpace?: import('three').ColorSpace) => string;
+                    getHSL: (target: import('three').HSL, colorSpace?: import('three').ColorSpace) => import('three').HSL;
+                    getRGB: (target: import('three').RGB, colorSpace?: import('three').ColorSpace) => import('three').RGB;
+                    getStyle: (colorSpace?: import('three').ColorSpace) => string;
+                    offsetHSL: (h: number, s: number, l: number) => import('three').Color;
+                    add: (color: import('three').Color) => import('three').Color;
+                    addColors: (color1: import('three').Color, color2: import('three').Color) => import('three').Color;
+                    addScalar: (s: number) => import('three').Color;
+                    applyMatrix3: (m: import('three').Matrix3) => import('three').Color;
+                    sub: (color: import('three').Color) => import('three').Color;
+                    multiply: (color: import('three').Color) => import('three').Color;
+                    multiplyScalar: (s: number) => import('three').Color;
+                    lerp: (color: import('three').Color, alpha: number) => import('three').Color;
+                    lerpColors: (color1: import('three').Color, color2: import('three').Color, alpha: number) => import('three').Color;
+                    lerpHSL: (color: import('three').Color, alpha: number) => import('three').Color;
+                    equals: (color: import('three').Color) => boolean;
+                    fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Color;
                     toArray: {
-                        (array?: number[] | undefined, offset?: number | undefined): number[];
-                        (xyz: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
+                        (array?: number[], offset?: number): number[];
+                        (xyz: ArrayLike<number>, offset?: number): ArrayLike<number>;
                     };
                     toJSON: () => number;
-                    fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => import("three").Color;
-                    [Symbol.iterator]: () => Generator<number, void, unknown>;
+                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Color;
+                    [Symbol.iterator]: () => Generator<number, void>;
                 };
-                blendDst: import("three").BlendingDstFactor;
+                blendDst: import('three').BlendingDstFactor;
                 blendDstAlpha: number | null;
-                blendEquation: import("three").BlendingEquation;
+                blendEquation: import('three').BlendingEquation;
                 blendEquationAlpha: number | null;
-                blending: import("three").Blending;
-                blendSrc: 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207 | 208 | 209 | 211 | 212 | 213 | 214 | 210;
+                blending: import('three').Blending;
+                blendSrc: import('three').BlendingSrcFactor | import('three').BlendingDstFactor;
                 blendSrcAlpha: number | null;
                 clipIntersection: boolean;
                 clippingPlanes: {
@@ -1405,125 +1425,125 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                         y: number;
                         z: number;
                         readonly isVector3: true;
-                        set: (x: number, y: number, z: number) => import("three").Vector3;
-                        setScalar: (scalar: number) => import("three").Vector3;
-                        setX: (x: number) => import("three").Vector3;
-                        setY: (y: number) => import("three").Vector3;
-                        setZ: (z: number) => import("three").Vector3;
-                        setComponent: (index: number, value: number) => import("three").Vector3;
+                        set: (x: number, y: number, z: number) => import('three').Vector3;
+                        setScalar: (scalar: number) => import('three').Vector3;
+                        setX: (x: number) => import('three').Vector3;
+                        setY: (y: number) => import('three').Vector3;
+                        setZ: (z: number) => import('three').Vector3;
+                        setComponent: (index: number, value: number) => import('three').Vector3;
                         getComponent: (index: number) => number;
-                        clone: () => import("three").Vector3;
-                        copy: (v: import("three").Vector3Like) => import("three").Vector3;
-                        add: (v: import("three").Vector3Like) => import("three").Vector3;
-                        addScalar: (s: number) => import("three").Vector3;
-                        addVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                        addScaledVector: (v: import("three").Vector3, s: number) => import("three").Vector3;
-                        sub: (a: import("three").Vector3Like) => import("three").Vector3;
-                        subScalar: (s: number) => import("three").Vector3;
-                        subVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                        multiply: (v: import("three").Vector3Like) => import("three").Vector3;
-                        multiplyScalar: (s: number) => import("three").Vector3;
-                        multiplyVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                        applyEuler: (euler: import("three").Euler) => import("three").Vector3;
-                        applyAxisAngle: (axis: import("three").Vector3, angle: number) => import("three").Vector3;
-                        applyMatrix3: (m: import("three").Matrix3) => import("three").Vector3;
-                        applyNormalMatrix: (m: import("three").Matrix3) => import("three").Vector3;
-                        applyMatrix4: (m: import("three").Matrix4) => import("three").Vector3;
-                        applyQuaternion: (q: import("three").QuaternionLike) => import("three").Vector3;
-                        project: (camera: Camera) => import("three").Vector3;
-                        unproject: (camera: Camera) => import("three").Vector3;
-                        transformDirection: (m: import("three").Matrix4) => import("three").Vector3;
-                        divide: (v: import("three").Vector3Like) => import("three").Vector3;
-                        divideScalar: (s: number) => import("three").Vector3;
-                        min: (v: import("three").Vector3Like) => import("three").Vector3;
-                        max: (v: import("three").Vector3Like) => import("three").Vector3;
-                        clamp: (min: import("three").Vector3Like, max: import("three").Vector3Like) => import("three").Vector3;
-                        clampScalar: (min: number, max: number) => import("three").Vector3;
-                        clampLength: (min: number, max: number) => import("three").Vector3;
-                        floor: () => import("three").Vector3;
-                        ceil: () => import("three").Vector3;
-                        round: () => import("three").Vector3;
-                        roundToZero: () => import("three").Vector3;
-                        negate: () => import("three").Vector3;
-                        dot: (v: import("three").Vector3Like) => number;
+                        clone: () => import('three').Vector3;
+                        copy: (v: import('three').Vector3Like) => import('three').Vector3;
+                        add: (v: import('three').Vector3Like) => import('three').Vector3;
+                        addScalar: (s: number) => import('three').Vector3;
+                        addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                        addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
+                        sub: (a: import('three').Vector3Like) => import('three').Vector3;
+                        subScalar: (s: number) => import('three').Vector3;
+                        subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                        multiply: (v: import('three').Vector3Like) => import('three').Vector3;
+                        multiplyScalar: (s: number) => import('three').Vector3;
+                        multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                        applyEuler: (euler: import('three').Euler) => import('three').Vector3;
+                        applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
+                        applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
+                        applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
+                        applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
+                        applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
+                        project: (camera: Camera) => import('three').Vector3;
+                        unproject: (camera: Camera) => import('three').Vector3;
+                        transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
+                        divide: (v: import('three').Vector3Like) => import('three').Vector3;
+                        divideScalar: (s: number) => import('three').Vector3;
+                        min: (v: import('three').Vector3Like) => import('three').Vector3;
+                        max: (v: import('three').Vector3Like) => import('three').Vector3;
+                        clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
+                        clampScalar: (min: number, max: number) => import('three').Vector3;
+                        clampLength: (min: number, max: number) => import('three').Vector3;
+                        floor: () => import('three').Vector3;
+                        ceil: () => import('three').Vector3;
+                        round: () => import('three').Vector3;
+                        roundToZero: () => import('three').Vector3;
+                        negate: () => import('three').Vector3;
+                        dot: (v: import('three').Vector3Like) => number;
                         lengthSq: () => number;
                         length: () => number;
                         manhattanLength: () => number;
-                        normalize: () => import("three").Vector3;
-                        setLength: (l: number) => import("three").Vector3;
-                        lerp: (v: import("three").Vector3Like, alpha: number) => import("three").Vector3;
-                        lerpVectors: (v1: import("three").Vector3Like, v2: import("three").Vector3Like, alpha: number) => import("three").Vector3;
-                        cross: (a: import("three").Vector3Like) => import("three").Vector3;
-                        crossVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                        projectOnVector: (v: import("three").Vector3) => import("three").Vector3;
-                        projectOnPlane: (planeNormal: import("three").Vector3) => import("three").Vector3;
-                        reflect: (vector: import("three").Vector3Like) => import("three").Vector3;
-                        angleTo: (v: import("three").Vector3) => number;
-                        distanceTo: (v: import("three").Vector3Like) => number;
-                        distanceToSquared: (v: import("three").Vector3Like) => number;
-                        manhattanDistanceTo: (v: import("three").Vector3Like) => number;
-                        setFromSpherical: (s: import("three").Spherical) => import("three").Vector3;
-                        setFromSphericalCoords: (r: number, phi: number, theta: number) => import("three").Vector3;
-                        setFromCylindrical: (s: import("three").Cylindrical) => import("three").Vector3;
-                        setFromCylindricalCoords: (radius: number, theta: number, y: number) => import("three").Vector3;
-                        setFromMatrixPosition: (m: import("three").Matrix4) => import("three").Vector3;
-                        setFromMatrixScale: (m: import("three").Matrix4) => import("three").Vector3;
-                        setFromMatrixColumn: (matrix: import("three").Matrix4, index: number) => import("three").Vector3;
-                        setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => import("three").Vector3;
-                        setFromEuler: (e: import("three").Euler) => import("three").Vector3;
-                        setFromColor: (color: import("three").RGB) => import("three").Vector3;
-                        equals: (v: import("three").Vector3Like) => boolean;
-                        fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector3;
+                        normalize: () => import('three').Vector3;
+                        setLength: (l: number) => import('three').Vector3;
+                        lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
+                        lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
+                        cross: (a: import('three').Vector3Like) => import('three').Vector3;
+                        crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                        projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
+                        projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
+                        reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
+                        angleTo: (v: import('three').Vector3) => number;
+                        distanceTo: (v: import('three').Vector3Like) => number;
+                        distanceToSquared: (v: import('three').Vector3Like) => number;
+                        manhattanDistanceTo: (v: import('three').Vector3Like) => number;
+                        setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
+                        setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
+                        setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
+                        setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
+                        setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
+                        setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
+                        setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
+                        setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
+                        setFromEuler: (e: import('three').Euler) => import('three').Vector3;
+                        setFromColor: (color: import('three').RGB) => import('three').Vector3;
+                        equals: (v: import('three').Vector3Like) => boolean;
+                        fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector3;
                         toArray: {
-                            (array?: number[] | undefined, offset?: number | undefined): number[];
-                            (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
-                            (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
+                            (array?: number[], offset?: number): number[];
+                            (array?: import('three').Vector3Tuple, offset?: 0): import('three').Vector3Tuple;
+                            (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                         };
-                        fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => import("three").Vector3;
-                        random: () => import("three").Vector3;
-                        randomDirection: () => import("three").Vector3;
-                        [Symbol.iterator]: () => Iterator<number, any, undefined>;
+                        fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
+                        random: () => import('three').Vector3;
+                        randomDirection: () => import('three').Vector3;
+                        [Symbol.iterator]: () => Iterator<number>;
                     };
                     constant: number;
                     readonly isPlane: true;
-                    set: (normal: import("three").Vector3, constant: number) => import("three").Plane;
-                    setComponents: (x: number, y: number, z: number, w: number) => import("three").Plane;
-                    setFromNormalAndCoplanarPoint: (normal: import("three").Vector3, point: import("three").Vector3) => import("three").Plane;
-                    setFromCoplanarPoints: (a: import("three").Vector3, b: import("three").Vector3, c: import("three").Vector3) => import("three").Plane;
-                    clone: () => import("three").Plane;
-                    copy: (plane: import("three").Plane) => import("three").Plane;
-                    normalize: () => import("three").Plane;
-                    negate: () => import("three").Plane;
-                    distanceToPoint: (point: import("three").Vector3) => number;
-                    distanceToSphere: (sphere: import("three").Sphere) => number;
-                    projectPoint: (point: import("three").Vector3, target: import("three").Vector3) => import("three").Vector3;
-                    intersectLine: (line: import("three").Line3, target: import("three").Vector3) => import("three").Vector3 | null;
-                    intersectsLine: (line: import("three").Line3) => boolean;
-                    intersectsBox: (box: import("three").Box3) => boolean;
-                    intersectsSphere: (sphere: import("three").Sphere) => boolean;
-                    coplanarPoint: (target: import("three").Vector3) => import("three").Vector3;
-                    applyMatrix4: (matrix: import("three").Matrix4, optionalNormalMatrix?: import("three").Matrix3 | undefined) => import("three").Plane;
-                    translate: (offset: import("three").Vector3) => import("three").Plane;
-                    equals: (plane: import("three").Plane) => boolean;
+                    set: (normal: import('three').Vector3, constant: number) => import('three').Plane;
+                    setComponents: (x: number, y: number, z: number, w: number) => import('three').Plane;
+                    setFromNormalAndCoplanarPoint: (normal: import('three').Vector3, point: import('three').Vector3) => import('three').Plane;
+                    setFromCoplanarPoints: (a: import('three').Vector3, b: import('three').Vector3, c: import('three').Vector3) => import('three').Plane;
+                    clone: () => import('three').Plane;
+                    copy: (plane: import('three').Plane) => import('three').Plane;
+                    normalize: () => import('three').Plane;
+                    negate: () => import('three').Plane;
+                    distanceToPoint: (point: import('three').Vector3) => number;
+                    distanceToSphere: (sphere: import('three').Sphere) => number;
+                    projectPoint: (point: import('three').Vector3, target: import('three').Vector3) => import('three').Vector3;
+                    intersectLine: (line: import('three').Line3, target: import('three').Vector3) => import('three').Vector3 | null;
+                    intersectsLine: (line: import('three').Line3) => boolean;
+                    intersectsBox: (box: import('three').Box3) => boolean;
+                    intersectsSphere: (sphere: import('three').Sphere) => boolean;
+                    coplanarPoint: (target: import('three').Vector3) => import('three').Vector3;
+                    applyMatrix4: (matrix: import('three').Matrix4, optionalNormalMatrix?: import('three').Matrix3) => import('three').Plane;
+                    translate: (offset: import('three').Vector3) => import('three').Plane;
+                    equals: (plane: import('three').Plane) => boolean;
                     isIntersectionLine: (l: any) => any;
                 }[] | null;
                 clipShadows: boolean;
                 colorWrite: boolean;
-                defines: {
+                defines: undefined | {
                     [key: string]: any;
-                } | undefined;
-                depthFunc: import("three").DepthModes;
+                };
+                depthFunc: import('three').DepthModes;
                 depthTest: boolean;
                 depthWrite: boolean;
                 id: number;
                 stencilWrite: boolean;
-                stencilFunc: import("three").StencilFunc;
+                stencilFunc: import('three').StencilFunc;
                 stencilRef: number;
                 stencilWriteMask: number;
                 stencilFuncMask: number;
-                stencilFail: import("three").StencilOp;
-                stencilZFail: import("three").StencilOp;
-                stencilZPass: import("three").StencilOp;
+                stencilFail: import('three').StencilOp;
+                stencilZFail: import('three').StencilOp;
+                stencilZPass: import('three').StencilOp;
                 name: string;
                 opacity: number;
                 polygonOffset: boolean;
@@ -1533,8 +1553,8 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                 premultipliedAlpha: boolean;
                 forceSinglePass: boolean;
                 dithering: boolean;
-                side: import("three").Side;
-                shadowSide: import("three").Side | null;
+                side: import('three').Side;
+                shadowSide: import('three').Side | null;
                 toneMapped: boolean;
                 transparent: boolean;
                 type: string;
@@ -1544,111 +1564,111 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                 userData: Record<string, any>;
                 version: number;
                 alphaTest: number;
-                onBuild: (object: import("three").Object3D<import("three").Object3DEventMap>, parameters: import("three").WebGLProgramParametersWithUniforms, renderer: import("three").WebGLRenderer) => void;
-                onBeforeRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: Camera, geometry: import("three").BufferGeometry<import("three").NormalBufferAttributes>, object: import("three").Object3D<import("three").Object3DEventMap>, group: import("three").Group<import("three").Object3DEventMap>) => void;
-                onBeforeCompile: (parameters: import("three").WebGLProgramParametersWithUniforms, renderer: import("three").WebGLRenderer) => void;
+                onBeforeCompile: (parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                 customProgramCacheKey: () => string;
-                setValues: (values: import("three").MaterialParameters) => void;
+                setValues: (values: import('three').MaterialParameters) => void;
                 toJSON: (meta?: any) => any;
-                clone: () => import("three").Material;
-                copy: (material: import("three").Material) => import("three").Material;
+                clone: () => import('three').Material;
+                copy: (material: import('three').Material) => import('three').Material;
                 dispose: () => void;
                 needsUpdate: boolean;
+                onBuild: (object: import('three').Object3D, parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
+                onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry, object: import('three').Object3D, group: import('three').Group) => void;
                 addEventListener: {
-                    <T extends "dispose">(type: T, listener: import("three").EventListener<{
+                    <T extends "dispose">(type: T, listener: import('three').EventListener<{
                         dispose: {};
-                    }[T], T, import("three").Material>): void;
-                    <T_1 extends string>(type: T_1, listener: import("three").EventListener<{}, T_1, import("three").Material>): void;
+                    }[T], T, import('three').Material>): void;
+                    <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Material>): void;
                 };
                 hasEventListener: {
-                    <T_2 extends "dispose">(type: T_2, listener: import("three").EventListener<{
+                    <T extends "dispose">(type: T, listener: import('three').EventListener<{
                         dispose: {};
-                    }[T_2], T_2, import("three").Material>): boolean;
-                    <T_3 extends string>(type: T_3, listener: import("three").EventListener<{}, T_3, import("three").Material>): boolean;
+                    }[T], T, import('three').Material>): boolean;
+                    <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Material>): boolean;
                 };
                 removeEventListener: {
-                    <T_4 extends "dispose">(type: T_4, listener: import("three").EventListener<{
+                    <T extends "dispose">(type: T, listener: import('three').EventListener<{
                         dispose: {};
-                    }[T_4], T_4, import("three").Material>): void;
-                    <T_5 extends string>(type: T_5, listener: import("three").EventListener<{}, T_5, import("three").Material>): void;
+                    }[T], T, import('three').Material>): void;
+                    <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Material>): void;
                 };
-                dispatchEvent: <T_6 extends "dispose">(event: import("three").BaseEvent<T_6> & {
+                dispatchEvent: <T extends "dispose">(event: import('three').BaseEvent<T> & {
                     dispose: {};
-                }[T_6]) => void;
+                }[T]) => void;
             } | undefined;
-            onBeforeShadow: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, shadowCamera: Camera, geometry: import("three").BufferGeometry<import("three").NormalBufferAttributes>, depthMaterial: import("three").Material, group: import("three").Group<import("three").Object3DEventMap>) => void;
-            onAfterShadow: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, shadowCamera: Camera, geometry: import("three").BufferGeometry<import("three").NormalBufferAttributes>, depthMaterial: import("three").Material, group: import("three").Group<import("three").Object3DEventMap>) => void;
-            onBeforeRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: Camera, geometry: import("three").BufferGeometry<import("three").NormalBufferAttributes>, material: import("three").Material, group: import("three").Group<import("three").Object3DEventMap>) => void;
-            onAfterRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: Camera, geometry: import("three").BufferGeometry<import("three").NormalBufferAttributes>, material: import("three").Material, group: import("three").Group<import("three").Object3DEventMap>) => void;
-            applyMatrix4: (matrix: import("three").Matrix4) => void;
-            applyQuaternion: (quaternion: import("three").Quaternion) => import("three").Object3D<import("three").Object3DEventMap>;
-            setRotationFromAxisAngle: (axis: import("three").Vector3, angle: number) => void;
-            setRotationFromEuler: (euler: import("three").Euler) => void;
-            setRotationFromMatrix: (m: import("three").Matrix4) => void;
-            setRotationFromQuaternion: (q: import("three").Quaternion) => void;
-            rotateOnAxis: (axis: import("three").Vector3, angle: number) => import("three").Object3D<import("three").Object3DEventMap>;
-            rotateOnWorldAxis: (axis: import("three").Vector3, angle: number) => import("three").Object3D<import("three").Object3DEventMap>;
-            rotateX: (angle: number) => import("three").Object3D<import("three").Object3DEventMap>;
-            rotateY: (angle: number) => import("three").Object3D<import("three").Object3DEventMap>;
-            rotateZ: (angle: number) => import("three").Object3D<import("three").Object3DEventMap>;
-            translateOnAxis: (axis: import("three").Vector3, distance: number) => import("three").Object3D<import("three").Object3DEventMap>;
-            translateX: (distance: number) => import("three").Object3D<import("three").Object3DEventMap>;
-            translateY: (distance: number) => import("three").Object3D<import("three").Object3DEventMap>;
-            translateZ: (distance: number) => import("three").Object3D<import("three").Object3DEventMap>;
-            localToWorld: (vector: import("three").Vector3) => import("three").Vector3;
-            worldToLocal: (vector: import("three").Vector3) => import("three").Vector3;
+            onBeforeShadow: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, shadowCamera: Camera, geometry: import('three').BufferGeometry, depthMaterial: import('three').Material, group: import('three').Group) => void;
+            onAfterShadow: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, shadowCamera: Camera, geometry: import('three').BufferGeometry, depthMaterial: import('three').Material, group: import('three').Group) => void;
+            onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry, material: import('three').Material, group: import('three').Group) => void;
+            onAfterRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry, material: import('three').Material, group: import('three').Group) => void;
+            applyMatrix4: (matrix: import('three').Matrix4) => void;
+            applyQuaternion: (quaternion: import('three').Quaternion) => import('three').Object3D<import('three').Object3DEventMap>;
+            setRotationFromAxisAngle: (axis: import('three').Vector3, angle: number) => void;
+            setRotationFromEuler: (euler: import('three').Euler) => void;
+            setRotationFromMatrix: (m: import('three').Matrix4) => void;
+            setRotationFromQuaternion: (q: import('three').Quaternion) => void;
+            rotateOnAxis: (axis: import('three').Vector3, angle: number) => import('three').Object3D<import('three').Object3DEventMap>;
+            rotateOnWorldAxis: (axis: import('three').Vector3, angle: number) => import('three').Object3D<import('three').Object3DEventMap>;
+            rotateX: (angle: number) => import('three').Object3D<import('three').Object3DEventMap>;
+            rotateY: (angle: number) => import('three').Object3D<import('three').Object3DEventMap>;
+            rotateZ: (angle: number) => import('three').Object3D<import('three').Object3DEventMap>;
+            translateOnAxis: (axis: import('three').Vector3, distance: number) => import('three').Object3D<import('three').Object3DEventMap>;
+            translateX: (distance: number) => import('three').Object3D<import('three').Object3DEventMap>;
+            translateY: (distance: number) => import('three').Object3D<import('three').Object3DEventMap>;
+            translateZ: (distance: number) => import('three').Object3D<import('three').Object3DEventMap>;
+            localToWorld: (vector: import('three').Vector3) => import('three').Vector3;
+            worldToLocal: (vector: import('three').Vector3) => import('three').Vector3;
             lookAt: {
-                (vector: import("three").Vector3): void;
+                (vector: import('three').Vector3): void;
                 (x: number, y: number, z: number): void;
             };
-            add: (...object: import("three").Object3D<import("three").Object3DEventMap>[]) => import("three").Object3D<import("three").Object3DEventMap>;
-            remove: (...object: import("three").Object3D<import("three").Object3DEventMap>[]) => import("three").Object3D<import("three").Object3DEventMap>;
-            removeFromParent: () => import("three").Object3D<import("three").Object3DEventMap>;
-            clear: () => import("three").Object3D<import("three").Object3DEventMap>;
-            attach: (object: import("three").Object3D<import("three").Object3DEventMap>) => import("three").Object3D<import("three").Object3DEventMap>;
-            getObjectById: (id: number) => import("three").Object3D<import("three").Object3DEventMap> | undefined;
-            getObjectByName: (name: string) => import("three").Object3D<import("three").Object3DEventMap> | undefined;
-            getObjectByProperty: (name: string, value: any) => import("three").Object3D<import("three").Object3DEventMap> | undefined;
-            getObjectsByProperty: (name: string, value: any, optionalTarget?: import("three").Object3D<import("three").Object3DEventMap>[] | undefined) => import("three").Object3D<import("three").Object3DEventMap>[];
-            getWorldPosition: (target: import("three").Vector3) => import("three").Vector3;
-            getWorldQuaternion: (target: import("three").Quaternion) => import("three").Quaternion;
-            getWorldScale: (target: import("three").Vector3) => import("three").Vector3;
-            getWorldDirection: (target: import("three").Vector3) => import("three").Vector3;
-            raycast: (raycaster: import("three").Raycaster, intersects: import("three").Intersection<import("three").Object3D<import("three").Object3DEventMap>>[]) => void;
-            traverse: (callback: (object: import("three").Object3D<import("three").Object3DEventMap>) => any) => void;
-            traverseVisible: (callback: (object: import("three").Object3D<import("three").Object3DEventMap>) => any) => void;
-            traverseAncestors: (callback: (object: import("three").Object3D<import("three").Object3DEventMap>) => any) => void;
+            add: (...object: import('three').Object3D[]) => import('three').Object3D<import('three').Object3DEventMap>;
+            remove: (...object: import('three').Object3D[]) => import('three').Object3D<import('three').Object3DEventMap>;
+            removeFromParent: () => import('three').Object3D<import('three').Object3DEventMap>;
+            clear: () => import('three').Object3D<import('three').Object3DEventMap>;
+            attach: (object: import('three').Object3D) => import('three').Object3D<import('three').Object3DEventMap>;
+            getObjectById: (id: number) => import('three').Object3D | undefined;
+            getObjectByName: (name: string) => import('three').Object3D | undefined;
+            getObjectByProperty: (name: string, value: any) => import('three').Object3D | undefined;
+            getObjectsByProperty: (name: string, value: any, optionalTarget?: import('three').Object3D[]) => import('three').Object3D[];
+            getWorldPosition: (target: import('three').Vector3) => import('three').Vector3;
+            getWorldQuaternion: (target: import('three').Quaternion) => import('three').Quaternion;
+            getWorldScale: (target: import('three').Vector3) => import('three').Vector3;
+            getWorldDirection: (target: import('three').Vector3) => import('three').Vector3;
+            raycast: (raycaster: import('three').Raycaster, intersects: import('three').Intersection[]) => void;
+            traverse: (callback: (object: import('three').Object3D) => any) => void;
+            traverseVisible: (callback: (object: import('three').Object3D) => any) => void;
+            traverseAncestors: (callback: (object: import('three').Object3D) => any) => void;
             updateMatrix: () => void;
-            updateMatrixWorld: (force?: boolean | undefined) => void;
+            updateMatrixWorld: (force?: boolean) => void;
             updateWorldMatrix: (updateParents: boolean, updateChildren: boolean) => void;
             toJSON: (meta?: {
                 geometries: any;
                 materials: any;
                 textures: any;
                 images: any;
-            } | undefined) => any;
-            clone: (recursive?: boolean | undefined) => import("three").Object3D<import("three").Object3DEventMap>;
-            copy: (source: import("three").Object3D<import("three").Object3DEventMap>, recursive?: boolean | undefined) => import("three").Object3D<import("three").Object3DEventMap>;
+            }) => any;
+            clone: (recursive?: boolean) => import('three').Object3D<import('three').Object3DEventMap>;
+            copy: (object: import('three').Object3D, recursive?: boolean) => import('three').Object3D<import('three').Object3DEventMap>;
             addEventListener: {
-                <T_7 extends keyof import("three").Object3DEventMap>(type: T_7, listener: import("three").EventListener<import("three").Object3DEventMap[T_7], T_7, import("three").Object3D<import("three").Object3DEventMap>>): void;
-                <T_8 extends string>(type: T_8, listener: import("three").EventListener<{}, T_8, import("three").Object3D<import("three").Object3DEventMap>>): void;
+                <T extends keyof import('three').Object3DEventMap>(type: T, listener: import('three').EventListener<import('three').Object3DEventMap[T], T, import('three').Object3D<import('three').Object3DEventMap>>): void;
+                <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Object3D<import('three').Object3DEventMap>>): void;
             };
             hasEventListener: {
-                <T_9 extends keyof import("three").Object3DEventMap>(type: T_9, listener: import("three").EventListener<import("three").Object3DEventMap[T_9], T_9, import("three").Object3D<import("three").Object3DEventMap>>): boolean;
-                <T_10 extends string>(type: T_10, listener: import("three").EventListener<{}, T_10, import("three").Object3D<import("three").Object3DEventMap>>): boolean;
+                <T extends keyof import('three').Object3DEventMap>(type: T, listener: import('three').EventListener<import('three').Object3DEventMap[T], T, import('three').Object3D<import('three').Object3DEventMap>>): boolean;
+                <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Object3D<import('three').Object3DEventMap>>): boolean;
             };
             removeEventListener: {
-                <T_11 extends keyof import("three").Object3DEventMap>(type: T_11, listener: import("three").EventListener<import("three").Object3DEventMap[T_11], T_11, import("three").Object3D<import("three").Object3DEventMap>>): void;
-                <T_12 extends string>(type: T_12, listener: import("three").EventListener<{}, T_12, import("three").Object3D<import("three").Object3DEventMap>>): void;
+                <T extends keyof import('three').Object3DEventMap>(type: T, listener: import('three').EventListener<import('three').Object3DEventMap[T], T, import('three').Object3D<import('three').Object3DEventMap>>): void;
+                <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Object3D<import('three').Object3DEventMap>>): void;
             };
-            dispatchEvent: <T_13 extends keyof import("three").Object3DEventMap>(event: import("three").BaseEvent<T_13> & import("three").Object3DEventMap[T_13]) => void;
+            dispatchEvent: <T extends keyof import('three').Object3DEventMap>(event: import('three').BaseEvent<T> & import('three').Object3DEventMap[T]) => void;
         } | null;
         children: {
             readonly isObject3D: true;
             readonly id: number;
             uuid: string;
             name: string;
-            readonly type: string;
+            readonly type: string | "Object3D";
             parent: any | null;
             children: any[];
             up: {
@@ -1656,188 +1676,188 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                 y: number;
                 z: number;
                 readonly isVector3: true;
-                set: (x: number, y: number, z: number) => import("three").Vector3;
-                setScalar: (scalar: number) => import("three").Vector3;
-                setX: (x: number) => import("three").Vector3;
-                setY: (y: number) => import("three").Vector3;
-                setZ: (z: number) => import("three").Vector3;
-                setComponent: (index: number, value: number) => import("three").Vector3;
+                set: (x: number, y: number, z: number) => import('three').Vector3;
+                setScalar: (scalar: number) => import('three').Vector3;
+                setX: (x: number) => import('three').Vector3;
+                setY: (y: number) => import('three').Vector3;
+                setZ: (z: number) => import('three').Vector3;
+                setComponent: (index: number, value: number) => import('three').Vector3;
                 getComponent: (index: number) => number;
-                clone: () => import("three").Vector3;
-                copy: (v: import("three").Vector3Like) => import("three").Vector3;
-                add: (v: import("three").Vector3Like) => import("three").Vector3;
-                addScalar: (s: number) => import("three").Vector3;
-                addVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                addScaledVector: (v: import("three").Vector3, s: number) => import("three").Vector3;
-                sub: (a: import("three").Vector3Like) => import("three").Vector3;
-                subScalar: (s: number) => import("three").Vector3;
-                subVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                multiply: (v: import("three").Vector3Like) => import("three").Vector3;
-                multiplyScalar: (s: number) => import("three").Vector3;
-                multiplyVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                applyEuler: (euler: import("three").Euler) => import("three").Vector3;
-                applyAxisAngle: (axis: import("three").Vector3, angle: number) => import("three").Vector3;
-                applyMatrix3: (m: import("three").Matrix3) => import("three").Vector3;
-                applyNormalMatrix: (m: import("three").Matrix3) => import("three").Vector3;
-                applyMatrix4: (m: import("three").Matrix4) => import("three").Vector3;
-                applyQuaternion: (q: import("three").QuaternionLike) => import("three").Vector3;
-                project: (camera: Camera) => import("three").Vector3;
-                unproject: (camera: Camera) => import("three").Vector3;
-                transformDirection: (m: import("three").Matrix4) => import("three").Vector3;
-                divide: (v: import("three").Vector3Like) => import("three").Vector3;
-                divideScalar: (s: number) => import("three").Vector3;
-                min: (v: import("three").Vector3Like) => import("three").Vector3;
-                max: (v: import("three").Vector3Like) => import("three").Vector3;
-                clamp: (min: import("three").Vector3Like, max: import("three").Vector3Like) => import("three").Vector3;
-                clampScalar: (min: number, max: number) => import("three").Vector3;
-                clampLength: (min: number, max: number) => import("three").Vector3;
-                floor: () => import("three").Vector3;
-                ceil: () => import("three").Vector3;
-                round: () => import("three").Vector3;
-                roundToZero: () => import("three").Vector3;
-                negate: () => import("three").Vector3;
-                dot: (v: import("three").Vector3Like) => number;
+                clone: () => import('three').Vector3;
+                copy: (v: import('three').Vector3Like) => import('three').Vector3;
+                add: (v: import('three').Vector3Like) => import('three').Vector3;
+                addScalar: (s: number) => import('three').Vector3;
+                addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
+                sub: (a: import('three').Vector3Like) => import('three').Vector3;
+                subScalar: (s: number) => import('three').Vector3;
+                subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                multiply: (v: import('three').Vector3Like) => import('three').Vector3;
+                multiplyScalar: (s: number) => import('three').Vector3;
+                multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                applyEuler: (euler: import('three').Euler) => import('three').Vector3;
+                applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
+                applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
+                applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
+                applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
+                applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
+                project: (camera: Camera) => import('three').Vector3;
+                unproject: (camera: Camera) => import('three').Vector3;
+                transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
+                divide: (v: import('three').Vector3Like) => import('three').Vector3;
+                divideScalar: (s: number) => import('three').Vector3;
+                min: (v: import('three').Vector3Like) => import('three').Vector3;
+                max: (v: import('three').Vector3Like) => import('three').Vector3;
+                clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
+                clampScalar: (min: number, max: number) => import('three').Vector3;
+                clampLength: (min: number, max: number) => import('three').Vector3;
+                floor: () => import('three').Vector3;
+                ceil: () => import('three').Vector3;
+                round: () => import('three').Vector3;
+                roundToZero: () => import('three').Vector3;
+                negate: () => import('three').Vector3;
+                dot: (v: import('three').Vector3Like) => number;
                 lengthSq: () => number;
                 length: () => number;
                 manhattanLength: () => number;
-                normalize: () => import("three").Vector3;
-                setLength: (l: number) => import("three").Vector3;
-                lerp: (v: import("three").Vector3Like, alpha: number) => import("three").Vector3;
-                lerpVectors: (v1: import("three").Vector3Like, v2: import("three").Vector3Like, alpha: number) => import("three").Vector3;
-                cross: (a: import("three").Vector3Like) => import("three").Vector3;
-                crossVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                projectOnVector: (v: import("three").Vector3) => import("three").Vector3;
-                projectOnPlane: (planeNormal: import("three").Vector3) => import("three").Vector3;
-                reflect: (vector: import("three").Vector3Like) => import("three").Vector3;
-                angleTo: (v: import("three").Vector3) => number;
-                distanceTo: (v: import("three").Vector3Like) => number;
-                distanceToSquared: (v: import("three").Vector3Like) => number;
-                manhattanDistanceTo: (v: import("three").Vector3Like) => number;
-                setFromSpherical: (s: import("three").Spherical) => import("three").Vector3;
-                setFromSphericalCoords: (r: number, phi: number, theta: number) => import("three").Vector3;
-                setFromCylindrical: (s: import("three").Cylindrical) => import("three").Vector3;
-                setFromCylindricalCoords: (radius: number, theta: number, y: number) => import("three").Vector3;
-                setFromMatrixPosition: (m: import("three").Matrix4) => import("three").Vector3;
-                setFromMatrixScale: (m: import("three").Matrix4) => import("three").Vector3;
-                setFromMatrixColumn: (matrix: import("three").Matrix4, index: number) => import("three").Vector3;
-                setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => import("three").Vector3;
-                setFromEuler: (e: import("three").Euler) => import("three").Vector3;
-                setFromColor: (color: import("three").RGB) => import("three").Vector3;
-                equals: (v: import("three").Vector3Like) => boolean;
-                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector3;
+                normalize: () => import('three').Vector3;
+                setLength: (l: number) => import('three').Vector3;
+                lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
+                lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
+                cross: (a: import('three').Vector3Like) => import('three').Vector3;
+                crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
+                projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
+                reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
+                angleTo: (v: import('three').Vector3) => number;
+                distanceTo: (v: import('three').Vector3Like) => number;
+                distanceToSquared: (v: import('three').Vector3Like) => number;
+                manhattanDistanceTo: (v: import('three').Vector3Like) => number;
+                setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
+                setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
+                setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
+                setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
+                setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
+                setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
+                setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
+                setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
+                setFromEuler: (e: import('three').Euler) => import('three').Vector3;
+                setFromColor: (color: import('three').RGB) => import('three').Vector3;
+                equals: (v: import('three').Vector3Like) => boolean;
+                fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector3;
                 toArray: {
-                    (array?: number[] | undefined, offset?: number | undefined): number[];
-                    (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
-                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
+                    (array?: number[], offset?: number): number[];
+                    (array?: import('three').Vector3Tuple, offset?: 0): import('three').Vector3Tuple;
+                    (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                 };
-                fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => import("three").Vector3;
-                random: () => import("three").Vector3;
-                randomDirection: () => import("three").Vector3;
-                [Symbol.iterator]: () => Iterator<number, any, undefined>;
+                fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
+                random: () => import('three').Vector3;
+                randomDirection: () => import('three').Vector3;
+                [Symbol.iterator]: () => Iterator<number>;
             };
             readonly position: {
                 x: number;
                 y: number;
                 z: number;
                 readonly isVector3: true;
-                set: (x: number, y: number, z: number) => import("three").Vector3;
-                setScalar: (scalar: number) => import("three").Vector3;
-                setX: (x: number) => import("three").Vector3;
-                setY: (y: number) => import("three").Vector3;
-                setZ: (z: number) => import("three").Vector3;
-                setComponent: (index: number, value: number) => import("three").Vector3;
+                set: (x: number, y: number, z: number) => import('three').Vector3;
+                setScalar: (scalar: number) => import('three').Vector3;
+                setX: (x: number) => import('three').Vector3;
+                setY: (y: number) => import('three').Vector3;
+                setZ: (z: number) => import('three').Vector3;
+                setComponent: (index: number, value: number) => import('three').Vector3;
                 getComponent: (index: number) => number;
-                clone: () => import("three").Vector3;
-                copy: (v: import("three").Vector3Like) => import("three").Vector3;
-                add: (v: import("three").Vector3Like) => import("three").Vector3;
-                addScalar: (s: number) => import("three").Vector3;
-                addVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                addScaledVector: (v: import("three").Vector3, s: number) => import("three").Vector3;
-                sub: (a: import("three").Vector3Like) => import("three").Vector3;
-                subScalar: (s: number) => import("three").Vector3;
-                subVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                multiply: (v: import("three").Vector3Like) => import("three").Vector3;
-                multiplyScalar: (s: number) => import("three").Vector3;
-                multiplyVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                applyEuler: (euler: import("three").Euler) => import("three").Vector3;
-                applyAxisAngle: (axis: import("three").Vector3, angle: number) => import("three").Vector3;
-                applyMatrix3: (m: import("three").Matrix3) => import("three").Vector3;
-                applyNormalMatrix: (m: import("three").Matrix3) => import("three").Vector3;
-                applyMatrix4: (m: import("three").Matrix4) => import("three").Vector3;
-                applyQuaternion: (q: import("three").QuaternionLike) => import("three").Vector3;
-                project: (camera: Camera) => import("three").Vector3;
-                unproject: (camera: Camera) => import("three").Vector3;
-                transformDirection: (m: import("three").Matrix4) => import("three").Vector3;
-                divide: (v: import("three").Vector3Like) => import("three").Vector3;
-                divideScalar: (s: number) => import("three").Vector3;
-                min: (v: import("three").Vector3Like) => import("three").Vector3;
-                max: (v: import("three").Vector3Like) => import("three").Vector3;
-                clamp: (min: import("three").Vector3Like, max: import("three").Vector3Like) => import("three").Vector3;
-                clampScalar: (min: number, max: number) => import("three").Vector3;
-                clampLength: (min: number, max: number) => import("three").Vector3;
-                floor: () => import("three").Vector3;
-                ceil: () => import("three").Vector3;
-                round: () => import("three").Vector3;
-                roundToZero: () => import("three").Vector3;
-                negate: () => import("three").Vector3;
-                dot: (v: import("three").Vector3Like) => number;
+                clone: () => import('three').Vector3;
+                copy: (v: import('three').Vector3Like) => import('three').Vector3;
+                add: (v: import('three').Vector3Like) => import('three').Vector3;
+                addScalar: (s: number) => import('three').Vector3;
+                addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
+                sub: (a: import('three').Vector3Like) => import('three').Vector3;
+                subScalar: (s: number) => import('three').Vector3;
+                subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                multiply: (v: import('three').Vector3Like) => import('three').Vector3;
+                multiplyScalar: (s: number) => import('three').Vector3;
+                multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                applyEuler: (euler: import('three').Euler) => import('three').Vector3;
+                applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
+                applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
+                applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
+                applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
+                applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
+                project: (camera: Camera) => import('three').Vector3;
+                unproject: (camera: Camera) => import('three').Vector3;
+                transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
+                divide: (v: import('three').Vector3Like) => import('three').Vector3;
+                divideScalar: (s: number) => import('three').Vector3;
+                min: (v: import('three').Vector3Like) => import('three').Vector3;
+                max: (v: import('three').Vector3Like) => import('three').Vector3;
+                clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
+                clampScalar: (min: number, max: number) => import('three').Vector3;
+                clampLength: (min: number, max: number) => import('three').Vector3;
+                floor: () => import('three').Vector3;
+                ceil: () => import('three').Vector3;
+                round: () => import('three').Vector3;
+                roundToZero: () => import('three').Vector3;
+                negate: () => import('three').Vector3;
+                dot: (v: import('three').Vector3Like) => number;
                 lengthSq: () => number;
                 length: () => number;
                 manhattanLength: () => number;
-                normalize: () => import("three").Vector3;
-                setLength: (l: number) => import("three").Vector3;
-                lerp: (v: import("three").Vector3Like, alpha: number) => import("three").Vector3;
-                lerpVectors: (v1: import("three").Vector3Like, v2: import("three").Vector3Like, alpha: number) => import("three").Vector3;
-                cross: (a: import("three").Vector3Like) => import("three").Vector3;
-                crossVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                projectOnVector: (v: import("three").Vector3) => import("three").Vector3;
-                projectOnPlane: (planeNormal: import("three").Vector3) => import("three").Vector3;
-                reflect: (vector: import("three").Vector3Like) => import("three").Vector3;
-                angleTo: (v: import("three").Vector3) => number;
-                distanceTo: (v: import("three").Vector3Like) => number;
-                distanceToSquared: (v: import("three").Vector3Like) => number;
-                manhattanDistanceTo: (v: import("three").Vector3Like) => number;
-                setFromSpherical: (s: import("three").Spherical) => import("three").Vector3;
-                setFromSphericalCoords: (r: number, phi: number, theta: number) => import("three").Vector3;
-                setFromCylindrical: (s: import("three").Cylindrical) => import("three").Vector3;
-                setFromCylindricalCoords: (radius: number, theta: number, y: number) => import("three").Vector3;
-                setFromMatrixPosition: (m: import("three").Matrix4) => import("three").Vector3;
-                setFromMatrixScale: (m: import("three").Matrix4) => import("three").Vector3;
-                setFromMatrixColumn: (matrix: import("three").Matrix4, index: number) => import("three").Vector3;
-                setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => import("three").Vector3;
-                setFromEuler: (e: import("three").Euler) => import("three").Vector3;
-                setFromColor: (color: import("three").RGB) => import("three").Vector3;
-                equals: (v: import("three").Vector3Like) => boolean;
-                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector3;
+                normalize: () => import('three').Vector3;
+                setLength: (l: number) => import('three').Vector3;
+                lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
+                lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
+                cross: (a: import('three').Vector3Like) => import('three').Vector3;
+                crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
+                projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
+                reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
+                angleTo: (v: import('three').Vector3) => number;
+                distanceTo: (v: import('three').Vector3Like) => number;
+                distanceToSquared: (v: import('three').Vector3Like) => number;
+                manhattanDistanceTo: (v: import('three').Vector3Like) => number;
+                setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
+                setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
+                setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
+                setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
+                setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
+                setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
+                setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
+                setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
+                setFromEuler: (e: import('three').Euler) => import('three').Vector3;
+                setFromColor: (color: import('three').RGB) => import('three').Vector3;
+                equals: (v: import('three').Vector3Like) => boolean;
+                fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector3;
                 toArray: {
-                    (array?: number[] | undefined, offset?: number | undefined): number[];
-                    (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
-                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
+                    (array?: number[], offset?: number): number[];
+                    (array?: import('three').Vector3Tuple, offset?: 0): import('three').Vector3Tuple;
+                    (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                 };
-                fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => import("three").Vector3;
-                random: () => import("three").Vector3;
-                randomDirection: () => import("three").Vector3;
-                [Symbol.iterator]: () => Iterator<number, any, undefined>;
+                fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
+                random: () => import('three').Vector3;
+                randomDirection: () => import('three').Vector3;
+                [Symbol.iterator]: () => Iterator<number>;
             };
             readonly rotation: {
                 x: number;
                 y: number;
                 z: number;
-                order: import("three").EulerOrder;
+                order: import('three').EulerOrder;
                 readonly isEuler: true;
                 _onChangeCallback: () => void;
-                set: (x: number, y: number, z: number, order?: import("three").EulerOrder | undefined) => import("three").Euler;
-                clone: () => import("three").Euler;
-                copy: (euler: import("three").Euler) => import("three").Euler;
-                setFromRotationMatrix: (m: import("three").Matrix4, order?: import("three").EulerOrder | undefined, update?: boolean | undefined) => import("three").Euler;
-                setFromQuaternion: (q: import("three").Quaternion, order?: import("three").EulerOrder | undefined, update?: boolean | undefined) => import("three").Euler;
-                setFromVector3: (v: import("three").Vector3, order?: import("three").EulerOrder | undefined) => import("three").Euler;
-                reorder: (newOrder: import("three").EulerOrder) => import("three").Euler;
-                equals: (euler: import("three").Euler) => boolean;
-                fromArray: (xyzo: [number, number, number, (import("three").EulerOrder | undefined)?, ...any[]]) => import("three").Euler;
-                toArray: (array?: (string | number | undefined)[] | undefined, offset?: number | undefined) => (string | number | undefined)[];
-                _onChange: (callback: () => void) => import("three").Euler;
-                [Symbol.iterator]: () => Generator<string | number, void, unknown>;
+                set: (x: number, y: number, z: number, order?: import('three').EulerOrder) => import('three').Euler;
+                clone: () => import('three').Euler;
+                copy: (euler: import('three').Euler) => import('three').Euler;
+                setFromRotationMatrix: (m: import('three').Matrix4, order?: import('three').EulerOrder, update?: boolean) => import('three').Euler;
+                setFromQuaternion: (q: import('three').Quaternion, order?: import('three').EulerOrder, update?: boolean) => import('three').Euler;
+                setFromVector3: (v: import('three').Vector3, order?: import('three').EulerOrder) => import('three').Euler;
+                reorder: (newOrder: import('three').EulerOrder) => import('three').Euler;
+                equals: (euler: import('three').Euler) => boolean;
+                fromArray: (xyzo: [number, number, number, import('three').EulerOrder?, ...any[]]) => import('three').Euler;
+                toArray: (array?: Array<number | string | undefined>, offset?: number) => Array<number | string | undefined>;
+                _onChange: (callback: () => void) => import('three').Euler;
+                [Symbol.iterator]: () => Generator<string | number, void>;
             };
             readonly quaternion: {
                 x: number;
@@ -1845,348 +1865,352 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                 z: number;
                 w: number;
                 readonly isQuaternion: true;
-                set: (x: number, y: number, z: number, w: number) => import("three").Quaternion;
-                clone: () => import("three").Quaternion;
-                copy: (q: import("three").QuaternionLike) => import("three").Quaternion;
-                setFromEuler: (euler: import("three").Euler, update?: boolean | undefined) => import("three").Quaternion;
-                setFromAxisAngle: (axis: import("three").Vector3Like, angle: number) => import("three").Quaternion;
-                setFromRotationMatrix: (m: import("three").Matrix4) => import("three").Quaternion;
-                setFromUnitVectors: (vFrom: import("three").Vector3, vTo: import("three").Vector3Like) => import("three").Quaternion;
-                angleTo: (q: import("three").Quaternion) => number;
-                rotateTowards: (q: import("three").Quaternion, step: number) => import("three").Quaternion;
-                identity: () => import("three").Quaternion;
-                invert: () => import("three").Quaternion;
-                conjugate: () => import("three").Quaternion;
-                dot: (v: import("three").Quaternion) => number;
+                set: (x: number, y: number, z: number, w: number) => import('three').Quaternion;
+                clone: () => import('three').Quaternion;
+                copy: (q: import('three').QuaternionLike) => import('three').Quaternion;
+                setFromEuler: (euler: import('three').Euler, update?: boolean) => import('three').Quaternion;
+                setFromAxisAngle: (axis: import('three').Vector3Like, angle: number) => import('three').Quaternion;
+                setFromRotationMatrix: (m: import('three').Matrix4) => import('three').Quaternion;
+                setFromUnitVectors: (vFrom: import('three').Vector3, vTo: import('three').Vector3Like) => import('three').Quaternion;
+                angleTo: (q: import('three').Quaternion) => number;
+                rotateTowards: (q: import('three').Quaternion, step: number) => import('three').Quaternion;
+                identity: () => import('three').Quaternion;
+                invert: () => import('three').Quaternion;
+                conjugate: () => import('three').Quaternion;
+                dot: (v: import('three').Quaternion) => number;
                 lengthSq: () => number;
                 length: () => number;
-                normalize: () => import("three").Quaternion;
-                multiply: (q: import("three").Quaternion) => import("three").Quaternion;
-                premultiply: (q: import("three").Quaternion) => import("three").Quaternion;
-                multiplyQuaternions: (a: import("three").Quaternion, b: import("three").Quaternion) => import("three").Quaternion;
-                slerp: (qb: import("three").Quaternion, t: number) => import("three").Quaternion;
-                slerpQuaternions: (qa: import("three").Quaternion, qb: import("three").Quaternion, t: number) => import("three").Quaternion;
-                equals: (v: import("three").Quaternion) => boolean;
-                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Quaternion;
+                normalize: () => import('three').Quaternion;
+                multiply: (q: import('three').Quaternion) => import('three').Quaternion;
+                premultiply: (q: import('three').Quaternion) => import('three').Quaternion;
+                multiplyQuaternions: (a: import('three').Quaternion, b: import('three').Quaternion) => import('three').Quaternion;
+                slerp: (qb: import('three').Quaternion, t: number) => import('three').Quaternion;
+                slerpQuaternions: (qa: import('three').Quaternion, qb: import('three').Quaternion, t: number) => import('three').Quaternion;
+                equals: (v: import('three').Quaternion) => boolean;
+                fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Quaternion;
                 toArray: {
-                    (array?: number[] | undefined, offset?: number | undefined): number[];
-                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
+                    (array?: number[], offset?: number): number[];
+                    (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                 };
                 toJSON: () => [number, number, number, number];
-                fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => import("three").Quaternion;
-                _onChange: (callback: () => void) => import("three").Quaternion;
+                fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Quaternion;
+                _onChange: (callback: () => void) => import('three').Quaternion;
                 _onChangeCallback: () => void;
-                random: () => import("three").Quaternion;
-                [Symbol.iterator]: () => Generator<number, void, unknown>;
+                random: () => import('three').Quaternion;
+                [Symbol.iterator]: () => Generator<number, void>;
             };
             readonly scale: {
                 x: number;
                 y: number;
                 z: number;
                 readonly isVector3: true;
-                set: (x: number, y: number, z: number) => import("three").Vector3;
-                setScalar: (scalar: number) => import("three").Vector3;
-                setX: (x: number) => import("three").Vector3;
-                setY: (y: number) => import("three").Vector3;
-                setZ: (z: number) => import("three").Vector3;
-                setComponent: (index: number, value: number) => import("three").Vector3;
+                set: (x: number, y: number, z: number) => import('three').Vector3;
+                setScalar: (scalar: number) => import('three').Vector3;
+                setX: (x: number) => import('three').Vector3;
+                setY: (y: number) => import('three').Vector3;
+                setZ: (z: number) => import('three').Vector3;
+                setComponent: (index: number, value: number) => import('three').Vector3;
                 getComponent: (index: number) => number;
-                clone: () => import("three").Vector3;
-                copy: (v: import("three").Vector3Like) => import("three").Vector3;
-                add: (v: import("three").Vector3Like) => import("three").Vector3;
-                addScalar: (s: number) => import("three").Vector3;
-                addVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                addScaledVector: (v: import("three").Vector3, s: number) => import("three").Vector3;
-                sub: (a: import("three").Vector3Like) => import("three").Vector3;
-                subScalar: (s: number) => import("three").Vector3;
-                subVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                multiply: (v: import("three").Vector3Like) => import("three").Vector3;
-                multiplyScalar: (s: number) => import("three").Vector3;
-                multiplyVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                applyEuler: (euler: import("three").Euler) => import("three").Vector3;
-                applyAxisAngle: (axis: import("three").Vector3, angle: number) => import("three").Vector3;
-                applyMatrix3: (m: import("three").Matrix3) => import("three").Vector3;
-                applyNormalMatrix: (m: import("three").Matrix3) => import("three").Vector3;
-                applyMatrix4: (m: import("three").Matrix4) => import("three").Vector3;
-                applyQuaternion: (q: import("three").QuaternionLike) => import("three").Vector3;
-                project: (camera: Camera) => import("three").Vector3;
-                unproject: (camera: Camera) => import("three").Vector3;
-                transformDirection: (m: import("three").Matrix4) => import("three").Vector3;
-                divide: (v: import("three").Vector3Like) => import("three").Vector3;
-                divideScalar: (s: number) => import("three").Vector3;
-                min: (v: import("three").Vector3Like) => import("three").Vector3;
-                max: (v: import("three").Vector3Like) => import("three").Vector3;
-                clamp: (min: import("three").Vector3Like, max: import("three").Vector3Like) => import("three").Vector3;
-                clampScalar: (min: number, max: number) => import("three").Vector3;
-                clampLength: (min: number, max: number) => import("three").Vector3;
-                floor: () => import("three").Vector3;
-                ceil: () => import("three").Vector3;
-                round: () => import("three").Vector3;
-                roundToZero: () => import("three").Vector3;
-                negate: () => import("three").Vector3;
-                dot: (v: import("three").Vector3Like) => number;
+                clone: () => import('three').Vector3;
+                copy: (v: import('three').Vector3Like) => import('three').Vector3;
+                add: (v: import('three').Vector3Like) => import('three').Vector3;
+                addScalar: (s: number) => import('three').Vector3;
+                addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
+                sub: (a: import('three').Vector3Like) => import('three').Vector3;
+                subScalar: (s: number) => import('three').Vector3;
+                subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                multiply: (v: import('three').Vector3Like) => import('three').Vector3;
+                multiplyScalar: (s: number) => import('three').Vector3;
+                multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                applyEuler: (euler: import('three').Euler) => import('three').Vector3;
+                applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
+                applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
+                applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
+                applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
+                applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
+                project: (camera: Camera) => import('three').Vector3;
+                unproject: (camera: Camera) => import('three').Vector3;
+                transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
+                divide: (v: import('three').Vector3Like) => import('three').Vector3;
+                divideScalar: (s: number) => import('three').Vector3;
+                min: (v: import('three').Vector3Like) => import('three').Vector3;
+                max: (v: import('three').Vector3Like) => import('three').Vector3;
+                clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
+                clampScalar: (min: number, max: number) => import('three').Vector3;
+                clampLength: (min: number, max: number) => import('three').Vector3;
+                floor: () => import('three').Vector3;
+                ceil: () => import('three').Vector3;
+                round: () => import('three').Vector3;
+                roundToZero: () => import('three').Vector3;
+                negate: () => import('three').Vector3;
+                dot: (v: import('three').Vector3Like) => number;
                 lengthSq: () => number;
                 length: () => number;
                 manhattanLength: () => number;
-                normalize: () => import("three").Vector3;
-                setLength: (l: number) => import("three").Vector3;
-                lerp: (v: import("three").Vector3Like, alpha: number) => import("three").Vector3;
-                lerpVectors: (v1: import("three").Vector3Like, v2: import("three").Vector3Like, alpha: number) => import("three").Vector3;
-                cross: (a: import("three").Vector3Like) => import("three").Vector3;
-                crossVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                projectOnVector: (v: import("three").Vector3) => import("three").Vector3;
-                projectOnPlane: (planeNormal: import("three").Vector3) => import("three").Vector3;
-                reflect: (vector: import("three").Vector3Like) => import("three").Vector3;
-                angleTo: (v: import("three").Vector3) => number;
-                distanceTo: (v: import("three").Vector3Like) => number;
-                distanceToSquared: (v: import("three").Vector3Like) => number;
-                manhattanDistanceTo: (v: import("three").Vector3Like) => number;
-                setFromSpherical: (s: import("three").Spherical) => import("three").Vector3;
-                setFromSphericalCoords: (r: number, phi: number, theta: number) => import("three").Vector3;
-                setFromCylindrical: (s: import("three").Cylindrical) => import("three").Vector3;
-                setFromCylindricalCoords: (radius: number, theta: number, y: number) => import("three").Vector3;
-                setFromMatrixPosition: (m: import("three").Matrix4) => import("three").Vector3;
-                setFromMatrixScale: (m: import("three").Matrix4) => import("three").Vector3;
-                setFromMatrixColumn: (matrix: import("three").Matrix4, index: number) => import("three").Vector3;
-                setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => import("three").Vector3;
-                setFromEuler: (e: import("three").Euler) => import("three").Vector3;
-                setFromColor: (color: import("three").RGB) => import("three").Vector3;
-                equals: (v: import("three").Vector3Like) => boolean;
-                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector3;
+                normalize: () => import('three').Vector3;
+                setLength: (l: number) => import('three').Vector3;
+                lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
+                lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
+                cross: (a: import('three').Vector3Like) => import('three').Vector3;
+                crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
+                projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
+                reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
+                angleTo: (v: import('three').Vector3) => number;
+                distanceTo: (v: import('three').Vector3Like) => number;
+                distanceToSquared: (v: import('three').Vector3Like) => number;
+                manhattanDistanceTo: (v: import('three').Vector3Like) => number;
+                setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
+                setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
+                setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
+                setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
+                setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
+                setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
+                setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
+                setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
+                setFromEuler: (e: import('three').Euler) => import('three').Vector3;
+                setFromColor: (color: import('three').RGB) => import('three').Vector3;
+                equals: (v: import('three').Vector3Like) => boolean;
+                fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector3;
                 toArray: {
-                    (array?: number[] | undefined, offset?: number | undefined): number[];
-                    (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
-                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
+                    (array?: number[], offset?: number): number[];
+                    (array?: import('three').Vector3Tuple, offset?: 0): import('three').Vector3Tuple;
+                    (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                 };
-                fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => import("three").Vector3;
-                random: () => import("three").Vector3;
-                randomDirection: () => import("three").Vector3;
-                [Symbol.iterator]: () => Iterator<number, any, undefined>;
+                fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
+                random: () => import('three').Vector3;
+                randomDirection: () => import('three').Vector3;
+                [Symbol.iterator]: () => Iterator<number>;
             };
             readonly modelViewMatrix: {
+                readonly isMatrix4: true;
                 elements: number[];
-                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import("three").Matrix4;
-                identity: () => import("three").Matrix4;
-                clone: () => import("three").Matrix4;
-                copy: (m: import("three").Matrix4) => import("three").Matrix4;
-                copyPosition: (m: import("three").Matrix4) => import("three").Matrix4;
-                extractBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
-                makeBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
-                extractRotation: (m: import("three").Matrix4) => import("three").Matrix4;
-                makeRotationFromEuler: (euler: import("three").Euler) => import("three").Matrix4;
-                makeRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
-                lookAt: (eye: import("three").Vector3, target: import("three").Vector3, up: import("three").Vector3) => import("three").Matrix4;
-                multiply: (m: import("three").Matrix4) => import("three").Matrix4;
-                premultiply: (m: import("three").Matrix4) => import("three").Matrix4;
-                multiplyMatrices: (a: import("three").Matrix4, b: import("three").Matrix4) => import("three").Matrix4;
-                multiplyToArray: (a: import("three").Matrix4, b: import("three").Matrix4, r: number[]) => import("three").Matrix4;
-                multiplyScalar: (s: number) => import("three").Matrix4;
+                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
+                identity: () => import('three').Matrix4;
+                clone: () => import('three').Matrix4;
+                copy: (m: import('three').Matrix4) => import('three').Matrix4;
+                copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
+                extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
+                makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
+                extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
+                makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
+                makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
+                lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
+                multiply: (m: import('three').Matrix4) => import('three').Matrix4;
+                premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
+                multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
+                multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
+                multiplyScalar: (s: number) => import('three').Matrix4;
                 determinant: () => number;
-                transpose: () => import("three").Matrix4;
+                transpose: () => import('three').Matrix4;
                 setPosition: {
-                    (v: import("three").Vector3): import("three").Matrix4;
-                    (x: number, y: number, z: number): import("three").Matrix4;
+                    (v: import('three').Vector3): import('three').Matrix4;
+                    (x: number, y: number, z: number): import('three').Matrix4;
                 };
-                invert: () => import("three").Matrix4;
-                scale: (v: import("three").Vector3) => import("three").Matrix4;
+                invert: () => import('three').Matrix4;
+                scale: (v: import('three').Vector3) => import('three').Matrix4;
                 getMaxScaleOnAxis: () => number;
                 makeTranslation: {
-                    (v: import("three").Vector3): import("three").Matrix4;
-                    (x: number, y: number, z: number): import("three").Matrix4;
+                    (v: import('three').Vector3): import('three').Matrix4;
+                    (x: number, y: number, z: number): import('three').Matrix4;
                 };
-                makeRotationX: (theta: number) => import("three").Matrix4;
-                makeRotationY: (theta: number) => import("three").Matrix4;
-                makeRotationZ: (theta: number) => import("three").Matrix4;
-                makeRotationAxis: (axis: import("three").Vector3, angle: number) => import("three").Matrix4;
-                makeScale: (x: number, y: number, z: number) => import("three").Matrix4;
-                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import("three").Matrix4;
-                compose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
-                decompose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
-                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => import("three").Matrix4;
-                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => import("three").Matrix4;
-                equals: (matrix: import("three").Matrix4) => boolean;
-                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Matrix4;
+                makeRotationX: (theta: number) => import('three').Matrix4;
+                makeRotationY: (theta: number) => import('three').Matrix4;
+                makeRotationZ: (theta: number) => import('three').Matrix4;
+                makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
+                makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
+                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
+                compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
+                decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
+                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
+                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
+                equals: (matrix: import('three').Matrix4) => boolean;
+                fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Matrix4;
                 toArray: {
-                    (array?: number[] | undefined, offset?: number | undefined): number[];
-                    (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
-                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
+                    (array?: number[], offset?: number): number[];
+                    (array?: import('three').Matrix4Tuple, offset?: 0): import('three').Matrix4Tuple;
+                    (array?: ArrayLike<number>, offset?: number): ArrayLike<number>;
                 };
-                setFromMatrix3: (m: import("three").Matrix3) => import("three").Matrix4;
-                extractPosition: (m: import("three").Matrix4) => import("three").Matrix4;
-                setRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
+                setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
+                extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
+                setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                 multiplyVector3: (v: any) => any;
                 multiplyVector4: (v: any) => any;
                 multiplyVector3Array: (array: number[]) => number[];
                 rotateAxis: (v: any) => void;
                 crossVector: (v: any) => void;
                 flattenToArrayOffset: (array: number[], offset: number) => number[];
-                getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
+                getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
             };
             readonly normalMatrix: {
+                readonly isMatrix3: true;
                 elements: number[];
-                set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => import("three").Matrix3;
-                identity: () => import("three").Matrix3;
-                clone: () => import("three").Matrix3;
-                copy: (m: import("three").Matrix3) => import("three").Matrix3;
-                extractBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix3;
-                setFromMatrix4: (m: import("three").Matrix4) => import("three").Matrix3;
-                multiplyScalar: (s: number) => import("three").Matrix3;
+                set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => import('three').Matrix3;
+                identity: () => import('three').Matrix3;
+                clone: () => import('three').Matrix3;
+                copy: (m: import('three').Matrix3) => import('three').Matrix3;
+                extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix3;
+                setFromMatrix4: (m: import('three').Matrix4) => import('three').Matrix3;
+                multiplyScalar: (s: number) => import('three').Matrix3;
                 determinant: () => number;
-                invert: () => import("three").Matrix3;
-                transpose: () => import("three").Matrix3;
-                getNormalMatrix: (matrix4: import("three").Matrix4) => import("three").Matrix3;
-                transposeIntoArray: (r: number[]) => import("three").Matrix3;
-                setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => import("three").Matrix3;
-                scale: (sx: number, sy: number) => import("three").Matrix3;
+                invert: () => import('three').Matrix3;
+                transpose: () => import('three').Matrix3;
+                getNormalMatrix: (matrix4: import('three').Matrix4) => import('three').Matrix3;
+                transposeIntoArray: (r: number[]) => import('three').Matrix3;
+                setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => import('three').Matrix3;
+                scale: (sx: number, sy: number) => import('three').Matrix3;
                 makeTranslation: {
-                    (v: import("three").Vector2): import("three").Matrix3;
-                    (x: number, y: number): import("three").Matrix3;
+                    (v: import('three').Vector2): import('three').Matrix3;
+                    (x: number, y: number): import('three').Matrix3;
                 };
                 makeRotation: {
-                    (theta: number): import("three").Matrix3;
-                    (theta: number): import("three").Matrix3;
+                    (theta: number): import('three').Matrix3;
+                    (theta: number): import('three').Matrix3;
                 };
                 makeScale: {
-                    (x: number, y: number): import("three").Matrix3;
-                    (x: number, y: number): import("three").Matrix3;
+                    (x: number, y: number): import('three').Matrix3;
+                    (x: number, y: number): import('three').Matrix3;
                 };
-                rotate: (theta: number) => import("three").Matrix3;
-                translate: (tx: number, ty: number) => import("three").Matrix3;
-                equals: (matrix: import("three").Matrix3) => boolean;
-                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Matrix3;
+                rotate: (theta: number) => import('three').Matrix3;
+                translate: (tx: number, ty: number) => import('three').Matrix3;
+                equals: (matrix: import('three').Matrix3) => boolean;
+                fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Matrix3;
                 toArray: {
-                    (array?: number[] | undefined, offset?: number | undefined): number[];
-                    (array?: import("three").Matrix3Tuple | undefined, offset?: 0 | undefined): import("three").Matrix3Tuple;
-                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
+                    (array?: number[], offset?: number): number[];
+                    (array?: import('three').Matrix3Tuple, offset?: 0): import('three').Matrix3Tuple;
+                    (array?: ArrayLike<number>, offset?: number): ArrayLike<number>;
                 };
-                multiply: (m: import("three").Matrix3) => import("three").Matrix3;
-                premultiply: (m: import("three").Matrix3) => import("three").Matrix3;
-                multiplyMatrices: (a: import("three").Matrix3, b: import("three").Matrix3) => import("three").Matrix3;
-                multiplyVector3: (vector: import("three").Vector3) => any;
+                multiply: (m: import('three').Matrix3) => import('three').Matrix3;
+                premultiply: (m: import('three').Matrix3) => import('three').Matrix3;
+                multiplyMatrices: (a: import('three').Matrix3, b: import('three').Matrix3) => import('three').Matrix3;
+                multiplyVector3: (vector: import('three').Vector3) => any;
                 multiplyVector3Array: (a: any) => any;
                 getInverse: {
-                    (matrix: import("three").Matrix4, throwOnDegenerate?: boolean | undefined): import("three").Matrix3;
-                    (matrix: import("three").Matrix): import("three").Matrix;
+                    (matrix: import('three').Matrix4, throwOnDegenerate?: boolean): import('three').Matrix3;
+                    (matrix: import('three').Matrix): import('three').Matrix;
                 };
                 flattenToArrayOffset: (array: number[], offset: number) => number[];
             };
             matrix: {
+                readonly isMatrix4: true;
                 elements: number[];
-                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import("three").Matrix4;
-                identity: () => import("three").Matrix4;
-                clone: () => import("three").Matrix4;
-                copy: (m: import("three").Matrix4) => import("three").Matrix4;
-                copyPosition: (m: import("three").Matrix4) => import("three").Matrix4;
-                extractBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
-                makeBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
-                extractRotation: (m: import("three").Matrix4) => import("three").Matrix4;
-                makeRotationFromEuler: (euler: import("three").Euler) => import("three").Matrix4;
-                makeRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
-                lookAt: (eye: import("three").Vector3, target: import("three").Vector3, up: import("three").Vector3) => import("three").Matrix4;
-                multiply: (m: import("three").Matrix4) => import("three").Matrix4;
-                premultiply: (m: import("three").Matrix4) => import("three").Matrix4;
-                multiplyMatrices: (a: import("three").Matrix4, b: import("three").Matrix4) => import("three").Matrix4;
-                multiplyToArray: (a: import("three").Matrix4, b: import("three").Matrix4, r: number[]) => import("three").Matrix4;
-                multiplyScalar: (s: number) => import("three").Matrix4;
+                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
+                identity: () => import('three').Matrix4;
+                clone: () => import('three').Matrix4;
+                copy: (m: import('three').Matrix4) => import('three').Matrix4;
+                copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
+                extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
+                makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
+                extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
+                makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
+                makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
+                lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
+                multiply: (m: import('three').Matrix4) => import('three').Matrix4;
+                premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
+                multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
+                multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
+                multiplyScalar: (s: number) => import('three').Matrix4;
                 determinant: () => number;
-                transpose: () => import("three").Matrix4;
+                transpose: () => import('three').Matrix4;
                 setPosition: {
-                    (v: import("three").Vector3): import("three").Matrix4;
-                    (x: number, y: number, z: number): import("three").Matrix4;
+                    (v: import('three').Vector3): import('three').Matrix4;
+                    (x: number, y: number, z: number): import('three').Matrix4;
                 };
-                invert: () => import("three").Matrix4;
-                scale: (v: import("three").Vector3) => import("three").Matrix4;
+                invert: () => import('three').Matrix4;
+                scale: (v: import('three').Vector3) => import('three').Matrix4;
                 getMaxScaleOnAxis: () => number;
                 makeTranslation: {
-                    (v: import("three").Vector3): import("three").Matrix4;
-                    (x: number, y: number, z: number): import("three").Matrix4;
+                    (v: import('three').Vector3): import('three').Matrix4;
+                    (x: number, y: number, z: number): import('three').Matrix4;
                 };
-                makeRotationX: (theta: number) => import("three").Matrix4;
-                makeRotationY: (theta: number) => import("three").Matrix4;
-                makeRotationZ: (theta: number) => import("three").Matrix4;
-                makeRotationAxis: (axis: import("three").Vector3, angle: number) => import("three").Matrix4;
-                makeScale: (x: number, y: number, z: number) => import("three").Matrix4;
-                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import("three").Matrix4;
-                compose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
-                decompose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
-                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => import("three").Matrix4;
-                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => import("three").Matrix4;
-                equals: (matrix: import("three").Matrix4) => boolean;
-                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Matrix4;
+                makeRotationX: (theta: number) => import('three').Matrix4;
+                makeRotationY: (theta: number) => import('three').Matrix4;
+                makeRotationZ: (theta: number) => import('three').Matrix4;
+                makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
+                makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
+                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
+                compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
+                decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
+                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
+                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
+                equals: (matrix: import('three').Matrix4) => boolean;
+                fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Matrix4;
                 toArray: {
-                    (array?: number[] | undefined, offset?: number | undefined): number[];
-                    (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
-                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
+                    (array?: number[], offset?: number): number[];
+                    (array?: import('three').Matrix4Tuple, offset?: 0): import('three').Matrix4Tuple;
+                    (array?: ArrayLike<number>, offset?: number): ArrayLike<number>;
                 };
-                setFromMatrix3: (m: import("three").Matrix3) => import("three").Matrix4;
-                extractPosition: (m: import("three").Matrix4) => import("three").Matrix4;
-                setRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
+                setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
+                extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
+                setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                 multiplyVector3: (v: any) => any;
                 multiplyVector4: (v: any) => any;
                 multiplyVector3Array: (array: number[]) => number[];
                 rotateAxis: (v: any) => void;
                 crossVector: (v: any) => void;
                 flattenToArrayOffset: (array: number[], offset: number) => number[];
-                getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
+                getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
             };
             matrixWorld: {
+                readonly isMatrix4: true;
                 elements: number[];
-                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import("three").Matrix4;
-                identity: () => import("three").Matrix4;
-                clone: () => import("three").Matrix4;
-                copy: (m: import("three").Matrix4) => import("three").Matrix4;
-                copyPosition: (m: import("three").Matrix4) => import("three").Matrix4;
-                extractBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
-                makeBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
-                extractRotation: (m: import("three").Matrix4) => import("three").Matrix4;
-                makeRotationFromEuler: (euler: import("three").Euler) => import("three").Matrix4;
-                makeRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
-                lookAt: (eye: import("three").Vector3, target: import("three").Vector3, up: import("three").Vector3) => import("three").Matrix4;
-                multiply: (m: import("three").Matrix4) => import("three").Matrix4;
-                premultiply: (m: import("three").Matrix4) => import("three").Matrix4;
-                multiplyMatrices: (a: import("three").Matrix4, b: import("three").Matrix4) => import("three").Matrix4;
-                multiplyToArray: (a: import("three").Matrix4, b: import("three").Matrix4, r: number[]) => import("three").Matrix4;
-                multiplyScalar: (s: number) => import("three").Matrix4;
+                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
+                identity: () => import('three').Matrix4;
+                clone: () => import('three').Matrix4;
+                copy: (m: import('three').Matrix4) => import('three').Matrix4;
+                copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
+                extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
+                makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
+                extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
+                makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
+                makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
+                lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
+                multiply: (m: import('three').Matrix4) => import('three').Matrix4;
+                premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
+                multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
+                multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
+                multiplyScalar: (s: number) => import('three').Matrix4;
                 determinant: () => number;
-                transpose: () => import("three").Matrix4;
+                transpose: () => import('three').Matrix4;
                 setPosition: {
-                    (v: import("three").Vector3): import("three").Matrix4;
-                    (x: number, y: number, z: number): import("three").Matrix4;
+                    (v: import('three').Vector3): import('three').Matrix4;
+                    (x: number, y: number, z: number): import('three').Matrix4;
                 };
-                invert: () => import("three").Matrix4;
-                scale: (v: import("three").Vector3) => import("three").Matrix4;
+                invert: () => import('three').Matrix4;
+                scale: (v: import('three').Vector3) => import('three').Matrix4;
                 getMaxScaleOnAxis: () => number;
                 makeTranslation: {
-                    (v: import("three").Vector3): import("three").Matrix4;
-                    (x: number, y: number, z: number): import("three").Matrix4;
+                    (v: import('three').Vector3): import('three').Matrix4;
+                    (x: number, y: number, z: number): import('three').Matrix4;
                 };
-                makeRotationX: (theta: number) => import("three").Matrix4;
-                makeRotationY: (theta: number) => import("three").Matrix4;
-                makeRotationZ: (theta: number) => import("three").Matrix4;
-                makeRotationAxis: (axis: import("three").Vector3, angle: number) => import("three").Matrix4;
-                makeScale: (x: number, y: number, z: number) => import("three").Matrix4;
-                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import("three").Matrix4;
-                compose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
-                decompose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
-                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => import("three").Matrix4;
-                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => import("three").Matrix4;
-                equals: (matrix: import("three").Matrix4) => boolean;
-                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Matrix4;
+                makeRotationX: (theta: number) => import('three').Matrix4;
+                makeRotationY: (theta: number) => import('three').Matrix4;
+                makeRotationZ: (theta: number) => import('three').Matrix4;
+                makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
+                makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
+                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
+                compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
+                decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
+                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
+                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
+                equals: (matrix: import('three').Matrix4) => boolean;
+                fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Matrix4;
                 toArray: {
-                    (array?: number[] | undefined, offset?: number | undefined): number[];
-                    (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
-                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
+                    (array?: number[], offset?: number): number[];
+                    (array?: import('three').Matrix4Tuple, offset?: 0): import('three').Matrix4Tuple;
+                    (array?: ArrayLike<number>, offset?: number): ArrayLike<number>;
                 };
-                setFromMatrix3: (m: import("three").Matrix3) => import("three").Matrix4;
-                extractPosition: (m: import("three").Matrix4) => import("three").Matrix4;
-                setRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
+                setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
+                extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
+                setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                 multiplyVector3: (v: any) => any;
                 multiplyVector4: (v: any) => any;
                 multiplyVector3Array: (array: number[]) => number[];
                 rotateAxis: (v: any) => void;
                 crossVector: (v: any) => void;
                 flattenToArrayOffset: (array: number[], offset: number) => number[];
-                getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
+                getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
             };
             matrixAutoUpdate: boolean;
             matrixWorldAutoUpdate: boolean;
@@ -2199,7 +2223,7 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                 toggle: (layer: number) => void;
                 disable: (layer: number) => void;
                 disableAll: () => void;
-                test: (layers: import("three").Layers) => boolean;
+                test: (layers: import('three').Layers) => boolean;
                 isEnabled: (layer: number) => boolean;
             };
             visible: boolean;
@@ -2216,26 +2240,26 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                         readonly BYTES_PER_ELEMENT: number;
                         readonly buffer: {
                             readonly byteLength: number;
-                            slice: (begin: number, end?: number | undefined) => ArrayBuffer;
+                            slice: (begin: number, end?: number) => ArrayBuffer;
                             readonly [Symbol.toStringTag]: string;
                         } | {
                             readonly byteLength: number;
-                            slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
+                            slice: (begin: number, end?: number) => SharedArrayBuffer;
                             readonly [Symbol.species]: SharedArrayBuffer;
                             readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                         };
                         readonly byteLength: number;
                         readonly byteOffset: number;
-                        copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
+                        copyWithin: (target: number, start: number, end?: number) => Float32Array;
                         every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
-                        fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
+                        fill: (value: number, start?: number, end?: number) => Float32Array;
                         filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                         find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                         findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                         forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
-                        indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
-                        join: (separator?: string | undefined) => string;
-                        lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
+                        indexOf: (searchElement: number, fromIndex?: number) => number;
+                        join: (separator?: string) => string;
+                        lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                         readonly length: number;
                         map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                         reduce: {
@@ -2246,21 +2270,24 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                         reduceRight: {
                             (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                             (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
-                            <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
+                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                         };
                         reverse: () => Float32Array;
-                        set: (array: ArrayLike<number>, offset?: number | undefined) => void;
-                        slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
+                        set: (array: ArrayLike<number>, offset?: number) => void;
+                        slice: (start?: number, end?: number) => Float32Array;
                         some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                         sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
-                        subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
-                        toLocaleString: () => string;
+                        subarray: (begin?: number, end?: number) => Float32Array;
+                        toLocaleString: {
+                            (): string;
+                            (locales: string | string[], options?: Intl.NumberFormatOptions): string;
+                        };
                         toString: () => string;
                         valueOf: () => Float32Array;
                         entries: () => IterableIterator<[number, number]>;
                         keys: () => IterableIterator<number>;
                         values: () => IterableIterator<number>;
-                        includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
+                        includes: (searchElement: number, fromIndex?: number) => boolean;
                         at: (index: number) => number | undefined;
                         findLast: {
                             <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
@@ -2278,26 +2305,26 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                         readonly BYTES_PER_ELEMENT: number;
                         readonly buffer: {
                             readonly byteLength: number;
-                            slice: (begin: number, end?: number | undefined) => ArrayBuffer;
+                            slice: (begin: number, end?: number) => ArrayBuffer;
                             readonly [Symbol.toStringTag]: string;
                         } | {
                             readonly byteLength: number;
-                            slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
+                            slice: (begin: number, end?: number) => SharedArrayBuffer;
                             readonly [Symbol.species]: SharedArrayBuffer;
                             readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                         };
                         readonly byteLength: number;
                         readonly byteOffset: number;
-                        copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
+                        copyWithin: (target: number, start: number, end?: number) => Float32Array;
                         every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
-                        fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
+                        fill: (value: number, start?: number, end?: number) => Float32Array;
                         filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                         find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                         findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                         forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
-                        indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
-                        join: (separator?: string | undefined) => string;
-                        lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
+                        indexOf: (searchElement: number, fromIndex?: number) => number;
+                        join: (separator?: string) => string;
+                        lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                         readonly length: number;
                         map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                         reduce: {
@@ -2308,21 +2335,24 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                         reduceRight: {
                             (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                             (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
-                            <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
+                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                         };
                         reverse: () => Float32Array;
-                        set: (array: ArrayLike<number>, offset?: number | undefined) => void;
-                        slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
+                        set: (array: ArrayLike<number>, offset?: number) => void;
+                        slice: (start?: number, end?: number) => Float32Array;
                         some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                         sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
-                        subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
-                        toLocaleString: () => string;
+                        subarray: (begin?: number, end?: number) => Float32Array;
+                        toLocaleString: {
+                            (): string;
+                            (locales: string | string[], options?: Intl.NumberFormatOptions): string;
+                        };
                         toString: () => string;
                         valueOf: () => Float32Array;
                         entries: () => IterableIterator<[number, number]>;
                         keys: () => IterableIterator<number>;
                         values: () => IterableIterator<number>;
-                        includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
+                        includes: (searchElement: number, fromIndex?: number) => boolean;
                         at: (index: number) => number | undefined;
                         findLast: {
                             <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
@@ -2341,26 +2371,26 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                         readonly BYTES_PER_ELEMENT: number;
                         readonly buffer: {
                             readonly byteLength: number;
-                            slice: (begin: number, end?: number | undefined) => ArrayBuffer;
+                            slice: (begin: number, end?: number) => ArrayBuffer;
                             readonly [Symbol.toStringTag]: string;
                         } | {
                             readonly byteLength: number;
-                            slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
+                            slice: (begin: number, end?: number) => SharedArrayBuffer;
                             readonly [Symbol.species]: SharedArrayBuffer;
                             readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                         };
                         readonly byteLength: number;
                         readonly byteOffset: number;
-                        copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
+                        copyWithin: (target: number, start: number, end?: number) => Float32Array;
                         every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
-                        fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
+                        fill: (value: number, start?: number, end?: number) => Float32Array;
                         filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                         find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                         findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                         forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
-                        indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
-                        join: (separator?: string | undefined) => string;
-                        lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
+                        indexOf: (searchElement: number, fromIndex?: number) => number;
+                        join: (separator?: string) => string;
+                        lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                         readonly length: number;
                         map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                         reduce: {
@@ -2371,21 +2401,24 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                         reduceRight: {
                             (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                             (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
-                            <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
+                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                         };
                         reverse: () => Float32Array;
-                        set: (array: ArrayLike<number>, offset?: number | undefined) => void;
-                        slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
+                        set: (array: ArrayLike<number>, offset?: number) => void;
+                        slice: (start?: number, end?: number) => Float32Array;
                         some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                         sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
-                        subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
-                        toLocaleString: () => string;
+                        subarray: (begin?: number, end?: number) => Float32Array;
+                        toLocaleString: {
+                            (): string;
+                            (locales: string | string[], options?: Intl.NumberFormatOptions): string;
+                        };
                         toString: () => string;
                         valueOf: () => Float32Array;
                         entries: () => IterableIterator<[number, number]>;
                         keys: () => IterableIterator<number>;
                         values: () => IterableIterator<number>;
-                        includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
+                        includes: (searchElement: number, fromIndex?: number) => boolean;
                         at: (index: number) => number | undefined;
                         findLast: {
                             <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
@@ -2403,26 +2436,26 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                         readonly BYTES_PER_ELEMENT: number;
                         readonly buffer: {
                             readonly byteLength: number;
-                            slice: (begin: number, end?: number | undefined) => ArrayBuffer;
+                            slice: (begin: number, end?: number) => ArrayBuffer;
                             readonly [Symbol.toStringTag]: string;
                         } | {
                             readonly byteLength: number;
-                            slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
+                            slice: (begin: number, end?: number) => SharedArrayBuffer;
                             readonly [Symbol.species]: SharedArrayBuffer;
                             readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                         };
                         readonly byteLength: number;
                         readonly byteOffset: number;
-                        copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
+                        copyWithin: (target: number, start: number, end?: number) => Float32Array;
                         every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
-                        fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
+                        fill: (value: number, start?: number, end?: number) => Float32Array;
                         filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                         find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                         findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                         forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
-                        indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
-                        join: (separator?: string | undefined) => string;
-                        lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
+                        indexOf: (searchElement: number, fromIndex?: number) => number;
+                        join: (separator?: string) => string;
+                        lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                         readonly length: number;
                         map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                         reduce: {
@@ -2433,21 +2466,24 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                         reduceRight: {
                             (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                             (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
-                            <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
+                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                         };
                         reverse: () => Float32Array;
-                        set: (array: ArrayLike<number>, offset?: number | undefined) => void;
-                        slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
+                        set: (array: ArrayLike<number>, offset?: number) => void;
+                        slice: (start?: number, end?: number) => Float32Array;
                         some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                         sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
-                        subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
-                        toLocaleString: () => string;
+                        subarray: (begin?: number, end?: number) => Float32Array;
+                        toLocaleString: {
+                            (): string;
+                            (locales: string | string[], options?: Intl.NumberFormatOptions): string;
+                        };
                         toString: () => string;
                         valueOf: () => Float32Array;
                         entries: () => IterableIterator<[number, number]>;
                         keys: () => IterableIterator<number>;
                         values: () => IterableIterator<number>;
-                        includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
+                        includes: (searchElement: number, fromIndex?: number) => boolean;
                         at: (index: number) => number | undefined;
                         findLast: {
                             <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
@@ -2460,31 +2496,31 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                         [Symbol.iterator]: () => IterableIterator<number>;
                         readonly [Symbol.toStringTag]: "Float32Array";
                     };
-                    DefaultInterpolation: import("three").InterpolationModes;
-                    InterpolantFactoryMethodDiscrete: (result: any) => import("three").DiscreteInterpolant;
-                    InterpolantFactoryMethodLinear: (result: any) => import("three").LinearInterpolant;
-                    InterpolantFactoryMethodSmooth: (result: any) => import("three").CubicInterpolant;
-                    setInterpolation: (interpolation: import("three").InterpolationModes) => import("three").KeyframeTrack;
-                    getInterpolation: () => import("three").InterpolationModes;
-                    createInterpolant: () => import("three").Interpolant;
+                    DefaultInterpolation: import('three').InterpolationModes;
+                    InterpolantFactoryMethodDiscrete: (result: any) => import('three').DiscreteInterpolant;
+                    InterpolantFactoryMethodLinear: (result: any) => import('three').LinearInterpolant;
+                    InterpolantFactoryMethodSmooth: (result: any) => import('three').CubicInterpolant;
+                    setInterpolation: (interpolation: import('three').InterpolationModes) => import('three').KeyframeTrack;
+                    getInterpolation: () => import('three').InterpolationModes;
+                    createInterpolant: () => import('three').Interpolant;
                     getValueSize: () => number;
-                    shift: (timeOffset: number) => import("three").KeyframeTrack;
-                    scale: (timeScale: number) => import("three").KeyframeTrack;
-                    trim: (startTime: number, endTime: number) => import("three").KeyframeTrack;
+                    shift: (timeOffset: number) => import('three').KeyframeTrack;
+                    scale: (timeScale: number) => import('three').KeyframeTrack;
+                    trim: (startTime: number, endTime: number) => import('three').KeyframeTrack;
                     validate: () => boolean;
-                    optimize: () => import("three").KeyframeTrack;
-                    clone: () => import("three").KeyframeTrack;
+                    optimize: () => import('three').KeyframeTrack;
+                    clone: () => import('three').KeyframeTrack;
                 }[];
-                blendMode: import("three").AnimationBlendMode;
+                blendMode: import('three').AnimationBlendMode;
                 duration: number;
                 uuid: string;
                 results: any[];
-                resetDuration: () => import("three").AnimationClip;
-                trim: () => import("three").AnimationClip;
+                resetDuration: () => import('three').AnimationClip;
+                trim: () => import('three').AnimationClip;
                 validate: () => boolean;
-                optimize: () => import("three").AnimationClip;
-                clone: () => import("three").AnimationClip;
-                toJSON: (clip: import("three").AnimationClip) => any;
+                optimize: () => import('three').AnimationClip;
+                clone: () => import('three').AnimationClip;
+                toJSON: (clip: import('three').AnimationClip) => any;
             }[];
             userData: Record<string, any>;
             customDepthMaterial?: {
@@ -2497,52 +2533,52 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                     r: number;
                     g: number;
                     b: number;
-                    set: (...args: [color: import("three").ColorRepresentation] | [r: number, g: number, b: number]) => import("three").Color;
-                    setFromVector3: (vector: import("three").Vector3) => import("three").Color;
-                    setScalar: (scalar: number) => import("three").Color;
-                    setHex: (hex: number, colorSpace?: import("three").ColorSpace | undefined) => import("three").Color;
-                    setRGB: (r: number, g: number, b: number, colorSpace?: import("three").ColorSpace | undefined) => import("three").Color;
-                    setHSL: (h: number, s: number, l: number, colorSpace?: import("three").ColorSpace | undefined) => import("three").Color;
-                    setStyle: (style: string, colorSpace?: import("three").ColorSpace | undefined) => import("three").Color;
-                    setColorName: (style: string, colorSpace?: import("three").ColorSpace | undefined) => import("three").Color;
-                    clone: () => import("three").Color;
-                    copy: (color: import("three").Color) => import("three").Color;
-                    copySRGBToLinear: (color: import("three").Color) => import("three").Color;
-                    copyLinearToSRGB: (color: import("three").Color) => import("three").Color;
-                    convertSRGBToLinear: () => import("three").Color;
-                    convertLinearToSRGB: () => import("three").Color;
-                    getHex: (colorSpace?: import("three").ColorSpace | undefined) => number;
-                    getHexString: (colorSpace?: import("three").ColorSpace | undefined) => string;
-                    getHSL: (target: import("three").HSL, colorSpace?: import("three").ColorSpace | undefined) => import("three").HSL;
-                    getRGB: (target: import("three").RGB, colorSpace?: import("three").ColorSpace | undefined) => import("three").RGB;
-                    getStyle: (colorSpace?: import("three").ColorSpace | undefined) => string;
-                    offsetHSL: (h: number, s: number, l: number) => import("three").Color;
-                    add: (color: import("three").Color) => import("three").Color;
-                    addColors: (color1: import("three").Color, color2: import("three").Color) => import("three").Color;
-                    addScalar: (s: number) => import("three").Color;
-                    applyMatrix3: (m: import("three").Matrix3) => import("three").Color;
-                    sub: (color: import("three").Color) => import("three").Color;
-                    multiply: (color: import("three").Color) => import("three").Color;
-                    multiplyScalar: (s: number) => import("three").Color;
-                    lerp: (color: import("three").Color, alpha: number) => import("three").Color;
-                    lerpColors: (color1: import("three").Color, color2: import("three").Color, alpha: number) => import("three").Color;
-                    lerpHSL: (color: import("three").Color, alpha: number) => import("three").Color;
-                    equals: (color: import("three").Color) => boolean;
-                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Color;
+                    set: (...args: [color: import('three').ColorRepresentation] | [r: number, g: number, b: number]) => import('three').Color;
+                    setFromVector3: (vector: import('three').Vector3) => import('three').Color;
+                    setScalar: (scalar: number) => import('three').Color;
+                    setHex: (hex: number, colorSpace?: import('three').ColorSpace) => import('three').Color;
+                    setRGB: (r: number, g: number, b: number, colorSpace?: import('three').ColorSpace) => import('three').Color;
+                    setHSL: (h: number, s: number, l: number, colorSpace?: import('three').ColorSpace) => import('three').Color;
+                    setStyle: (style: string, colorSpace?: import('three').ColorSpace) => import('three').Color;
+                    setColorName: (style: string, colorSpace?: import('three').ColorSpace) => import('three').Color;
+                    clone: () => import('three').Color;
+                    copy: (color: import('three').Color) => import('three').Color;
+                    copySRGBToLinear: (color: import('three').Color) => import('three').Color;
+                    copyLinearToSRGB: (color: import('three').Color) => import('three').Color;
+                    convertSRGBToLinear: () => import('three').Color;
+                    convertLinearToSRGB: () => import('three').Color;
+                    getHex: (colorSpace?: import('three').ColorSpace) => number;
+                    getHexString: (colorSpace?: import('three').ColorSpace) => string;
+                    getHSL: (target: import('three').HSL, colorSpace?: import('three').ColorSpace) => import('three').HSL;
+                    getRGB: (target: import('three').RGB, colorSpace?: import('three').ColorSpace) => import('three').RGB;
+                    getStyle: (colorSpace?: import('three').ColorSpace) => string;
+                    offsetHSL: (h: number, s: number, l: number) => import('three').Color;
+                    add: (color: import('three').Color) => import('three').Color;
+                    addColors: (color1: import('three').Color, color2: import('three').Color) => import('three').Color;
+                    addScalar: (s: number) => import('three').Color;
+                    applyMatrix3: (m: import('three').Matrix3) => import('three').Color;
+                    sub: (color: import('three').Color) => import('three').Color;
+                    multiply: (color: import('three').Color) => import('three').Color;
+                    multiplyScalar: (s: number) => import('three').Color;
+                    lerp: (color: import('three').Color, alpha: number) => import('three').Color;
+                    lerpColors: (color1: import('three').Color, color2: import('three').Color, alpha: number) => import('three').Color;
+                    lerpHSL: (color: import('three').Color, alpha: number) => import('three').Color;
+                    equals: (color: import('three').Color) => boolean;
+                    fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Color;
                     toArray: {
-                        (array?: number[] | undefined, offset?: number | undefined): number[];
-                        (xyz: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
+                        (array?: number[], offset?: number): number[];
+                        (xyz: ArrayLike<number>, offset?: number): ArrayLike<number>;
                     };
                     toJSON: () => number;
-                    fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => import("three").Color;
-                    [Symbol.iterator]: () => Generator<number, void, unknown>;
+                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Color;
+                    [Symbol.iterator]: () => Generator<number, void>;
                 };
-                blendDst: import("three").BlendingDstFactor;
+                blendDst: import('three').BlendingDstFactor;
                 blendDstAlpha: number | null;
-                blendEquation: import("three").BlendingEquation;
+                blendEquation: import('three').BlendingEquation;
                 blendEquationAlpha: number | null;
-                blending: import("three").Blending;
-                blendSrc: 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207 | 208 | 209 | 211 | 212 | 213 | 214 | 210;
+                blending: import('three').Blending;
+                blendSrc: import('three').BlendingSrcFactor | import('three').BlendingDstFactor;
                 blendSrcAlpha: number | null;
                 clipIntersection: boolean;
                 clippingPlanes: {
@@ -2551,125 +2587,125 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                         y: number;
                         z: number;
                         readonly isVector3: true;
-                        set: (x: number, y: number, z: number) => import("three").Vector3;
-                        setScalar: (scalar: number) => import("three").Vector3;
-                        setX: (x: number) => import("three").Vector3;
-                        setY: (y: number) => import("three").Vector3;
-                        setZ: (z: number) => import("three").Vector3;
-                        setComponent: (index: number, value: number) => import("three").Vector3;
+                        set: (x: number, y: number, z: number) => import('three').Vector3;
+                        setScalar: (scalar: number) => import('three').Vector3;
+                        setX: (x: number) => import('three').Vector3;
+                        setY: (y: number) => import('three').Vector3;
+                        setZ: (z: number) => import('three').Vector3;
+                        setComponent: (index: number, value: number) => import('three').Vector3;
                         getComponent: (index: number) => number;
-                        clone: () => import("three").Vector3;
-                        copy: (v: import("three").Vector3Like) => import("three").Vector3;
-                        add: (v: import("three").Vector3Like) => import("three").Vector3;
-                        addScalar: (s: number) => import("three").Vector3;
-                        addVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                        addScaledVector: (v: import("three").Vector3, s: number) => import("three").Vector3;
-                        sub: (a: import("three").Vector3Like) => import("three").Vector3;
-                        subScalar: (s: number) => import("three").Vector3;
-                        subVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                        multiply: (v: import("three").Vector3Like) => import("three").Vector3;
-                        multiplyScalar: (s: number) => import("three").Vector3;
-                        multiplyVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                        applyEuler: (euler: import("three").Euler) => import("three").Vector3;
-                        applyAxisAngle: (axis: import("three").Vector3, angle: number) => import("three").Vector3;
-                        applyMatrix3: (m: import("three").Matrix3) => import("three").Vector3;
-                        applyNormalMatrix: (m: import("three").Matrix3) => import("three").Vector3;
-                        applyMatrix4: (m: import("three").Matrix4) => import("three").Vector3;
-                        applyQuaternion: (q: import("three").QuaternionLike) => import("three").Vector3;
-                        project: (camera: Camera) => import("three").Vector3;
-                        unproject: (camera: Camera) => import("three").Vector3;
-                        transformDirection: (m: import("three").Matrix4) => import("three").Vector3;
-                        divide: (v: import("three").Vector3Like) => import("three").Vector3;
-                        divideScalar: (s: number) => import("three").Vector3;
-                        min: (v: import("three").Vector3Like) => import("three").Vector3;
-                        max: (v: import("three").Vector3Like) => import("three").Vector3;
-                        clamp: (min: import("three").Vector3Like, max: import("three").Vector3Like) => import("three").Vector3;
-                        clampScalar: (min: number, max: number) => import("three").Vector3;
-                        clampLength: (min: number, max: number) => import("three").Vector3;
-                        floor: () => import("three").Vector3;
-                        ceil: () => import("three").Vector3;
-                        round: () => import("three").Vector3;
-                        roundToZero: () => import("three").Vector3;
-                        negate: () => import("three").Vector3;
-                        dot: (v: import("three").Vector3Like) => number;
+                        clone: () => import('three').Vector3;
+                        copy: (v: import('three').Vector3Like) => import('three').Vector3;
+                        add: (v: import('three').Vector3Like) => import('three').Vector3;
+                        addScalar: (s: number) => import('three').Vector3;
+                        addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                        addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
+                        sub: (a: import('three').Vector3Like) => import('three').Vector3;
+                        subScalar: (s: number) => import('three').Vector3;
+                        subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                        multiply: (v: import('three').Vector3Like) => import('three').Vector3;
+                        multiplyScalar: (s: number) => import('three').Vector3;
+                        multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                        applyEuler: (euler: import('three').Euler) => import('three').Vector3;
+                        applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
+                        applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
+                        applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
+                        applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
+                        applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
+                        project: (camera: Camera) => import('three').Vector3;
+                        unproject: (camera: Camera) => import('three').Vector3;
+                        transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
+                        divide: (v: import('three').Vector3Like) => import('three').Vector3;
+                        divideScalar: (s: number) => import('three').Vector3;
+                        min: (v: import('three').Vector3Like) => import('three').Vector3;
+                        max: (v: import('three').Vector3Like) => import('three').Vector3;
+                        clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
+                        clampScalar: (min: number, max: number) => import('three').Vector3;
+                        clampLength: (min: number, max: number) => import('three').Vector3;
+                        floor: () => import('three').Vector3;
+                        ceil: () => import('three').Vector3;
+                        round: () => import('three').Vector3;
+                        roundToZero: () => import('three').Vector3;
+                        negate: () => import('three').Vector3;
+                        dot: (v: import('three').Vector3Like) => number;
                         lengthSq: () => number;
                         length: () => number;
                         manhattanLength: () => number;
-                        normalize: () => import("three").Vector3;
-                        setLength: (l: number) => import("three").Vector3;
-                        lerp: (v: import("three").Vector3Like, alpha: number) => import("three").Vector3;
-                        lerpVectors: (v1: import("three").Vector3Like, v2: import("three").Vector3Like, alpha: number) => import("three").Vector3;
-                        cross: (a: import("three").Vector3Like) => import("three").Vector3;
-                        crossVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                        projectOnVector: (v: import("three").Vector3) => import("three").Vector3;
-                        projectOnPlane: (planeNormal: import("three").Vector3) => import("three").Vector3;
-                        reflect: (vector: import("three").Vector3Like) => import("three").Vector3;
-                        angleTo: (v: import("three").Vector3) => number;
-                        distanceTo: (v: import("three").Vector3Like) => number;
-                        distanceToSquared: (v: import("three").Vector3Like) => number;
-                        manhattanDistanceTo: (v: import("three").Vector3Like) => number;
-                        setFromSpherical: (s: import("three").Spherical) => import("three").Vector3;
-                        setFromSphericalCoords: (r: number, phi: number, theta: number) => import("three").Vector3;
-                        setFromCylindrical: (s: import("three").Cylindrical) => import("three").Vector3;
-                        setFromCylindricalCoords: (radius: number, theta: number, y: number) => import("three").Vector3;
-                        setFromMatrixPosition: (m: import("three").Matrix4) => import("three").Vector3;
-                        setFromMatrixScale: (m: import("three").Matrix4) => import("three").Vector3;
-                        setFromMatrixColumn: (matrix: import("three").Matrix4, index: number) => import("three").Vector3;
-                        setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => import("three").Vector3;
-                        setFromEuler: (e: import("three").Euler) => import("three").Vector3;
-                        setFromColor: (color: import("three").RGB) => import("three").Vector3;
-                        equals: (v: import("three").Vector3Like) => boolean;
-                        fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector3;
+                        normalize: () => import('three').Vector3;
+                        setLength: (l: number) => import('three').Vector3;
+                        lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
+                        lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
+                        cross: (a: import('three').Vector3Like) => import('three').Vector3;
+                        crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                        projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
+                        projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
+                        reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
+                        angleTo: (v: import('three').Vector3) => number;
+                        distanceTo: (v: import('three').Vector3Like) => number;
+                        distanceToSquared: (v: import('three').Vector3Like) => number;
+                        manhattanDistanceTo: (v: import('three').Vector3Like) => number;
+                        setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
+                        setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
+                        setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
+                        setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
+                        setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
+                        setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
+                        setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
+                        setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
+                        setFromEuler: (e: import('three').Euler) => import('three').Vector3;
+                        setFromColor: (color: import('three').RGB) => import('three').Vector3;
+                        equals: (v: import('three').Vector3Like) => boolean;
+                        fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector3;
                         toArray: {
-                            (array?: number[] | undefined, offset?: number | undefined): number[];
-                            (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
-                            (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
+                            (array?: number[], offset?: number): number[];
+                            (array?: import('three').Vector3Tuple, offset?: 0): import('three').Vector3Tuple;
+                            (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                         };
-                        fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => import("three").Vector3;
-                        random: () => import("three").Vector3;
-                        randomDirection: () => import("three").Vector3;
-                        [Symbol.iterator]: () => Iterator<number, any, undefined>;
+                        fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
+                        random: () => import('three').Vector3;
+                        randomDirection: () => import('three').Vector3;
+                        [Symbol.iterator]: () => Iterator<number>;
                     };
                     constant: number;
                     readonly isPlane: true;
-                    set: (normal: import("three").Vector3, constant: number) => import("three").Plane;
-                    setComponents: (x: number, y: number, z: number, w: number) => import("three").Plane;
-                    setFromNormalAndCoplanarPoint: (normal: import("three").Vector3, point: import("three").Vector3) => import("three").Plane;
-                    setFromCoplanarPoints: (a: import("three").Vector3, b: import("three").Vector3, c: import("three").Vector3) => import("three").Plane;
-                    clone: () => import("three").Plane;
-                    copy: (plane: import("three").Plane) => import("three").Plane;
-                    normalize: () => import("three").Plane;
-                    negate: () => import("three").Plane;
-                    distanceToPoint: (point: import("three").Vector3) => number;
-                    distanceToSphere: (sphere: import("three").Sphere) => number;
-                    projectPoint: (point: import("three").Vector3, target: import("three").Vector3) => import("three").Vector3;
-                    intersectLine: (line: import("three").Line3, target: import("three").Vector3) => import("three").Vector3 | null;
-                    intersectsLine: (line: import("three").Line3) => boolean;
-                    intersectsBox: (box: import("three").Box3) => boolean;
-                    intersectsSphere: (sphere: import("three").Sphere) => boolean;
-                    coplanarPoint: (target: import("three").Vector3) => import("three").Vector3;
-                    applyMatrix4: (matrix: import("three").Matrix4, optionalNormalMatrix?: import("three").Matrix3 | undefined) => import("three").Plane;
-                    translate: (offset: import("three").Vector3) => import("three").Plane;
-                    equals: (plane: import("three").Plane) => boolean;
+                    set: (normal: import('three').Vector3, constant: number) => import('three').Plane;
+                    setComponents: (x: number, y: number, z: number, w: number) => import('three').Plane;
+                    setFromNormalAndCoplanarPoint: (normal: import('three').Vector3, point: import('three').Vector3) => import('three').Plane;
+                    setFromCoplanarPoints: (a: import('three').Vector3, b: import('three').Vector3, c: import('three').Vector3) => import('three').Plane;
+                    clone: () => import('three').Plane;
+                    copy: (plane: import('three').Plane) => import('three').Plane;
+                    normalize: () => import('three').Plane;
+                    negate: () => import('three').Plane;
+                    distanceToPoint: (point: import('three').Vector3) => number;
+                    distanceToSphere: (sphere: import('three').Sphere) => number;
+                    projectPoint: (point: import('three').Vector3, target: import('three').Vector3) => import('three').Vector3;
+                    intersectLine: (line: import('three').Line3, target: import('three').Vector3) => import('three').Vector3 | null;
+                    intersectsLine: (line: import('three').Line3) => boolean;
+                    intersectsBox: (box: import('three').Box3) => boolean;
+                    intersectsSphere: (sphere: import('three').Sphere) => boolean;
+                    coplanarPoint: (target: import('three').Vector3) => import('three').Vector3;
+                    applyMatrix4: (matrix: import('three').Matrix4, optionalNormalMatrix?: import('three').Matrix3) => import('three').Plane;
+                    translate: (offset: import('three').Vector3) => import('three').Plane;
+                    equals: (plane: import('three').Plane) => boolean;
                     isIntersectionLine: (l: any) => any;
                 }[] | null;
                 clipShadows: boolean;
                 colorWrite: boolean;
-                defines: {
+                defines: undefined | {
                     [key: string]: any;
-                } | undefined;
-                depthFunc: import("three").DepthModes;
+                };
+                depthFunc: import('three').DepthModes;
                 depthTest: boolean;
                 depthWrite: boolean;
                 id: number;
                 stencilWrite: boolean;
-                stencilFunc: import("three").StencilFunc;
+                stencilFunc: import('three').StencilFunc;
                 stencilRef: number;
                 stencilWriteMask: number;
                 stencilFuncMask: number;
-                stencilFail: import("three").StencilOp;
-                stencilZFail: import("three").StencilOp;
-                stencilZPass: import("three").StencilOp;
+                stencilFail: import('three').StencilOp;
+                stencilZFail: import('three').StencilOp;
+                stencilZPass: import('three').StencilOp;
                 name: string;
                 opacity: number;
                 polygonOffset: boolean;
@@ -2679,8 +2715,8 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                 premultipliedAlpha: boolean;
                 forceSinglePass: boolean;
                 dithering: boolean;
-                side: import("three").Side;
-                shadowSide: import("three").Side | null;
+                side: import('three').Side;
+                shadowSide: import('three').Side | null;
                 toneMapped: boolean;
                 transparent: boolean;
                 type: string;
@@ -2690,37 +2726,37 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                 userData: Record<string, any>;
                 version: number;
                 alphaTest: number;
-                onBuild: (object: import("three").Object3D<import("three").Object3DEventMap>, parameters: import("three").WebGLProgramParametersWithUniforms, renderer: import("three").WebGLRenderer) => void;
-                onBeforeRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: Camera, geometry: import("three").BufferGeometry<import("three").NormalBufferAttributes>, object: import("three").Object3D<import("three").Object3DEventMap>, group: import("three").Group<import("three").Object3DEventMap>) => void;
-                onBeforeCompile: (parameters: import("three").WebGLProgramParametersWithUniforms, renderer: import("three").WebGLRenderer) => void;
+                onBeforeCompile: (parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                 customProgramCacheKey: () => string;
-                setValues: (values: import("three").MaterialParameters) => void;
+                setValues: (values: import('three').MaterialParameters) => void;
                 toJSON: (meta?: any) => any;
-                clone: () => import("three").Material;
-                copy: (material: import("three").Material) => import("three").Material;
+                clone: () => import('three').Material;
+                copy: (material: import('three').Material) => import('three').Material;
                 dispose: () => void;
                 needsUpdate: boolean;
+                onBuild: (object: import('three').Object3D, parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
+                onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry, object: import('three').Object3D, group: import('three').Group) => void;
                 addEventListener: {
-                    <T extends "dispose">(type: T, listener: import("three").EventListener<{
+                    <T extends "dispose">(type: T, listener: import('three').EventListener<{
                         dispose: {};
-                    }[T], T, import("three").Material>): void;
-                    <T_1 extends string>(type: T_1, listener: import("three").EventListener<{}, T_1, import("three").Material>): void;
+                    }[T], T, import('three').Material>): void;
+                    <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Material>): void;
                 };
                 hasEventListener: {
-                    <T_2 extends "dispose">(type: T_2, listener: import("three").EventListener<{
+                    <T extends "dispose">(type: T, listener: import('three').EventListener<{
                         dispose: {};
-                    }[T_2], T_2, import("three").Material>): boolean;
-                    <T_3 extends string>(type: T_3, listener: import("three").EventListener<{}, T_3, import("three").Material>): boolean;
+                    }[T], T, import('three').Material>): boolean;
+                    <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Material>): boolean;
                 };
                 removeEventListener: {
-                    <T_4 extends "dispose">(type: T_4, listener: import("three").EventListener<{
+                    <T extends "dispose">(type: T, listener: import('three').EventListener<{
                         dispose: {};
-                    }[T_4], T_4, import("three").Material>): void;
-                    <T_5 extends string>(type: T_5, listener: import("three").EventListener<{}, T_5, import("three").Material>): void;
+                    }[T], T, import('three').Material>): void;
+                    <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Material>): void;
                 };
-                dispatchEvent: <T_6 extends "dispose">(event: import("three").BaseEvent<T_6> & {
+                dispatchEvent: <T extends "dispose">(event: import('three').BaseEvent<T> & {
                     dispose: {};
-                }[T_6]) => void;
+                }[T]) => void;
             } | undefined;
             customDistanceMaterial?: {
                 readonly isMaterial: true;
@@ -2732,52 +2768,52 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                     r: number;
                     g: number;
                     b: number;
-                    set: (...args: [color: import("three").ColorRepresentation] | [r: number, g: number, b: number]) => import("three").Color;
-                    setFromVector3: (vector: import("three").Vector3) => import("three").Color;
-                    setScalar: (scalar: number) => import("three").Color;
-                    setHex: (hex: number, colorSpace?: import("three").ColorSpace | undefined) => import("three").Color;
-                    setRGB: (r: number, g: number, b: number, colorSpace?: import("three").ColorSpace | undefined) => import("three").Color;
-                    setHSL: (h: number, s: number, l: number, colorSpace?: import("three").ColorSpace | undefined) => import("three").Color;
-                    setStyle: (style: string, colorSpace?: import("three").ColorSpace | undefined) => import("three").Color;
-                    setColorName: (style: string, colorSpace?: import("three").ColorSpace | undefined) => import("three").Color;
-                    clone: () => import("three").Color;
-                    copy: (color: import("three").Color) => import("three").Color;
-                    copySRGBToLinear: (color: import("three").Color) => import("three").Color;
-                    copyLinearToSRGB: (color: import("three").Color) => import("three").Color;
-                    convertSRGBToLinear: () => import("three").Color;
-                    convertLinearToSRGB: () => import("three").Color;
-                    getHex: (colorSpace?: import("three").ColorSpace | undefined) => number;
-                    getHexString: (colorSpace?: import("three").ColorSpace | undefined) => string;
-                    getHSL: (target: import("three").HSL, colorSpace?: import("three").ColorSpace | undefined) => import("three").HSL;
-                    getRGB: (target: import("three").RGB, colorSpace?: import("three").ColorSpace | undefined) => import("three").RGB;
-                    getStyle: (colorSpace?: import("three").ColorSpace | undefined) => string;
-                    offsetHSL: (h: number, s: number, l: number) => import("three").Color;
-                    add: (color: import("three").Color) => import("three").Color;
-                    addColors: (color1: import("three").Color, color2: import("three").Color) => import("three").Color;
-                    addScalar: (s: number) => import("three").Color;
-                    applyMatrix3: (m: import("three").Matrix3) => import("three").Color;
-                    sub: (color: import("three").Color) => import("three").Color;
-                    multiply: (color: import("three").Color) => import("three").Color;
-                    multiplyScalar: (s: number) => import("three").Color;
-                    lerp: (color: import("three").Color, alpha: number) => import("three").Color;
-                    lerpColors: (color1: import("three").Color, color2: import("three").Color, alpha: number) => import("three").Color;
-                    lerpHSL: (color: import("three").Color, alpha: number) => import("three").Color;
-                    equals: (color: import("three").Color) => boolean;
-                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Color;
+                    set: (...args: [color: import('three').ColorRepresentation] | [r: number, g: number, b: number]) => import('three').Color;
+                    setFromVector3: (vector: import('three').Vector3) => import('three').Color;
+                    setScalar: (scalar: number) => import('three').Color;
+                    setHex: (hex: number, colorSpace?: import('three').ColorSpace) => import('three').Color;
+                    setRGB: (r: number, g: number, b: number, colorSpace?: import('three').ColorSpace) => import('three').Color;
+                    setHSL: (h: number, s: number, l: number, colorSpace?: import('three').ColorSpace) => import('three').Color;
+                    setStyle: (style: string, colorSpace?: import('three').ColorSpace) => import('three').Color;
+                    setColorName: (style: string, colorSpace?: import('three').ColorSpace) => import('three').Color;
+                    clone: () => import('three').Color;
+                    copy: (color: import('three').Color) => import('three').Color;
+                    copySRGBToLinear: (color: import('three').Color) => import('three').Color;
+                    copyLinearToSRGB: (color: import('three').Color) => import('three').Color;
+                    convertSRGBToLinear: () => import('three').Color;
+                    convertLinearToSRGB: () => import('three').Color;
+                    getHex: (colorSpace?: import('three').ColorSpace) => number;
+                    getHexString: (colorSpace?: import('three').ColorSpace) => string;
+                    getHSL: (target: import('three').HSL, colorSpace?: import('three').ColorSpace) => import('three').HSL;
+                    getRGB: (target: import('three').RGB, colorSpace?: import('three').ColorSpace) => import('three').RGB;
+                    getStyle: (colorSpace?: import('three').ColorSpace) => string;
+                    offsetHSL: (h: number, s: number, l: number) => import('three').Color;
+                    add: (color: import('three').Color) => import('three').Color;
+                    addColors: (color1: import('three').Color, color2: import('three').Color) => import('three').Color;
+                    addScalar: (s: number) => import('three').Color;
+                    applyMatrix3: (m: import('three').Matrix3) => import('three').Color;
+                    sub: (color: import('three').Color) => import('three').Color;
+                    multiply: (color: import('three').Color) => import('three').Color;
+                    multiplyScalar: (s: number) => import('three').Color;
+                    lerp: (color: import('three').Color, alpha: number) => import('three').Color;
+                    lerpColors: (color1: import('three').Color, color2: import('three').Color, alpha: number) => import('three').Color;
+                    lerpHSL: (color: import('three').Color, alpha: number) => import('three').Color;
+                    equals: (color: import('three').Color) => boolean;
+                    fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Color;
                     toArray: {
-                        (array?: number[] | undefined, offset?: number | undefined): number[];
-                        (xyz: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
+                        (array?: number[], offset?: number): number[];
+                        (xyz: ArrayLike<number>, offset?: number): ArrayLike<number>;
                     };
                     toJSON: () => number;
-                    fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => import("three").Color;
-                    [Symbol.iterator]: () => Generator<number, void, unknown>;
+                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Color;
+                    [Symbol.iterator]: () => Generator<number, void>;
                 };
-                blendDst: import("three").BlendingDstFactor;
+                blendDst: import('three').BlendingDstFactor;
                 blendDstAlpha: number | null;
-                blendEquation: import("three").BlendingEquation;
+                blendEquation: import('three').BlendingEquation;
                 blendEquationAlpha: number | null;
-                blending: import("three").Blending;
-                blendSrc: 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207 | 208 | 209 | 211 | 212 | 213 | 214 | 210;
+                blending: import('three').Blending;
+                blendSrc: import('three').BlendingSrcFactor | import('three').BlendingDstFactor;
                 blendSrcAlpha: number | null;
                 clipIntersection: boolean;
                 clippingPlanes: {
@@ -2786,125 +2822,125 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                         y: number;
                         z: number;
                         readonly isVector3: true;
-                        set: (x: number, y: number, z: number) => import("three").Vector3;
-                        setScalar: (scalar: number) => import("three").Vector3;
-                        setX: (x: number) => import("three").Vector3;
-                        setY: (y: number) => import("three").Vector3;
-                        setZ: (z: number) => import("three").Vector3;
-                        setComponent: (index: number, value: number) => import("three").Vector3;
+                        set: (x: number, y: number, z: number) => import('three').Vector3;
+                        setScalar: (scalar: number) => import('three').Vector3;
+                        setX: (x: number) => import('three').Vector3;
+                        setY: (y: number) => import('three').Vector3;
+                        setZ: (z: number) => import('three').Vector3;
+                        setComponent: (index: number, value: number) => import('three').Vector3;
                         getComponent: (index: number) => number;
-                        clone: () => import("three").Vector3;
-                        copy: (v: import("three").Vector3Like) => import("three").Vector3;
-                        add: (v: import("three").Vector3Like) => import("three").Vector3;
-                        addScalar: (s: number) => import("three").Vector3;
-                        addVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                        addScaledVector: (v: import("three").Vector3, s: number) => import("three").Vector3;
-                        sub: (a: import("three").Vector3Like) => import("three").Vector3;
-                        subScalar: (s: number) => import("three").Vector3;
-                        subVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                        multiply: (v: import("three").Vector3Like) => import("three").Vector3;
-                        multiplyScalar: (s: number) => import("three").Vector3;
-                        multiplyVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                        applyEuler: (euler: import("three").Euler) => import("three").Vector3;
-                        applyAxisAngle: (axis: import("three").Vector3, angle: number) => import("three").Vector3;
-                        applyMatrix3: (m: import("three").Matrix3) => import("three").Vector3;
-                        applyNormalMatrix: (m: import("three").Matrix3) => import("three").Vector3;
-                        applyMatrix4: (m: import("three").Matrix4) => import("three").Vector3;
-                        applyQuaternion: (q: import("three").QuaternionLike) => import("three").Vector3;
-                        project: (camera: Camera) => import("three").Vector3;
-                        unproject: (camera: Camera) => import("three").Vector3;
-                        transformDirection: (m: import("three").Matrix4) => import("three").Vector3;
-                        divide: (v: import("three").Vector3Like) => import("three").Vector3;
-                        divideScalar: (s: number) => import("three").Vector3;
-                        min: (v: import("three").Vector3Like) => import("three").Vector3;
-                        max: (v: import("three").Vector3Like) => import("three").Vector3;
-                        clamp: (min: import("three").Vector3Like, max: import("three").Vector3Like) => import("three").Vector3;
-                        clampScalar: (min: number, max: number) => import("three").Vector3;
-                        clampLength: (min: number, max: number) => import("three").Vector3;
-                        floor: () => import("three").Vector3;
-                        ceil: () => import("three").Vector3;
-                        round: () => import("three").Vector3;
-                        roundToZero: () => import("three").Vector3;
-                        negate: () => import("three").Vector3;
-                        dot: (v: import("three").Vector3Like) => number;
+                        clone: () => import('three').Vector3;
+                        copy: (v: import('three').Vector3Like) => import('three').Vector3;
+                        add: (v: import('three').Vector3Like) => import('three').Vector3;
+                        addScalar: (s: number) => import('three').Vector3;
+                        addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                        addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
+                        sub: (a: import('three').Vector3Like) => import('three').Vector3;
+                        subScalar: (s: number) => import('three').Vector3;
+                        subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                        multiply: (v: import('three').Vector3Like) => import('three').Vector3;
+                        multiplyScalar: (s: number) => import('three').Vector3;
+                        multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                        applyEuler: (euler: import('three').Euler) => import('three').Vector3;
+                        applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
+                        applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
+                        applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
+                        applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
+                        applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
+                        project: (camera: Camera) => import('three').Vector3;
+                        unproject: (camera: Camera) => import('three').Vector3;
+                        transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
+                        divide: (v: import('three').Vector3Like) => import('three').Vector3;
+                        divideScalar: (s: number) => import('three').Vector3;
+                        min: (v: import('three').Vector3Like) => import('three').Vector3;
+                        max: (v: import('three').Vector3Like) => import('three').Vector3;
+                        clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
+                        clampScalar: (min: number, max: number) => import('three').Vector3;
+                        clampLength: (min: number, max: number) => import('three').Vector3;
+                        floor: () => import('three').Vector3;
+                        ceil: () => import('three').Vector3;
+                        round: () => import('three').Vector3;
+                        roundToZero: () => import('three').Vector3;
+                        negate: () => import('three').Vector3;
+                        dot: (v: import('three').Vector3Like) => number;
                         lengthSq: () => number;
                         length: () => number;
                         manhattanLength: () => number;
-                        normalize: () => import("three").Vector3;
-                        setLength: (l: number) => import("three").Vector3;
-                        lerp: (v: import("three").Vector3Like, alpha: number) => import("three").Vector3;
-                        lerpVectors: (v1: import("three").Vector3Like, v2: import("three").Vector3Like, alpha: number) => import("three").Vector3;
-                        cross: (a: import("three").Vector3Like) => import("three").Vector3;
-                        crossVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                        projectOnVector: (v: import("three").Vector3) => import("three").Vector3;
-                        projectOnPlane: (planeNormal: import("three").Vector3) => import("three").Vector3;
-                        reflect: (vector: import("three").Vector3Like) => import("three").Vector3;
-                        angleTo: (v: import("three").Vector3) => number;
-                        distanceTo: (v: import("three").Vector3Like) => number;
-                        distanceToSquared: (v: import("three").Vector3Like) => number;
-                        manhattanDistanceTo: (v: import("three").Vector3Like) => number;
-                        setFromSpherical: (s: import("three").Spherical) => import("three").Vector3;
-                        setFromSphericalCoords: (r: number, phi: number, theta: number) => import("three").Vector3;
-                        setFromCylindrical: (s: import("three").Cylindrical) => import("three").Vector3;
-                        setFromCylindricalCoords: (radius: number, theta: number, y: number) => import("three").Vector3;
-                        setFromMatrixPosition: (m: import("three").Matrix4) => import("three").Vector3;
-                        setFromMatrixScale: (m: import("three").Matrix4) => import("three").Vector3;
-                        setFromMatrixColumn: (matrix: import("three").Matrix4, index: number) => import("three").Vector3;
-                        setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => import("three").Vector3;
-                        setFromEuler: (e: import("three").Euler) => import("three").Vector3;
-                        setFromColor: (color: import("three").RGB) => import("three").Vector3;
-                        equals: (v: import("three").Vector3Like) => boolean;
-                        fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector3;
+                        normalize: () => import('three').Vector3;
+                        setLength: (l: number) => import('three').Vector3;
+                        lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
+                        lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
+                        cross: (a: import('three').Vector3Like) => import('three').Vector3;
+                        crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                        projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
+                        projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
+                        reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
+                        angleTo: (v: import('three').Vector3) => number;
+                        distanceTo: (v: import('three').Vector3Like) => number;
+                        distanceToSquared: (v: import('three').Vector3Like) => number;
+                        manhattanDistanceTo: (v: import('three').Vector3Like) => number;
+                        setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
+                        setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
+                        setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
+                        setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
+                        setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
+                        setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
+                        setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
+                        setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
+                        setFromEuler: (e: import('three').Euler) => import('three').Vector3;
+                        setFromColor: (color: import('three').RGB) => import('three').Vector3;
+                        equals: (v: import('three').Vector3Like) => boolean;
+                        fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector3;
                         toArray: {
-                            (array?: number[] | undefined, offset?: number | undefined): number[];
-                            (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
-                            (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
+                            (array?: number[], offset?: number): number[];
+                            (array?: import('three').Vector3Tuple, offset?: 0): import('three').Vector3Tuple;
+                            (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                         };
-                        fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => import("three").Vector3;
-                        random: () => import("three").Vector3;
-                        randomDirection: () => import("three").Vector3;
-                        [Symbol.iterator]: () => Iterator<number, any, undefined>;
+                        fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
+                        random: () => import('three').Vector3;
+                        randomDirection: () => import('three').Vector3;
+                        [Symbol.iterator]: () => Iterator<number>;
                     };
                     constant: number;
                     readonly isPlane: true;
-                    set: (normal: import("three").Vector3, constant: number) => import("three").Plane;
-                    setComponents: (x: number, y: number, z: number, w: number) => import("three").Plane;
-                    setFromNormalAndCoplanarPoint: (normal: import("three").Vector3, point: import("three").Vector3) => import("three").Plane;
-                    setFromCoplanarPoints: (a: import("three").Vector3, b: import("three").Vector3, c: import("three").Vector3) => import("three").Plane;
-                    clone: () => import("three").Plane;
-                    copy: (plane: import("three").Plane) => import("three").Plane;
-                    normalize: () => import("three").Plane;
-                    negate: () => import("three").Plane;
-                    distanceToPoint: (point: import("three").Vector3) => number;
-                    distanceToSphere: (sphere: import("three").Sphere) => number;
-                    projectPoint: (point: import("three").Vector3, target: import("three").Vector3) => import("three").Vector3;
-                    intersectLine: (line: import("three").Line3, target: import("three").Vector3) => import("three").Vector3 | null;
-                    intersectsLine: (line: import("three").Line3) => boolean;
-                    intersectsBox: (box: import("three").Box3) => boolean;
-                    intersectsSphere: (sphere: import("three").Sphere) => boolean;
-                    coplanarPoint: (target: import("three").Vector3) => import("three").Vector3;
-                    applyMatrix4: (matrix: import("three").Matrix4, optionalNormalMatrix?: import("three").Matrix3 | undefined) => import("three").Plane;
-                    translate: (offset: import("three").Vector3) => import("three").Plane;
-                    equals: (plane: import("three").Plane) => boolean;
+                    set: (normal: import('three').Vector3, constant: number) => import('three').Plane;
+                    setComponents: (x: number, y: number, z: number, w: number) => import('three').Plane;
+                    setFromNormalAndCoplanarPoint: (normal: import('three').Vector3, point: import('three').Vector3) => import('three').Plane;
+                    setFromCoplanarPoints: (a: import('three').Vector3, b: import('three').Vector3, c: import('three').Vector3) => import('three').Plane;
+                    clone: () => import('three').Plane;
+                    copy: (plane: import('three').Plane) => import('three').Plane;
+                    normalize: () => import('three').Plane;
+                    negate: () => import('three').Plane;
+                    distanceToPoint: (point: import('three').Vector3) => number;
+                    distanceToSphere: (sphere: import('three').Sphere) => number;
+                    projectPoint: (point: import('three').Vector3, target: import('three').Vector3) => import('three').Vector3;
+                    intersectLine: (line: import('three').Line3, target: import('three').Vector3) => import('three').Vector3 | null;
+                    intersectsLine: (line: import('three').Line3) => boolean;
+                    intersectsBox: (box: import('three').Box3) => boolean;
+                    intersectsSphere: (sphere: import('three').Sphere) => boolean;
+                    coplanarPoint: (target: import('three').Vector3) => import('three').Vector3;
+                    applyMatrix4: (matrix: import('three').Matrix4, optionalNormalMatrix?: import('three').Matrix3) => import('three').Plane;
+                    translate: (offset: import('three').Vector3) => import('three').Plane;
+                    equals: (plane: import('three').Plane) => boolean;
                     isIntersectionLine: (l: any) => any;
                 }[] | null;
                 clipShadows: boolean;
                 colorWrite: boolean;
-                defines: {
+                defines: undefined | {
                     [key: string]: any;
-                } | undefined;
-                depthFunc: import("three").DepthModes;
+                };
+                depthFunc: import('three').DepthModes;
                 depthTest: boolean;
                 depthWrite: boolean;
                 id: number;
                 stencilWrite: boolean;
-                stencilFunc: import("three").StencilFunc;
+                stencilFunc: import('three').StencilFunc;
                 stencilRef: number;
                 stencilWriteMask: number;
                 stencilFuncMask: number;
-                stencilFail: import("three").StencilOp;
-                stencilZFail: import("three").StencilOp;
-                stencilZPass: import("three").StencilOp;
+                stencilFail: import('three').StencilOp;
+                stencilZFail: import('three').StencilOp;
+                stencilZPass: import('three').StencilOp;
                 name: string;
                 opacity: number;
                 polygonOffset: boolean;
@@ -2914,8 +2950,8 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                 premultipliedAlpha: boolean;
                 forceSinglePass: boolean;
                 dithering: boolean;
-                side: import("three").Side;
-                shadowSide: import("three").Side | null;
+                side: import('three').Side;
+                shadowSide: import('three').Side | null;
                 toneMapped: boolean;
                 transparent: boolean;
                 type: string;
@@ -2925,292 +2961,292 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                 userData: Record<string, any>;
                 version: number;
                 alphaTest: number;
-                onBuild: (object: import("three").Object3D<import("three").Object3DEventMap>, parameters: import("three").WebGLProgramParametersWithUniforms, renderer: import("three").WebGLRenderer) => void;
-                onBeforeRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: Camera, geometry: import("three").BufferGeometry<import("three").NormalBufferAttributes>, object: import("three").Object3D<import("three").Object3DEventMap>, group: import("three").Group<import("three").Object3DEventMap>) => void;
-                onBeforeCompile: (parameters: import("three").WebGLProgramParametersWithUniforms, renderer: import("three").WebGLRenderer) => void;
+                onBeforeCompile: (parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                 customProgramCacheKey: () => string;
-                setValues: (values: import("three").MaterialParameters) => void;
+                setValues: (values: import('three').MaterialParameters) => void;
                 toJSON: (meta?: any) => any;
-                clone: () => import("three").Material;
-                copy: (material: import("three").Material) => import("three").Material;
+                clone: () => import('three').Material;
+                copy: (material: import('three').Material) => import('three').Material;
                 dispose: () => void;
                 needsUpdate: boolean;
+                onBuild: (object: import('three').Object3D, parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
+                onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry, object: import('three').Object3D, group: import('three').Group) => void;
                 addEventListener: {
-                    <T extends "dispose">(type: T, listener: import("three").EventListener<{
+                    <T extends "dispose">(type: T, listener: import('three').EventListener<{
                         dispose: {};
-                    }[T], T, import("three").Material>): void;
-                    <T_1 extends string>(type: T_1, listener: import("three").EventListener<{}, T_1, import("three").Material>): void;
+                    }[T], T, import('three').Material>): void;
+                    <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Material>): void;
                 };
                 hasEventListener: {
-                    <T_2 extends "dispose">(type: T_2, listener: import("three").EventListener<{
+                    <T extends "dispose">(type: T, listener: import('three').EventListener<{
                         dispose: {};
-                    }[T_2], T_2, import("three").Material>): boolean;
-                    <T_3 extends string>(type: T_3, listener: import("three").EventListener<{}, T_3, import("three").Material>): boolean;
+                    }[T], T, import('three').Material>): boolean;
+                    <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Material>): boolean;
                 };
                 removeEventListener: {
-                    <T_4 extends "dispose">(type: T_4, listener: import("three").EventListener<{
+                    <T extends "dispose">(type: T, listener: import('three').EventListener<{
                         dispose: {};
-                    }[T_4], T_4, import("three").Material>): void;
-                    <T_5 extends string>(type: T_5, listener: import("three").EventListener<{}, T_5, import("three").Material>): void;
+                    }[T], T, import('three').Material>): void;
+                    <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Material>): void;
                 };
-                dispatchEvent: <T_6 extends "dispose">(event: import("three").BaseEvent<T_6> & {
+                dispatchEvent: <T extends "dispose">(event: import('three').BaseEvent<T> & {
                     dispose: {};
-                }[T_6]) => void;
+                }[T]) => void;
             } | undefined;
-            onBeforeShadow: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, shadowCamera: Camera, geometry: import("three").BufferGeometry<import("three").NormalBufferAttributes>, depthMaterial: import("three").Material, group: import("three").Group<import("three").Object3DEventMap>) => void;
-            onAfterShadow: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, shadowCamera: Camera, geometry: import("three").BufferGeometry<import("three").NormalBufferAttributes>, depthMaterial: import("three").Material, group: import("three").Group<import("three").Object3DEventMap>) => void;
-            onBeforeRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: Camera, geometry: import("three").BufferGeometry<import("three").NormalBufferAttributes>, material: import("three").Material, group: import("three").Group<import("three").Object3DEventMap>) => void;
-            onAfterRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: Camera, geometry: import("three").BufferGeometry<import("three").NormalBufferAttributes>, material: import("three").Material, group: import("three").Group<import("three").Object3DEventMap>) => void;
-            applyMatrix4: (matrix: import("three").Matrix4) => void;
-            applyQuaternion: (quaternion: import("three").Quaternion) => import("three").Object3D<import("three").Object3DEventMap>;
-            setRotationFromAxisAngle: (axis: import("three").Vector3, angle: number) => void;
-            setRotationFromEuler: (euler: import("three").Euler) => void;
-            setRotationFromMatrix: (m: import("three").Matrix4) => void;
-            setRotationFromQuaternion: (q: import("three").Quaternion) => void;
-            rotateOnAxis: (axis: import("three").Vector3, angle: number) => import("three").Object3D<import("three").Object3DEventMap>;
-            rotateOnWorldAxis: (axis: import("three").Vector3, angle: number) => import("three").Object3D<import("three").Object3DEventMap>;
-            rotateX: (angle: number) => import("three").Object3D<import("three").Object3DEventMap>;
-            rotateY: (angle: number) => import("three").Object3D<import("three").Object3DEventMap>;
-            rotateZ: (angle: number) => import("three").Object3D<import("three").Object3DEventMap>;
-            translateOnAxis: (axis: import("three").Vector3, distance: number) => import("three").Object3D<import("three").Object3DEventMap>;
-            translateX: (distance: number) => import("three").Object3D<import("three").Object3DEventMap>;
-            translateY: (distance: number) => import("three").Object3D<import("three").Object3DEventMap>;
-            translateZ: (distance: number) => import("three").Object3D<import("three").Object3DEventMap>;
-            localToWorld: (vector: import("three").Vector3) => import("three").Vector3;
-            worldToLocal: (vector: import("three").Vector3) => import("three").Vector3;
+            onBeforeShadow: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, shadowCamera: Camera, geometry: import('three').BufferGeometry, depthMaterial: import('three').Material, group: import('three').Group) => void;
+            onAfterShadow: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, shadowCamera: Camera, geometry: import('three').BufferGeometry, depthMaterial: import('three').Material, group: import('three').Group) => void;
+            onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry, material: import('three').Material, group: import('three').Group) => void;
+            onAfterRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry, material: import('three').Material, group: import('three').Group) => void;
+            applyMatrix4: (matrix: import('three').Matrix4) => void;
+            applyQuaternion: (quaternion: import('three').Quaternion) => import('three').Object3D<import('three').Object3DEventMap>;
+            setRotationFromAxisAngle: (axis: import('three').Vector3, angle: number) => void;
+            setRotationFromEuler: (euler: import('three').Euler) => void;
+            setRotationFromMatrix: (m: import('three').Matrix4) => void;
+            setRotationFromQuaternion: (q: import('three').Quaternion) => void;
+            rotateOnAxis: (axis: import('three').Vector3, angle: number) => import('three').Object3D<import('three').Object3DEventMap>;
+            rotateOnWorldAxis: (axis: import('three').Vector3, angle: number) => import('three').Object3D<import('three').Object3DEventMap>;
+            rotateX: (angle: number) => import('three').Object3D<import('three').Object3DEventMap>;
+            rotateY: (angle: number) => import('three').Object3D<import('three').Object3DEventMap>;
+            rotateZ: (angle: number) => import('three').Object3D<import('three').Object3DEventMap>;
+            translateOnAxis: (axis: import('three').Vector3, distance: number) => import('three').Object3D<import('three').Object3DEventMap>;
+            translateX: (distance: number) => import('three').Object3D<import('three').Object3DEventMap>;
+            translateY: (distance: number) => import('three').Object3D<import('three').Object3DEventMap>;
+            translateZ: (distance: number) => import('three').Object3D<import('three').Object3DEventMap>;
+            localToWorld: (vector: import('three').Vector3) => import('three').Vector3;
+            worldToLocal: (vector: import('three').Vector3) => import('three').Vector3;
             lookAt: {
-                (vector: import("three").Vector3): void;
+                (vector: import('three').Vector3): void;
                 (x: number, y: number, z: number): void;
             };
-            add: (...object: import("three").Object3D<import("three").Object3DEventMap>[]) => import("three").Object3D<import("three").Object3DEventMap>;
-            remove: (...object: import("three").Object3D<import("three").Object3DEventMap>[]) => import("three").Object3D<import("three").Object3DEventMap>;
-            removeFromParent: () => import("three").Object3D<import("three").Object3DEventMap>;
-            clear: () => import("three").Object3D<import("three").Object3DEventMap>;
-            attach: (object: import("three").Object3D<import("three").Object3DEventMap>) => import("three").Object3D<import("three").Object3DEventMap>;
-            getObjectById: (id: number) => import("three").Object3D<import("three").Object3DEventMap> | undefined;
-            getObjectByName: (name: string) => import("three").Object3D<import("three").Object3DEventMap> | undefined;
-            getObjectByProperty: (name: string, value: any) => import("three").Object3D<import("three").Object3DEventMap> | undefined;
-            getObjectsByProperty: (name: string, value: any, optionalTarget?: import("three").Object3D<import("three").Object3DEventMap>[] | undefined) => import("three").Object3D<import("three").Object3DEventMap>[];
-            getWorldPosition: (target: import("three").Vector3) => import("three").Vector3;
-            getWorldQuaternion: (target: import("three").Quaternion) => import("three").Quaternion;
-            getWorldScale: (target: import("three").Vector3) => import("three").Vector3;
-            getWorldDirection: (target: import("three").Vector3) => import("three").Vector3;
-            raycast: (raycaster: import("three").Raycaster, intersects: import("three").Intersection<import("three").Object3D<import("three").Object3DEventMap>>[]) => void;
-            traverse: (callback: (object: import("three").Object3D<import("three").Object3DEventMap>) => any) => void;
-            traverseVisible: (callback: (object: import("three").Object3D<import("three").Object3DEventMap>) => any) => void;
-            traverseAncestors: (callback: (object: import("three").Object3D<import("three").Object3DEventMap>) => any) => void;
+            add: (...object: import('three').Object3D[]) => import('three').Object3D<import('three').Object3DEventMap>;
+            remove: (...object: import('three').Object3D[]) => import('three').Object3D<import('three').Object3DEventMap>;
+            removeFromParent: () => import('three').Object3D<import('three').Object3DEventMap>;
+            clear: () => import('three').Object3D<import('three').Object3DEventMap>;
+            attach: (object: import('three').Object3D) => import('three').Object3D<import('three').Object3DEventMap>;
+            getObjectById: (id: number) => import('three').Object3D | undefined;
+            getObjectByName: (name: string) => import('three').Object3D | undefined;
+            getObjectByProperty: (name: string, value: any) => import('three').Object3D | undefined;
+            getObjectsByProperty: (name: string, value: any, optionalTarget?: import('three').Object3D[]) => import('three').Object3D[];
+            getWorldPosition: (target: import('three').Vector3) => import('three').Vector3;
+            getWorldQuaternion: (target: import('three').Quaternion) => import('three').Quaternion;
+            getWorldScale: (target: import('three').Vector3) => import('three').Vector3;
+            getWorldDirection: (target: import('three').Vector3) => import('three').Vector3;
+            raycast: (raycaster: import('three').Raycaster, intersects: import('three').Intersection[]) => void;
+            traverse: (callback: (object: import('three').Object3D) => any) => void;
+            traverseVisible: (callback: (object: import('three').Object3D) => any) => void;
+            traverseAncestors: (callback: (object: import('three').Object3D) => any) => void;
             updateMatrix: () => void;
-            updateMatrixWorld: (force?: boolean | undefined) => void;
+            updateMatrixWorld: (force?: boolean) => void;
             updateWorldMatrix: (updateParents: boolean, updateChildren: boolean) => void;
             toJSON: (meta?: {
                 geometries: any;
                 materials: any;
                 textures: any;
                 images: any;
-            } | undefined) => any;
-            clone: (recursive?: boolean | undefined) => import("three").Object3D<import("three").Object3DEventMap>;
-            copy: (source: import("three").Object3D<import("three").Object3DEventMap>, recursive?: boolean | undefined) => import("three").Object3D<import("three").Object3DEventMap>;
+            }) => any;
+            clone: (recursive?: boolean) => import('three').Object3D<import('three').Object3DEventMap>;
+            copy: (object: import('three').Object3D, recursive?: boolean) => import('three').Object3D<import('three').Object3DEventMap>;
             addEventListener: {
-                <T_7 extends keyof import("three").Object3DEventMap>(type: T_7, listener: import("three").EventListener<import("three").Object3DEventMap[T_7], T_7, import("three").Object3D<import("three").Object3DEventMap>>): void;
-                <T_8 extends string>(type: T_8, listener: import("three").EventListener<{}, T_8, import("three").Object3D<import("three").Object3DEventMap>>): void;
+                <T extends keyof import('three').Object3DEventMap>(type: T, listener: import('three').EventListener<import('three').Object3DEventMap[T], T, import('three').Object3D<import('three').Object3DEventMap>>): void;
+                <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Object3D<import('three').Object3DEventMap>>): void;
             };
             hasEventListener: {
-                <T_9 extends keyof import("three").Object3DEventMap>(type: T_9, listener: import("three").EventListener<import("three").Object3DEventMap[T_9], T_9, import("three").Object3D<import("three").Object3DEventMap>>): boolean;
-                <T_10 extends string>(type: T_10, listener: import("three").EventListener<{}, T_10, import("three").Object3D<import("three").Object3DEventMap>>): boolean;
+                <T extends keyof import('three').Object3DEventMap>(type: T, listener: import('three').EventListener<import('three').Object3DEventMap[T], T, import('three').Object3D<import('three').Object3DEventMap>>): boolean;
+                <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Object3D<import('three').Object3DEventMap>>): boolean;
             };
             removeEventListener: {
-                <T_11 extends keyof import("three").Object3DEventMap>(type: T_11, listener: import("three").EventListener<import("three").Object3DEventMap[T_11], T_11, import("three").Object3D<import("three").Object3DEventMap>>): void;
-                <T_12 extends string>(type: T_12, listener: import("three").EventListener<{}, T_12, import("three").Object3D<import("three").Object3DEventMap>>): void;
+                <T extends keyof import('three').Object3DEventMap>(type: T, listener: import('three').EventListener<import('three').Object3DEventMap[T], T, import('three').Object3D<import('three').Object3DEventMap>>): void;
+                <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Object3D<import('three').Object3DEventMap>>): void;
             };
-            dispatchEvent: <T_13 extends keyof import("three").Object3DEventMap>(event: import("three").BaseEvent<T_13> & import("three").Object3DEventMap[T_13]) => void;
+            dispatchEvent: <T extends keyof import('three').Object3DEventMap>(event: import('three').BaseEvent<T> & import('three').Object3DEventMap[T]) => void;
         }[];
         up: {
             x: number;
             y: number;
             z: number;
             readonly isVector3: true;
-            set: (x: number, y: number, z: number) => import("three").Vector3;
-            setScalar: (scalar: number) => import("three").Vector3;
-            setX: (x: number) => import("three").Vector3;
-            setY: (y: number) => import("three").Vector3;
-            setZ: (z: number) => import("three").Vector3;
-            setComponent: (index: number, value: number) => import("three").Vector3;
+            set: (x: number, y: number, z: number) => import('three').Vector3;
+            setScalar: (scalar: number) => import('three').Vector3;
+            setX: (x: number) => import('three').Vector3;
+            setY: (y: number) => import('three').Vector3;
+            setZ: (z: number) => import('three').Vector3;
+            setComponent: (index: number, value: number) => import('three').Vector3;
             getComponent: (index: number) => number;
-            clone: () => import("three").Vector3;
-            copy: (v: import("three").Vector3Like) => import("three").Vector3;
-            add: (v: import("three").Vector3Like) => import("three").Vector3;
-            addScalar: (s: number) => import("three").Vector3;
-            addVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-            addScaledVector: (v: import("three").Vector3, s: number) => import("three").Vector3;
-            sub: (a: import("three").Vector3Like) => import("three").Vector3;
-            subScalar: (s: number) => import("three").Vector3;
-            subVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-            multiply: (v: import("three").Vector3Like) => import("three").Vector3;
-            multiplyScalar: (s: number) => import("three").Vector3;
-            multiplyVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-            applyEuler: (euler: import("three").Euler) => import("three").Vector3;
-            applyAxisAngle: (axis: import("three").Vector3, angle: number) => import("three").Vector3;
-            applyMatrix3: (m: import("three").Matrix3) => import("three").Vector3;
-            applyNormalMatrix: (m: import("three").Matrix3) => import("three").Vector3;
-            applyMatrix4: (m: import("three").Matrix4) => import("three").Vector3;
-            applyQuaternion: (q: import("three").QuaternionLike) => import("three").Vector3;
-            project: (camera: Camera) => import("three").Vector3;
-            unproject: (camera: Camera) => import("three").Vector3;
-            transformDirection: (m: import("three").Matrix4) => import("three").Vector3;
-            divide: (v: import("three").Vector3Like) => import("three").Vector3;
-            divideScalar: (s: number) => import("three").Vector3;
-            min: (v: import("three").Vector3Like) => import("three").Vector3;
-            max: (v: import("three").Vector3Like) => import("three").Vector3;
-            clamp: (min: import("three").Vector3Like, max: import("three").Vector3Like) => import("three").Vector3;
-            clampScalar: (min: number, max: number) => import("three").Vector3;
-            clampLength: (min: number, max: number) => import("three").Vector3;
-            floor: () => import("three").Vector3;
-            ceil: () => import("three").Vector3;
-            round: () => import("three").Vector3;
-            roundToZero: () => import("three").Vector3;
-            negate: () => import("three").Vector3;
-            dot: (v: import("three").Vector3Like) => number;
+            clone: () => import('three').Vector3;
+            copy: (v: import('three').Vector3Like) => import('three').Vector3;
+            add: (v: import('three').Vector3Like) => import('three').Vector3;
+            addScalar: (s: number) => import('three').Vector3;
+            addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+            addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
+            sub: (a: import('three').Vector3Like) => import('three').Vector3;
+            subScalar: (s: number) => import('three').Vector3;
+            subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+            multiply: (v: import('three').Vector3Like) => import('three').Vector3;
+            multiplyScalar: (s: number) => import('three').Vector3;
+            multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+            applyEuler: (euler: import('three').Euler) => import('three').Vector3;
+            applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
+            applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
+            applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
+            applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
+            applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
+            project: (camera: Camera) => import('three').Vector3;
+            unproject: (camera: Camera) => import('three').Vector3;
+            transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
+            divide: (v: import('three').Vector3Like) => import('three').Vector3;
+            divideScalar: (s: number) => import('three').Vector3;
+            min: (v: import('three').Vector3Like) => import('three').Vector3;
+            max: (v: import('three').Vector3Like) => import('three').Vector3;
+            clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
+            clampScalar: (min: number, max: number) => import('three').Vector3;
+            clampLength: (min: number, max: number) => import('three').Vector3;
+            floor: () => import('three').Vector3;
+            ceil: () => import('three').Vector3;
+            round: () => import('three').Vector3;
+            roundToZero: () => import('three').Vector3;
+            negate: () => import('three').Vector3;
+            dot: (v: import('three').Vector3Like) => number;
             lengthSq: () => number;
             length: () => number;
             manhattanLength: () => number;
-            normalize: () => import("three").Vector3;
-            setLength: (l: number) => import("three").Vector3;
-            lerp: (v: import("three").Vector3Like, alpha: number) => import("three").Vector3;
-            lerpVectors: (v1: import("three").Vector3Like, v2: import("three").Vector3Like, alpha: number) => import("three").Vector3;
-            cross: (a: import("three").Vector3Like) => import("three").Vector3;
-            crossVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-            projectOnVector: (v: import("three").Vector3) => import("three").Vector3;
-            projectOnPlane: (planeNormal: import("three").Vector3) => import("three").Vector3;
-            reflect: (vector: import("three").Vector3Like) => import("three").Vector3;
-            angleTo: (v: import("three").Vector3) => number;
-            distanceTo: (v: import("three").Vector3Like) => number;
-            distanceToSquared: (v: import("three").Vector3Like) => number;
-            manhattanDistanceTo: (v: import("three").Vector3Like) => number;
-            setFromSpherical: (s: import("three").Spherical) => import("three").Vector3;
-            setFromSphericalCoords: (r: number, phi: number, theta: number) => import("three").Vector3;
-            setFromCylindrical: (s: import("three").Cylindrical) => import("three").Vector3;
-            setFromCylindricalCoords: (radius: number, theta: number, y: number) => import("three").Vector3;
-            setFromMatrixPosition: (m: import("three").Matrix4) => import("three").Vector3;
-            setFromMatrixScale: (m: import("three").Matrix4) => import("three").Vector3;
-            setFromMatrixColumn: (matrix: import("three").Matrix4, index: number) => import("three").Vector3;
-            setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => import("three").Vector3;
-            setFromEuler: (e: import("three").Euler) => import("three").Vector3;
-            setFromColor: (color: import("three").RGB) => import("three").Vector3;
-            equals: (v: import("three").Vector3Like) => boolean;
-            fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector3;
+            normalize: () => import('three').Vector3;
+            setLength: (l: number) => import('three').Vector3;
+            lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
+            lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
+            cross: (a: import('three').Vector3Like) => import('three').Vector3;
+            crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+            projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
+            projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
+            reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
+            angleTo: (v: import('three').Vector3) => number;
+            distanceTo: (v: import('three').Vector3Like) => number;
+            distanceToSquared: (v: import('three').Vector3Like) => number;
+            manhattanDistanceTo: (v: import('three').Vector3Like) => number;
+            setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
+            setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
+            setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
+            setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
+            setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
+            setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
+            setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
+            setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
+            setFromEuler: (e: import('three').Euler) => import('three').Vector3;
+            setFromColor: (color: import('three').RGB) => import('three').Vector3;
+            equals: (v: import('three').Vector3Like) => boolean;
+            fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector3;
             toArray: {
-                (array?: number[] | undefined, offset?: number | undefined): number[];
-                (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
-                (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
+                (array?: number[], offset?: number): number[];
+                (array?: import('three').Vector3Tuple, offset?: 0): import('three').Vector3Tuple;
+                (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
             };
-            fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => import("three").Vector3;
-            random: () => import("three").Vector3;
-            randomDirection: () => import("three").Vector3;
-            [Symbol.iterator]: () => Iterator<number, any, undefined>;
+            fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
+            random: () => import('three').Vector3;
+            randomDirection: () => import('three').Vector3;
+            [Symbol.iterator]: () => Iterator<number>;
         };
         readonly position: {
             x: number;
             y: number;
             z: number;
             readonly isVector3: true;
-            set: (x: number, y: number, z: number) => import("three").Vector3;
-            setScalar: (scalar: number) => import("three").Vector3;
-            setX: (x: number) => import("three").Vector3;
-            setY: (y: number) => import("three").Vector3;
-            setZ: (z: number) => import("three").Vector3;
-            setComponent: (index: number, value: number) => import("three").Vector3;
+            set: (x: number, y: number, z: number) => import('three').Vector3;
+            setScalar: (scalar: number) => import('three').Vector3;
+            setX: (x: number) => import('three').Vector3;
+            setY: (y: number) => import('three').Vector3;
+            setZ: (z: number) => import('three').Vector3;
+            setComponent: (index: number, value: number) => import('three').Vector3;
             getComponent: (index: number) => number;
-            clone: () => import("three").Vector3;
-            copy: (v: import("three").Vector3Like) => import("three").Vector3;
-            add: (v: import("three").Vector3Like) => import("three").Vector3;
-            addScalar: (s: number) => import("three").Vector3;
-            addVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-            addScaledVector: (v: import("three").Vector3, s: number) => import("three").Vector3;
-            sub: (a: import("three").Vector3Like) => import("three").Vector3;
-            subScalar: (s: number) => import("three").Vector3;
-            subVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-            multiply: (v: import("three").Vector3Like) => import("three").Vector3;
-            multiplyScalar: (s: number) => import("three").Vector3;
-            multiplyVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-            applyEuler: (euler: import("three").Euler) => import("three").Vector3;
-            applyAxisAngle: (axis: import("three").Vector3, angle: number) => import("three").Vector3;
-            applyMatrix3: (m: import("three").Matrix3) => import("three").Vector3;
-            applyNormalMatrix: (m: import("three").Matrix3) => import("three").Vector3;
-            applyMatrix4: (m: import("three").Matrix4) => import("three").Vector3;
-            applyQuaternion: (q: import("three").QuaternionLike) => import("three").Vector3;
-            project: (camera: Camera) => import("three").Vector3;
-            unproject: (camera: Camera) => import("three").Vector3;
-            transformDirection: (m: import("three").Matrix4) => import("three").Vector3;
-            divide: (v: import("three").Vector3Like) => import("three").Vector3;
-            divideScalar: (s: number) => import("three").Vector3;
-            min: (v: import("three").Vector3Like) => import("three").Vector3;
-            max: (v: import("three").Vector3Like) => import("three").Vector3;
-            clamp: (min: import("three").Vector3Like, max: import("three").Vector3Like) => import("three").Vector3;
-            clampScalar: (min: number, max: number) => import("three").Vector3;
-            clampLength: (min: number, max: number) => import("three").Vector3;
-            floor: () => import("three").Vector3;
-            ceil: () => import("three").Vector3;
-            round: () => import("three").Vector3;
-            roundToZero: () => import("three").Vector3;
-            negate: () => import("three").Vector3;
-            dot: (v: import("three").Vector3Like) => number;
+            clone: () => import('three').Vector3;
+            copy: (v: import('three').Vector3Like) => import('three').Vector3;
+            add: (v: import('three').Vector3Like) => import('three').Vector3;
+            addScalar: (s: number) => import('three').Vector3;
+            addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+            addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
+            sub: (a: import('three').Vector3Like) => import('three').Vector3;
+            subScalar: (s: number) => import('three').Vector3;
+            subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+            multiply: (v: import('three').Vector3Like) => import('three').Vector3;
+            multiplyScalar: (s: number) => import('three').Vector3;
+            multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+            applyEuler: (euler: import('three').Euler) => import('three').Vector3;
+            applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
+            applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
+            applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
+            applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
+            applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
+            project: (camera: Camera) => import('three').Vector3;
+            unproject: (camera: Camera) => import('three').Vector3;
+            transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
+            divide: (v: import('three').Vector3Like) => import('three').Vector3;
+            divideScalar: (s: number) => import('three').Vector3;
+            min: (v: import('three').Vector3Like) => import('three').Vector3;
+            max: (v: import('three').Vector3Like) => import('three').Vector3;
+            clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
+            clampScalar: (min: number, max: number) => import('three').Vector3;
+            clampLength: (min: number, max: number) => import('three').Vector3;
+            floor: () => import('three').Vector3;
+            ceil: () => import('three').Vector3;
+            round: () => import('three').Vector3;
+            roundToZero: () => import('three').Vector3;
+            negate: () => import('three').Vector3;
+            dot: (v: import('three').Vector3Like) => number;
             lengthSq: () => number;
             length: () => number;
             manhattanLength: () => number;
-            normalize: () => import("three").Vector3;
-            setLength: (l: number) => import("three").Vector3;
-            lerp: (v: import("three").Vector3Like, alpha: number) => import("three").Vector3;
-            lerpVectors: (v1: import("three").Vector3Like, v2: import("three").Vector3Like, alpha: number) => import("three").Vector3;
-            cross: (a: import("three").Vector3Like) => import("three").Vector3;
-            crossVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-            projectOnVector: (v: import("three").Vector3) => import("three").Vector3;
-            projectOnPlane: (planeNormal: import("three").Vector3) => import("three").Vector3;
-            reflect: (vector: import("three").Vector3Like) => import("three").Vector3;
-            angleTo: (v: import("three").Vector3) => number;
-            distanceTo: (v: import("three").Vector3Like) => number;
-            distanceToSquared: (v: import("three").Vector3Like) => number;
-            manhattanDistanceTo: (v: import("three").Vector3Like) => number;
-            setFromSpherical: (s: import("three").Spherical) => import("three").Vector3;
-            setFromSphericalCoords: (r: number, phi: number, theta: number) => import("three").Vector3;
-            setFromCylindrical: (s: import("three").Cylindrical) => import("three").Vector3;
-            setFromCylindricalCoords: (radius: number, theta: number, y: number) => import("three").Vector3;
-            setFromMatrixPosition: (m: import("three").Matrix4) => import("three").Vector3;
-            setFromMatrixScale: (m: import("three").Matrix4) => import("three").Vector3;
-            setFromMatrixColumn: (matrix: import("three").Matrix4, index: number) => import("three").Vector3;
-            setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => import("three").Vector3;
-            setFromEuler: (e: import("three").Euler) => import("three").Vector3;
-            setFromColor: (color: import("three").RGB) => import("three").Vector3;
-            equals: (v: import("three").Vector3Like) => boolean;
-            fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector3;
+            normalize: () => import('three').Vector3;
+            setLength: (l: number) => import('three').Vector3;
+            lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
+            lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
+            cross: (a: import('three').Vector3Like) => import('three').Vector3;
+            crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+            projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
+            projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
+            reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
+            angleTo: (v: import('three').Vector3) => number;
+            distanceTo: (v: import('three').Vector3Like) => number;
+            distanceToSquared: (v: import('three').Vector3Like) => number;
+            manhattanDistanceTo: (v: import('three').Vector3Like) => number;
+            setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
+            setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
+            setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
+            setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
+            setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
+            setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
+            setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
+            setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
+            setFromEuler: (e: import('three').Euler) => import('three').Vector3;
+            setFromColor: (color: import('three').RGB) => import('three').Vector3;
+            equals: (v: import('three').Vector3Like) => boolean;
+            fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector3;
             toArray: {
-                (array?: number[] | undefined, offset?: number | undefined): number[];
-                (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
-                (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
+                (array?: number[], offset?: number): number[];
+                (array?: import('three').Vector3Tuple, offset?: 0): import('three').Vector3Tuple;
+                (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
             };
-            fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => import("three").Vector3;
-            random: () => import("three").Vector3;
-            randomDirection: () => import("three").Vector3;
-            [Symbol.iterator]: () => Iterator<number, any, undefined>;
+            fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
+            random: () => import('three').Vector3;
+            randomDirection: () => import('three').Vector3;
+            [Symbol.iterator]: () => Iterator<number>;
         };
         readonly rotation: {
             x: number;
             y: number;
             z: number;
-            order: import("three").EulerOrder;
+            order: import('three').EulerOrder;
             readonly isEuler: true;
             _onChangeCallback: () => void;
-            set: (x: number, y: number, z: number, order?: import("three").EulerOrder | undefined) => import("three").Euler;
-            clone: () => import("three").Euler;
-            copy: (euler: import("three").Euler) => import("three").Euler;
-            setFromRotationMatrix: (m: import("three").Matrix4, order?: import("three").EulerOrder | undefined, update?: boolean | undefined) => import("three").Euler;
-            setFromQuaternion: (q: import("three").Quaternion, order?: import("three").EulerOrder | undefined, update?: boolean | undefined) => import("three").Euler;
-            setFromVector3: (v: import("three").Vector3, order?: import("three").EulerOrder | undefined) => import("three").Euler;
-            reorder: (newOrder: import("three").EulerOrder) => import("three").Euler;
-            equals: (euler: import("three").Euler) => boolean;
-            fromArray: (xyzo: [number, number, number, (import("three").EulerOrder | undefined)?, ...any[]]) => import("three").Euler;
-            toArray: (array?: (string | number | undefined)[] | undefined, offset?: number | undefined) => (string | number | undefined)[];
-            _onChange: (callback: () => void) => import("three").Euler;
-            [Symbol.iterator]: () => Generator<string | number, void, unknown>;
+            set: (x: number, y: number, z: number, order?: import('three').EulerOrder) => import('three').Euler;
+            clone: () => import('three').Euler;
+            copy: (euler: import('three').Euler) => import('three').Euler;
+            setFromRotationMatrix: (m: import('three').Matrix4, order?: import('three').EulerOrder, update?: boolean) => import('three').Euler;
+            setFromQuaternion: (q: import('three').Quaternion, order?: import('three').EulerOrder, update?: boolean) => import('three').Euler;
+            setFromVector3: (v: import('three').Vector3, order?: import('three').EulerOrder) => import('three').Euler;
+            reorder: (newOrder: import('three').EulerOrder) => import('three').Euler;
+            equals: (euler: import('three').Euler) => boolean;
+            fromArray: (xyzo: [number, number, number, import('three').EulerOrder?, ...any[]]) => import('three').Euler;
+            toArray: (array?: Array<number | string | undefined>, offset?: number) => Array<number | string | undefined>;
+            _onChange: (callback: () => void) => import('three').Euler;
+            [Symbol.iterator]: () => Generator<string | number, void>;
         };
         readonly quaternion: {
             x: number;
@@ -3218,348 +3254,352 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
             z: number;
             w: number;
             readonly isQuaternion: true;
-            set: (x: number, y: number, z: number, w: number) => import("three").Quaternion;
-            clone: () => import("three").Quaternion;
-            copy: (q: import("three").QuaternionLike) => import("three").Quaternion;
-            setFromEuler: (euler: import("three").Euler, update?: boolean | undefined) => import("three").Quaternion;
-            setFromAxisAngle: (axis: import("three").Vector3Like, angle: number) => import("three").Quaternion;
-            setFromRotationMatrix: (m: import("three").Matrix4) => import("three").Quaternion;
-            setFromUnitVectors: (vFrom: import("three").Vector3, vTo: import("three").Vector3Like) => import("three").Quaternion;
-            angleTo: (q: import("three").Quaternion) => number;
-            rotateTowards: (q: import("three").Quaternion, step: number) => import("three").Quaternion;
-            identity: () => import("three").Quaternion;
-            invert: () => import("three").Quaternion;
-            conjugate: () => import("three").Quaternion;
-            dot: (v: import("three").Quaternion) => number;
+            set: (x: number, y: number, z: number, w: number) => import('three').Quaternion;
+            clone: () => import('three').Quaternion;
+            copy: (q: import('three').QuaternionLike) => import('three').Quaternion;
+            setFromEuler: (euler: import('three').Euler, update?: boolean) => import('three').Quaternion;
+            setFromAxisAngle: (axis: import('three').Vector3Like, angle: number) => import('three').Quaternion;
+            setFromRotationMatrix: (m: import('three').Matrix4) => import('three').Quaternion;
+            setFromUnitVectors: (vFrom: import('three').Vector3, vTo: import('three').Vector3Like) => import('three').Quaternion;
+            angleTo: (q: import('three').Quaternion) => number;
+            rotateTowards: (q: import('three').Quaternion, step: number) => import('three').Quaternion;
+            identity: () => import('three').Quaternion;
+            invert: () => import('three').Quaternion;
+            conjugate: () => import('three').Quaternion;
+            dot: (v: import('three').Quaternion) => number;
             lengthSq: () => number;
             length: () => number;
-            normalize: () => import("three").Quaternion;
-            multiply: (q: import("three").Quaternion) => import("three").Quaternion;
-            premultiply: (q: import("three").Quaternion) => import("three").Quaternion;
-            multiplyQuaternions: (a: import("three").Quaternion, b: import("three").Quaternion) => import("three").Quaternion;
-            slerp: (qb: import("three").Quaternion, t: number) => import("three").Quaternion;
-            slerpQuaternions: (qa: import("three").Quaternion, qb: import("three").Quaternion, t: number) => import("three").Quaternion;
-            equals: (v: import("three").Quaternion) => boolean;
-            fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Quaternion;
+            normalize: () => import('three').Quaternion;
+            multiply: (q: import('three').Quaternion) => import('three').Quaternion;
+            premultiply: (q: import('three').Quaternion) => import('three').Quaternion;
+            multiplyQuaternions: (a: import('three').Quaternion, b: import('three').Quaternion) => import('three').Quaternion;
+            slerp: (qb: import('three').Quaternion, t: number) => import('three').Quaternion;
+            slerpQuaternions: (qa: import('three').Quaternion, qb: import('three').Quaternion, t: number) => import('three').Quaternion;
+            equals: (v: import('three').Quaternion) => boolean;
+            fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Quaternion;
             toArray: {
-                (array?: number[] | undefined, offset?: number | undefined): number[];
-                (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
+                (array?: number[], offset?: number): number[];
+                (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
             };
             toJSON: () => [number, number, number, number];
-            fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => import("three").Quaternion;
-            _onChange: (callback: () => void) => import("three").Quaternion;
+            fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Quaternion;
+            _onChange: (callback: () => void) => import('three').Quaternion;
             _onChangeCallback: () => void;
-            random: () => import("three").Quaternion;
-            [Symbol.iterator]: () => Generator<number, void, unknown>;
+            random: () => import('three').Quaternion;
+            [Symbol.iterator]: () => Generator<number, void>;
         };
         readonly scale: {
             x: number;
             y: number;
             z: number;
             readonly isVector3: true;
-            set: (x: number, y: number, z: number) => import("three").Vector3;
-            setScalar: (scalar: number) => import("three").Vector3;
-            setX: (x: number) => import("three").Vector3;
-            setY: (y: number) => import("three").Vector3;
-            setZ: (z: number) => import("three").Vector3;
-            setComponent: (index: number, value: number) => import("three").Vector3;
+            set: (x: number, y: number, z: number) => import('three').Vector3;
+            setScalar: (scalar: number) => import('three').Vector3;
+            setX: (x: number) => import('three').Vector3;
+            setY: (y: number) => import('three').Vector3;
+            setZ: (z: number) => import('three').Vector3;
+            setComponent: (index: number, value: number) => import('three').Vector3;
             getComponent: (index: number) => number;
-            clone: () => import("three").Vector3;
-            copy: (v: import("three").Vector3Like) => import("three").Vector3;
-            add: (v: import("three").Vector3Like) => import("three").Vector3;
-            addScalar: (s: number) => import("three").Vector3;
-            addVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-            addScaledVector: (v: import("three").Vector3, s: number) => import("three").Vector3;
-            sub: (a: import("three").Vector3Like) => import("three").Vector3;
-            subScalar: (s: number) => import("three").Vector3;
-            subVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-            multiply: (v: import("three").Vector3Like) => import("three").Vector3;
-            multiplyScalar: (s: number) => import("three").Vector3;
-            multiplyVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-            applyEuler: (euler: import("three").Euler) => import("three").Vector3;
-            applyAxisAngle: (axis: import("three").Vector3, angle: number) => import("three").Vector3;
-            applyMatrix3: (m: import("three").Matrix3) => import("three").Vector3;
-            applyNormalMatrix: (m: import("three").Matrix3) => import("three").Vector3;
-            applyMatrix4: (m: import("three").Matrix4) => import("three").Vector3;
-            applyQuaternion: (q: import("three").QuaternionLike) => import("three").Vector3;
-            project: (camera: Camera) => import("three").Vector3;
-            unproject: (camera: Camera) => import("three").Vector3;
-            transformDirection: (m: import("three").Matrix4) => import("three").Vector3;
-            divide: (v: import("three").Vector3Like) => import("three").Vector3;
-            divideScalar: (s: number) => import("three").Vector3;
-            min: (v: import("three").Vector3Like) => import("three").Vector3;
-            max: (v: import("three").Vector3Like) => import("three").Vector3;
-            clamp: (min: import("three").Vector3Like, max: import("three").Vector3Like) => import("three").Vector3;
-            clampScalar: (min: number, max: number) => import("three").Vector3;
-            clampLength: (min: number, max: number) => import("three").Vector3;
-            floor: () => import("three").Vector3;
-            ceil: () => import("three").Vector3;
-            round: () => import("three").Vector3;
-            roundToZero: () => import("three").Vector3;
-            negate: () => import("three").Vector3;
-            dot: (v: import("three").Vector3Like) => number;
+            clone: () => import('three').Vector3;
+            copy: (v: import('three').Vector3Like) => import('three').Vector3;
+            add: (v: import('three').Vector3Like) => import('three').Vector3;
+            addScalar: (s: number) => import('three').Vector3;
+            addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+            addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
+            sub: (a: import('three').Vector3Like) => import('three').Vector3;
+            subScalar: (s: number) => import('three').Vector3;
+            subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+            multiply: (v: import('three').Vector3Like) => import('three').Vector3;
+            multiplyScalar: (s: number) => import('three').Vector3;
+            multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+            applyEuler: (euler: import('three').Euler) => import('three').Vector3;
+            applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
+            applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
+            applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
+            applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
+            applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
+            project: (camera: Camera) => import('three').Vector3;
+            unproject: (camera: Camera) => import('three').Vector3;
+            transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
+            divide: (v: import('three').Vector3Like) => import('three').Vector3;
+            divideScalar: (s: number) => import('three').Vector3;
+            min: (v: import('three').Vector3Like) => import('three').Vector3;
+            max: (v: import('three').Vector3Like) => import('three').Vector3;
+            clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
+            clampScalar: (min: number, max: number) => import('three').Vector3;
+            clampLength: (min: number, max: number) => import('three').Vector3;
+            floor: () => import('three').Vector3;
+            ceil: () => import('three').Vector3;
+            round: () => import('three').Vector3;
+            roundToZero: () => import('three').Vector3;
+            negate: () => import('three').Vector3;
+            dot: (v: import('three').Vector3Like) => number;
             lengthSq: () => number;
             length: () => number;
             manhattanLength: () => number;
-            normalize: () => import("three").Vector3;
-            setLength: (l: number) => import("three").Vector3;
-            lerp: (v: import("three").Vector3Like, alpha: number) => import("three").Vector3;
-            lerpVectors: (v1: import("three").Vector3Like, v2: import("three").Vector3Like, alpha: number) => import("three").Vector3;
-            cross: (a: import("three").Vector3Like) => import("three").Vector3;
-            crossVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-            projectOnVector: (v: import("three").Vector3) => import("three").Vector3;
-            projectOnPlane: (planeNormal: import("three").Vector3) => import("three").Vector3;
-            reflect: (vector: import("three").Vector3Like) => import("three").Vector3;
-            angleTo: (v: import("three").Vector3) => number;
-            distanceTo: (v: import("three").Vector3Like) => number;
-            distanceToSquared: (v: import("three").Vector3Like) => number;
-            manhattanDistanceTo: (v: import("three").Vector3Like) => number;
-            setFromSpherical: (s: import("three").Spherical) => import("three").Vector3;
-            setFromSphericalCoords: (r: number, phi: number, theta: number) => import("three").Vector3;
-            setFromCylindrical: (s: import("three").Cylindrical) => import("three").Vector3;
-            setFromCylindricalCoords: (radius: number, theta: number, y: number) => import("three").Vector3;
-            setFromMatrixPosition: (m: import("three").Matrix4) => import("three").Vector3;
-            setFromMatrixScale: (m: import("three").Matrix4) => import("three").Vector3;
-            setFromMatrixColumn: (matrix: import("three").Matrix4, index: number) => import("three").Vector3;
-            setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => import("three").Vector3;
-            setFromEuler: (e: import("three").Euler) => import("three").Vector3;
-            setFromColor: (color: import("three").RGB) => import("three").Vector3;
-            equals: (v: import("three").Vector3Like) => boolean;
-            fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector3;
+            normalize: () => import('three').Vector3;
+            setLength: (l: number) => import('three').Vector3;
+            lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
+            lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
+            cross: (a: import('three').Vector3Like) => import('three').Vector3;
+            crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+            projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
+            projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
+            reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
+            angleTo: (v: import('three').Vector3) => number;
+            distanceTo: (v: import('three').Vector3Like) => number;
+            distanceToSquared: (v: import('three').Vector3Like) => number;
+            manhattanDistanceTo: (v: import('three').Vector3Like) => number;
+            setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
+            setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
+            setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
+            setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
+            setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
+            setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
+            setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
+            setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
+            setFromEuler: (e: import('three').Euler) => import('three').Vector3;
+            setFromColor: (color: import('three').RGB) => import('three').Vector3;
+            equals: (v: import('three').Vector3Like) => boolean;
+            fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector3;
             toArray: {
-                (array?: number[] | undefined, offset?: number | undefined): number[];
-                (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
-                (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
+                (array?: number[], offset?: number): number[];
+                (array?: import('three').Vector3Tuple, offset?: 0): import('three').Vector3Tuple;
+                (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
             };
-            fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => import("three").Vector3;
-            random: () => import("three").Vector3;
-            randomDirection: () => import("three").Vector3;
-            [Symbol.iterator]: () => Iterator<number, any, undefined>;
+            fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
+            random: () => import('three').Vector3;
+            randomDirection: () => import('three').Vector3;
+            [Symbol.iterator]: () => Iterator<number>;
         };
         readonly modelViewMatrix: {
+            readonly isMatrix4: true;
             elements: number[];
-            set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import("three").Matrix4;
-            identity: () => import("three").Matrix4;
-            clone: () => import("three").Matrix4;
-            copy: (m: import("three").Matrix4) => import("three").Matrix4;
-            copyPosition: (m: import("three").Matrix4) => import("three").Matrix4;
-            extractBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
-            makeBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
-            extractRotation: (m: import("three").Matrix4) => import("three").Matrix4;
-            makeRotationFromEuler: (euler: import("three").Euler) => import("three").Matrix4;
-            makeRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
-            lookAt: (eye: import("three").Vector3, target: import("three").Vector3, up: import("three").Vector3) => import("three").Matrix4;
-            multiply: (m: import("three").Matrix4) => import("three").Matrix4;
-            premultiply: (m: import("three").Matrix4) => import("three").Matrix4;
-            multiplyMatrices: (a: import("three").Matrix4, b: import("three").Matrix4) => import("three").Matrix4;
-            multiplyToArray: (a: import("three").Matrix4, b: import("three").Matrix4, r: number[]) => import("three").Matrix4;
-            multiplyScalar: (s: number) => import("three").Matrix4;
+            set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
+            identity: () => import('three').Matrix4;
+            clone: () => import('three').Matrix4;
+            copy: (m: import('three').Matrix4) => import('three').Matrix4;
+            copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
+            extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
+            makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
+            extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
+            makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
+            makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
+            lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
+            multiply: (m: import('three').Matrix4) => import('three').Matrix4;
+            premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
+            multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
+            multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
+            multiplyScalar: (s: number) => import('three').Matrix4;
             determinant: () => number;
-            transpose: () => import("three").Matrix4;
+            transpose: () => import('three').Matrix4;
             setPosition: {
-                (v: import("three").Vector3): import("three").Matrix4;
-                (x: number, y: number, z: number): import("three").Matrix4;
+                (v: import('three').Vector3): import('three').Matrix4;
+                (x: number, y: number, z: number): import('three').Matrix4;
             };
-            invert: () => import("three").Matrix4;
-            scale: (v: import("three").Vector3) => import("three").Matrix4;
+            invert: () => import('three').Matrix4;
+            scale: (v: import('three').Vector3) => import('three').Matrix4;
             getMaxScaleOnAxis: () => number;
             makeTranslation: {
-                (v: import("three").Vector3): import("three").Matrix4;
-                (x: number, y: number, z: number): import("three").Matrix4;
+                (v: import('three').Vector3): import('three').Matrix4;
+                (x: number, y: number, z: number): import('three').Matrix4;
             };
-            makeRotationX: (theta: number) => import("three").Matrix4;
-            makeRotationY: (theta: number) => import("three").Matrix4;
-            makeRotationZ: (theta: number) => import("three").Matrix4;
-            makeRotationAxis: (axis: import("three").Vector3, angle: number) => import("three").Matrix4;
-            makeScale: (x: number, y: number, z: number) => import("three").Matrix4;
-            makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import("three").Matrix4;
-            compose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
-            decompose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
-            makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => import("three").Matrix4;
-            makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => import("three").Matrix4;
-            equals: (matrix: import("three").Matrix4) => boolean;
-            fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Matrix4;
+            makeRotationX: (theta: number) => import('three').Matrix4;
+            makeRotationY: (theta: number) => import('three').Matrix4;
+            makeRotationZ: (theta: number) => import('three').Matrix4;
+            makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
+            makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
+            makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
+            compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
+            decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
+            makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
+            makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
+            equals: (matrix: import('three').Matrix4) => boolean;
+            fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Matrix4;
             toArray: {
-                (array?: number[] | undefined, offset?: number | undefined): number[];
-                (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
-                (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
+                (array?: number[], offset?: number): number[];
+                (array?: import('three').Matrix4Tuple, offset?: 0): import('three').Matrix4Tuple;
+                (array?: ArrayLike<number>, offset?: number): ArrayLike<number>;
             };
-            setFromMatrix3: (m: import("three").Matrix3) => import("three").Matrix4;
-            extractPosition: (m: import("three").Matrix4) => import("three").Matrix4;
-            setRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
+            setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
+            extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
+            setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
             multiplyVector3: (v: any) => any;
             multiplyVector4: (v: any) => any;
             multiplyVector3Array: (array: number[]) => number[];
             rotateAxis: (v: any) => void;
             crossVector: (v: any) => void;
             flattenToArrayOffset: (array: number[], offset: number) => number[];
-            getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
+            getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
         };
         readonly normalMatrix: {
+            readonly isMatrix3: true;
             elements: number[];
-            set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => import("three").Matrix3;
-            identity: () => import("three").Matrix3;
-            clone: () => import("three").Matrix3;
-            copy: (m: import("three").Matrix3) => import("three").Matrix3;
-            extractBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix3;
-            setFromMatrix4: (m: import("three").Matrix4) => import("three").Matrix3;
-            multiplyScalar: (s: number) => import("three").Matrix3;
+            set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => import('three').Matrix3;
+            identity: () => import('three').Matrix3;
+            clone: () => import('three').Matrix3;
+            copy: (m: import('three').Matrix3) => import('three').Matrix3;
+            extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix3;
+            setFromMatrix4: (m: import('three').Matrix4) => import('three').Matrix3;
+            multiplyScalar: (s: number) => import('three').Matrix3;
             determinant: () => number;
-            invert: () => import("three").Matrix3;
-            transpose: () => import("three").Matrix3;
-            getNormalMatrix: (matrix4: import("three").Matrix4) => import("three").Matrix3;
-            transposeIntoArray: (r: number[]) => import("three").Matrix3;
-            setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => import("three").Matrix3;
-            scale: (sx: number, sy: number) => import("three").Matrix3;
+            invert: () => import('three').Matrix3;
+            transpose: () => import('three').Matrix3;
+            getNormalMatrix: (matrix4: import('three').Matrix4) => import('three').Matrix3;
+            transposeIntoArray: (r: number[]) => import('three').Matrix3;
+            setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => import('three').Matrix3;
+            scale: (sx: number, sy: number) => import('three').Matrix3;
             makeTranslation: {
-                (v: import("three").Vector2): import("three").Matrix3;
-                (x: number, y: number): import("three").Matrix3;
+                (v: import('three').Vector2): import('three').Matrix3;
+                (x: number, y: number): import('three').Matrix3;
             };
             makeRotation: {
-                (theta: number): import("three").Matrix3;
-                (theta: number): import("three").Matrix3;
+                (theta: number): import('three').Matrix3;
+                (theta: number): import('three').Matrix3;
             };
             makeScale: {
-                (x: number, y: number): import("three").Matrix3;
-                (x: number, y: number): import("three").Matrix3;
+                (x: number, y: number): import('three').Matrix3;
+                (x: number, y: number): import('three').Matrix3;
             };
-            rotate: (theta: number) => import("three").Matrix3;
-            translate: (tx: number, ty: number) => import("three").Matrix3;
-            equals: (matrix: import("three").Matrix3) => boolean;
-            fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Matrix3;
+            rotate: (theta: number) => import('three').Matrix3;
+            translate: (tx: number, ty: number) => import('three').Matrix3;
+            equals: (matrix: import('three').Matrix3) => boolean;
+            fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Matrix3;
             toArray: {
-                (array?: number[] | undefined, offset?: number | undefined): number[];
-                (array?: import("three").Matrix3Tuple | undefined, offset?: 0 | undefined): import("three").Matrix3Tuple;
-                (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
+                (array?: number[], offset?: number): number[];
+                (array?: import('three').Matrix3Tuple, offset?: 0): import('three').Matrix3Tuple;
+                (array?: ArrayLike<number>, offset?: number): ArrayLike<number>;
             };
-            multiply: (m: import("three").Matrix3) => import("three").Matrix3;
-            premultiply: (m: import("three").Matrix3) => import("three").Matrix3;
-            multiplyMatrices: (a: import("three").Matrix3, b: import("three").Matrix3) => import("three").Matrix3;
-            multiplyVector3: (vector: import("three").Vector3) => any;
+            multiply: (m: import('three').Matrix3) => import('three').Matrix3;
+            premultiply: (m: import('three').Matrix3) => import('three').Matrix3;
+            multiplyMatrices: (a: import('three').Matrix3, b: import('three').Matrix3) => import('three').Matrix3;
+            multiplyVector3: (vector: import('three').Vector3) => any;
             multiplyVector3Array: (a: any) => any;
             getInverse: {
-                (matrix: import("three").Matrix4, throwOnDegenerate?: boolean | undefined): import("three").Matrix3;
-                (matrix: import("three").Matrix): import("three").Matrix;
+                (matrix: import('three').Matrix4, throwOnDegenerate?: boolean): import('three').Matrix3;
+                (matrix: import('three').Matrix): import('three').Matrix;
             };
             flattenToArrayOffset: (array: number[], offset: number) => number[];
         };
         matrix: {
+            readonly isMatrix4: true;
             elements: number[];
-            set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import("three").Matrix4;
-            identity: () => import("three").Matrix4;
-            clone: () => import("three").Matrix4;
-            copy: (m: import("three").Matrix4) => import("three").Matrix4;
-            copyPosition: (m: import("three").Matrix4) => import("three").Matrix4;
-            extractBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
-            makeBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
-            extractRotation: (m: import("three").Matrix4) => import("three").Matrix4;
-            makeRotationFromEuler: (euler: import("three").Euler) => import("three").Matrix4;
-            makeRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
-            lookAt: (eye: import("three").Vector3, target: import("three").Vector3, up: import("three").Vector3) => import("three").Matrix4;
-            multiply: (m: import("three").Matrix4) => import("three").Matrix4;
-            premultiply: (m: import("three").Matrix4) => import("three").Matrix4;
-            multiplyMatrices: (a: import("three").Matrix4, b: import("three").Matrix4) => import("three").Matrix4;
-            multiplyToArray: (a: import("three").Matrix4, b: import("three").Matrix4, r: number[]) => import("three").Matrix4;
-            multiplyScalar: (s: number) => import("three").Matrix4;
+            set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
+            identity: () => import('three').Matrix4;
+            clone: () => import('three').Matrix4;
+            copy: (m: import('three').Matrix4) => import('three').Matrix4;
+            copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
+            extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
+            makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
+            extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
+            makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
+            makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
+            lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
+            multiply: (m: import('three').Matrix4) => import('three').Matrix4;
+            premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
+            multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
+            multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
+            multiplyScalar: (s: number) => import('three').Matrix4;
             determinant: () => number;
-            transpose: () => import("three").Matrix4;
+            transpose: () => import('three').Matrix4;
             setPosition: {
-                (v: import("three").Vector3): import("three").Matrix4;
-                (x: number, y: number, z: number): import("three").Matrix4;
+                (v: import('three').Vector3): import('three').Matrix4;
+                (x: number, y: number, z: number): import('three').Matrix4;
             };
-            invert: () => import("three").Matrix4;
-            scale: (v: import("three").Vector3) => import("three").Matrix4;
+            invert: () => import('three').Matrix4;
+            scale: (v: import('three').Vector3) => import('three').Matrix4;
             getMaxScaleOnAxis: () => number;
             makeTranslation: {
-                (v: import("three").Vector3): import("three").Matrix4;
-                (x: number, y: number, z: number): import("three").Matrix4;
+                (v: import('three').Vector3): import('three').Matrix4;
+                (x: number, y: number, z: number): import('three').Matrix4;
             };
-            makeRotationX: (theta: number) => import("three").Matrix4;
-            makeRotationY: (theta: number) => import("three").Matrix4;
-            makeRotationZ: (theta: number) => import("three").Matrix4;
-            makeRotationAxis: (axis: import("three").Vector3, angle: number) => import("three").Matrix4;
-            makeScale: (x: number, y: number, z: number) => import("three").Matrix4;
-            makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import("three").Matrix4;
-            compose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
-            decompose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
-            makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => import("three").Matrix4;
-            makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => import("three").Matrix4;
-            equals: (matrix: import("three").Matrix4) => boolean;
-            fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Matrix4;
+            makeRotationX: (theta: number) => import('three').Matrix4;
+            makeRotationY: (theta: number) => import('three').Matrix4;
+            makeRotationZ: (theta: number) => import('three').Matrix4;
+            makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
+            makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
+            makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
+            compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
+            decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
+            makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
+            makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
+            equals: (matrix: import('three').Matrix4) => boolean;
+            fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Matrix4;
             toArray: {
-                (array?: number[] | undefined, offset?: number | undefined): number[];
-                (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
-                (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
+                (array?: number[], offset?: number): number[];
+                (array?: import('three').Matrix4Tuple, offset?: 0): import('three').Matrix4Tuple;
+                (array?: ArrayLike<number>, offset?: number): ArrayLike<number>;
             };
-            setFromMatrix3: (m: import("three").Matrix3) => import("three").Matrix4;
-            extractPosition: (m: import("three").Matrix4) => import("three").Matrix4;
-            setRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
+            setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
+            extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
+            setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
             multiplyVector3: (v: any) => any;
             multiplyVector4: (v: any) => any;
             multiplyVector3Array: (array: number[]) => number[];
             rotateAxis: (v: any) => void;
             crossVector: (v: any) => void;
             flattenToArrayOffset: (array: number[], offset: number) => number[];
-            getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
+            getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
         };
         matrixWorld: {
+            readonly isMatrix4: true;
             elements: number[];
-            set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import("three").Matrix4;
-            identity: () => import("three").Matrix4;
-            clone: () => import("three").Matrix4;
-            copy: (m: import("three").Matrix4) => import("three").Matrix4;
-            copyPosition: (m: import("three").Matrix4) => import("three").Matrix4;
-            extractBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
-            makeBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
-            extractRotation: (m: import("three").Matrix4) => import("three").Matrix4;
-            makeRotationFromEuler: (euler: import("three").Euler) => import("three").Matrix4;
-            makeRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
-            lookAt: (eye: import("three").Vector3, target: import("three").Vector3, up: import("three").Vector3) => import("three").Matrix4;
-            multiply: (m: import("three").Matrix4) => import("three").Matrix4;
-            premultiply: (m: import("three").Matrix4) => import("three").Matrix4;
-            multiplyMatrices: (a: import("three").Matrix4, b: import("three").Matrix4) => import("three").Matrix4;
-            multiplyToArray: (a: import("three").Matrix4, b: import("three").Matrix4, r: number[]) => import("three").Matrix4;
-            multiplyScalar: (s: number) => import("three").Matrix4;
+            set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
+            identity: () => import('three').Matrix4;
+            clone: () => import('three').Matrix4;
+            copy: (m: import('three').Matrix4) => import('three').Matrix4;
+            copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
+            extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
+            makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
+            extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
+            makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
+            makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
+            lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
+            multiply: (m: import('three').Matrix4) => import('three').Matrix4;
+            premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
+            multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
+            multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
+            multiplyScalar: (s: number) => import('three').Matrix4;
             determinant: () => number;
-            transpose: () => import("three").Matrix4;
+            transpose: () => import('three').Matrix4;
             setPosition: {
-                (v: import("three").Vector3): import("three").Matrix4;
-                (x: number, y: number, z: number): import("three").Matrix4;
+                (v: import('three').Vector3): import('three').Matrix4;
+                (x: number, y: number, z: number): import('three').Matrix4;
             };
-            invert: () => import("three").Matrix4;
-            scale: (v: import("three").Vector3) => import("three").Matrix4;
+            invert: () => import('three').Matrix4;
+            scale: (v: import('three').Vector3) => import('three').Matrix4;
             getMaxScaleOnAxis: () => number;
             makeTranslation: {
-                (v: import("three").Vector3): import("three").Matrix4;
-                (x: number, y: number, z: number): import("three").Matrix4;
+                (v: import('three').Vector3): import('three').Matrix4;
+                (x: number, y: number, z: number): import('three').Matrix4;
             };
-            makeRotationX: (theta: number) => import("three").Matrix4;
-            makeRotationY: (theta: number) => import("three").Matrix4;
-            makeRotationZ: (theta: number) => import("three").Matrix4;
-            makeRotationAxis: (axis: import("three").Vector3, angle: number) => import("three").Matrix4;
-            makeScale: (x: number, y: number, z: number) => import("three").Matrix4;
-            makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import("three").Matrix4;
-            compose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
-            decompose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
-            makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => import("three").Matrix4;
-            makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => import("three").Matrix4;
-            equals: (matrix: import("three").Matrix4) => boolean;
-            fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Matrix4;
+            makeRotationX: (theta: number) => import('three').Matrix4;
+            makeRotationY: (theta: number) => import('three').Matrix4;
+            makeRotationZ: (theta: number) => import('three').Matrix4;
+            makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
+            makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
+            makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
+            compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
+            decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
+            makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
+            makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
+            equals: (matrix: import('three').Matrix4) => boolean;
+            fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Matrix4;
             toArray: {
-                (array?: number[] | undefined, offset?: number | undefined): number[];
-                (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
-                (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
+                (array?: number[], offset?: number): number[];
+                (array?: import('three').Matrix4Tuple, offset?: 0): import('three').Matrix4Tuple;
+                (array?: ArrayLike<number>, offset?: number): ArrayLike<number>;
             };
-            setFromMatrix3: (m: import("three").Matrix3) => import("three").Matrix4;
-            extractPosition: (m: import("three").Matrix4) => import("three").Matrix4;
-            setRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
+            setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
+            extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
+            setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
             multiplyVector3: (v: any) => any;
             multiplyVector4: (v: any) => any;
             multiplyVector3Array: (array: number[]) => number[];
             rotateAxis: (v: any) => void;
             crossVector: (v: any) => void;
             flattenToArrayOffset: (array: number[], offset: number) => number[];
-            getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
+            getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
         };
         matrixAutoUpdate: boolean;
         matrixWorldAutoUpdate: boolean;
@@ -3578,26 +3618,26 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                     readonly BYTES_PER_ELEMENT: number;
                     readonly buffer: {
                         readonly byteLength: number;
-                        slice: (begin: number, end?: number | undefined) => ArrayBuffer;
+                        slice: (begin: number, end?: number) => ArrayBuffer;
                         readonly [Symbol.toStringTag]: string;
                     } | {
                         readonly byteLength: number;
-                        slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
+                        slice: (begin: number, end?: number) => SharedArrayBuffer;
                         readonly [Symbol.species]: SharedArrayBuffer;
                         readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                     };
                     readonly byteLength: number;
                     readonly byteOffset: number;
-                    copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
+                    copyWithin: (target: number, start: number, end?: number) => Float32Array;
                     every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
-                    fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
+                    fill: (value: number, start?: number, end?: number) => Float32Array;
                     filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                     find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                     findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                     forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
-                    indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
-                    join: (separator?: string | undefined) => string;
-                    lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
+                    indexOf: (searchElement: number, fromIndex?: number) => number;
+                    join: (separator?: string) => string;
+                    lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                     readonly length: number;
                     map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                     reduce: {
@@ -3608,21 +3648,24 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                     reduceRight: {
                         (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                         (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
-                        <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
+                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                     };
                     reverse: () => Float32Array;
-                    set: (array: ArrayLike<number>, offset?: number | undefined) => void;
-                    slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
+                    set: (array: ArrayLike<number>, offset?: number) => void;
+                    slice: (start?: number, end?: number) => Float32Array;
                     some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                     sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
-                    subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
-                    toLocaleString: () => string;
+                    subarray: (begin?: number, end?: number) => Float32Array;
+                    toLocaleString: {
+                        (): string;
+                        (locales: string | string[], options?: Intl.NumberFormatOptions): string;
+                    };
                     toString: () => string;
                     valueOf: () => Float32Array;
                     entries: () => IterableIterator<[number, number]>;
                     keys: () => IterableIterator<number>;
                     values: () => IterableIterator<number>;
-                    includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
+                    includes: (searchElement: number, fromIndex?: number) => boolean;
                     at: (index: number) => number | undefined;
                     findLast: {
                         <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
@@ -3640,26 +3683,26 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                     readonly BYTES_PER_ELEMENT: number;
                     readonly buffer: {
                         readonly byteLength: number;
-                        slice: (begin: number, end?: number | undefined) => ArrayBuffer;
+                        slice: (begin: number, end?: number) => ArrayBuffer;
                         readonly [Symbol.toStringTag]: string;
                     } | {
                         readonly byteLength: number;
-                        slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
+                        slice: (begin: number, end?: number) => SharedArrayBuffer;
                         readonly [Symbol.species]: SharedArrayBuffer;
                         readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                     };
                     readonly byteLength: number;
                     readonly byteOffset: number;
-                    copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
+                    copyWithin: (target: number, start: number, end?: number) => Float32Array;
                     every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
-                    fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
+                    fill: (value: number, start?: number, end?: number) => Float32Array;
                     filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                     find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                     findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                     forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
-                    indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
-                    join: (separator?: string | undefined) => string;
-                    lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
+                    indexOf: (searchElement: number, fromIndex?: number) => number;
+                    join: (separator?: string) => string;
+                    lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                     readonly length: number;
                     map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                     reduce: {
@@ -3670,21 +3713,24 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                     reduceRight: {
                         (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                         (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
-                        <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
+                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                     };
                     reverse: () => Float32Array;
-                    set: (array: ArrayLike<number>, offset?: number | undefined) => void;
-                    slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
+                    set: (array: ArrayLike<number>, offset?: number) => void;
+                    slice: (start?: number, end?: number) => Float32Array;
                     some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                     sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
-                    subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
-                    toLocaleString: () => string;
+                    subarray: (begin?: number, end?: number) => Float32Array;
+                    toLocaleString: {
+                        (): string;
+                        (locales: string | string[], options?: Intl.NumberFormatOptions): string;
+                    };
                     toString: () => string;
                     valueOf: () => Float32Array;
                     entries: () => IterableIterator<[number, number]>;
                     keys: () => IterableIterator<number>;
                     values: () => IterableIterator<number>;
-                    includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
+                    includes: (searchElement: number, fromIndex?: number) => boolean;
                     at: (index: number) => number | undefined;
                     findLast: {
                         <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
@@ -3703,26 +3749,26 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                     readonly BYTES_PER_ELEMENT: number;
                     readonly buffer: {
                         readonly byteLength: number;
-                        slice: (begin: number, end?: number | undefined) => ArrayBuffer;
+                        slice: (begin: number, end?: number) => ArrayBuffer;
                         readonly [Symbol.toStringTag]: string;
                     } | {
                         readonly byteLength: number;
-                        slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
+                        slice: (begin: number, end?: number) => SharedArrayBuffer;
                         readonly [Symbol.species]: SharedArrayBuffer;
                         readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                     };
                     readonly byteLength: number;
                     readonly byteOffset: number;
-                    copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
+                    copyWithin: (target: number, start: number, end?: number) => Float32Array;
                     every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
-                    fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
+                    fill: (value: number, start?: number, end?: number) => Float32Array;
                     filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                     find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                     findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                     forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
-                    indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
-                    join: (separator?: string | undefined) => string;
-                    lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
+                    indexOf: (searchElement: number, fromIndex?: number) => number;
+                    join: (separator?: string) => string;
+                    lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                     readonly length: number;
                     map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                     reduce: {
@@ -3733,21 +3779,24 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                     reduceRight: {
                         (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                         (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
-                        <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
+                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                     };
                     reverse: () => Float32Array;
-                    set: (array: ArrayLike<number>, offset?: number | undefined) => void;
-                    slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
+                    set: (array: ArrayLike<number>, offset?: number) => void;
+                    slice: (start?: number, end?: number) => Float32Array;
                     some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                     sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
-                    subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
-                    toLocaleString: () => string;
+                    subarray: (begin?: number, end?: number) => Float32Array;
+                    toLocaleString: {
+                        (): string;
+                        (locales: string | string[], options?: Intl.NumberFormatOptions): string;
+                    };
                     toString: () => string;
                     valueOf: () => Float32Array;
                     entries: () => IterableIterator<[number, number]>;
                     keys: () => IterableIterator<number>;
                     values: () => IterableIterator<number>;
-                    includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
+                    includes: (searchElement: number, fromIndex?: number) => boolean;
                     at: (index: number) => number | undefined;
                     findLast: {
                         <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
@@ -3765,26 +3814,26 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                     readonly BYTES_PER_ELEMENT: number;
                     readonly buffer: {
                         readonly byteLength: number;
-                        slice: (begin: number, end?: number | undefined) => ArrayBuffer;
+                        slice: (begin: number, end?: number) => ArrayBuffer;
                         readonly [Symbol.toStringTag]: string;
                     } | {
                         readonly byteLength: number;
-                        slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
+                        slice: (begin: number, end?: number) => SharedArrayBuffer;
                         readonly [Symbol.species]: SharedArrayBuffer;
                         readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                     };
                     readonly byteLength: number;
                     readonly byteOffset: number;
-                    copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
+                    copyWithin: (target: number, start: number, end?: number) => Float32Array;
                     every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
-                    fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
+                    fill: (value: number, start?: number, end?: number) => Float32Array;
                     filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                     find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                     findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                     forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
-                    indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
-                    join: (separator?: string | undefined) => string;
-                    lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
+                    indexOf: (searchElement: number, fromIndex?: number) => number;
+                    join: (separator?: string) => string;
+                    lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                     readonly length: number;
                     map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                     reduce: {
@@ -3795,21 +3844,24 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                     reduceRight: {
                         (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                         (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
-                        <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
+                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                     };
                     reverse: () => Float32Array;
-                    set: (array: ArrayLike<number>, offset?: number | undefined) => void;
-                    slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
+                    set: (array: ArrayLike<number>, offset?: number) => void;
+                    slice: (start?: number, end?: number) => Float32Array;
                     some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                     sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
-                    subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
-                    toLocaleString: () => string;
+                    subarray: (begin?: number, end?: number) => Float32Array;
+                    toLocaleString: {
+                        (): string;
+                        (locales: string | string[], options?: Intl.NumberFormatOptions): string;
+                    };
                     toString: () => string;
                     valueOf: () => Float32Array;
                     entries: () => IterableIterator<[number, number]>;
                     keys: () => IterableIterator<number>;
                     values: () => IterableIterator<number>;
-                    includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
+                    includes: (searchElement: number, fromIndex?: number) => boolean;
                     at: (index: number) => number | undefined;
                     findLast: {
                         <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
@@ -3822,31 +3874,31 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                     [Symbol.iterator]: () => IterableIterator<number>;
                     readonly [Symbol.toStringTag]: "Float32Array";
                 };
-                DefaultInterpolation: import("three").InterpolationModes;
-                InterpolantFactoryMethodDiscrete: (result: any) => import("three").DiscreteInterpolant;
-                InterpolantFactoryMethodLinear: (result: any) => import("three").LinearInterpolant;
-                InterpolantFactoryMethodSmooth: (result: any) => import("three").CubicInterpolant;
-                setInterpolation: (interpolation: import("three").InterpolationModes) => import("three").KeyframeTrack;
-                getInterpolation: () => import("three").InterpolationModes;
-                createInterpolant: () => import("three").Interpolant;
+                DefaultInterpolation: import('three').InterpolationModes;
+                InterpolantFactoryMethodDiscrete: (result: any) => import('three').DiscreteInterpolant;
+                InterpolantFactoryMethodLinear: (result: any) => import('three').LinearInterpolant;
+                InterpolantFactoryMethodSmooth: (result: any) => import('three').CubicInterpolant;
+                setInterpolation: (interpolation: import('three').InterpolationModes) => import('three').KeyframeTrack;
+                getInterpolation: () => import('three').InterpolationModes;
+                createInterpolant: () => import('three').Interpolant;
                 getValueSize: () => number;
-                shift: (timeOffset: number) => import("three").KeyframeTrack;
-                scale: (timeScale: number) => import("three").KeyframeTrack;
-                trim: (startTime: number, endTime: number) => import("three").KeyframeTrack;
+                shift: (timeOffset: number) => import('three').KeyframeTrack;
+                scale: (timeScale: number) => import('three').KeyframeTrack;
+                trim: (startTime: number, endTime: number) => import('three').KeyframeTrack;
                 validate: () => boolean;
-                optimize: () => import("three").KeyframeTrack;
-                clone: () => import("three").KeyframeTrack;
+                optimize: () => import('three').KeyframeTrack;
+                clone: () => import('three').KeyframeTrack;
             }[];
-            blendMode: import("three").AnimationBlendMode;
+            blendMode: import('three').AnimationBlendMode;
             duration: number;
             uuid: string;
             results: any[];
-            resetDuration: () => import("three").AnimationClip;
-            trim: () => import("three").AnimationClip;
+            resetDuration: () => import('three').AnimationClip;
+            trim: () => import('three').AnimationClip;
             validate: () => boolean;
-            optimize: () => import("three").AnimationClip;
-            clone: () => import("three").AnimationClip;
-            toJSON: (clip: import("three").AnimationClip) => any;
+            optimize: () => import('three').AnimationClip;
+            clone: () => import('three').AnimationClip;
+            toJSON: (clip: import('three').AnimationClip) => any;
         }[];
         userData: Record<string, any>;
         customDepthMaterial?: {
@@ -3859,52 +3911,52 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                 r: number;
                 g: number;
                 b: number;
-                set: (...args: [color: import("three").ColorRepresentation] | [r: number, g: number, b: number]) => import("three").Color;
-                setFromVector3: (vector: import("three").Vector3) => import("three").Color;
-                setScalar: (scalar: number) => import("three").Color;
-                setHex: (hex: number, colorSpace?: import("three").ColorSpace | undefined) => import("three").Color;
-                setRGB: (r: number, g: number, b: number, colorSpace?: import("three").ColorSpace | undefined) => import("three").Color;
-                setHSL: (h: number, s: number, l: number, colorSpace?: import("three").ColorSpace | undefined) => import("three").Color;
-                setStyle: (style: string, colorSpace?: import("three").ColorSpace | undefined) => import("three").Color;
-                setColorName: (style: string, colorSpace?: import("three").ColorSpace | undefined) => import("three").Color;
-                clone: () => import("three").Color;
-                copy: (color: import("three").Color) => import("three").Color;
-                copySRGBToLinear: (color: import("three").Color) => import("three").Color;
-                copyLinearToSRGB: (color: import("three").Color) => import("three").Color;
-                convertSRGBToLinear: () => import("three").Color;
-                convertLinearToSRGB: () => import("three").Color;
-                getHex: (colorSpace?: import("three").ColorSpace | undefined) => number;
-                getHexString: (colorSpace?: import("three").ColorSpace | undefined) => string;
-                getHSL: (target: import("three").HSL, colorSpace?: import("three").ColorSpace | undefined) => import("three").HSL;
-                getRGB: (target: import("three").RGB, colorSpace?: import("three").ColorSpace | undefined) => import("three").RGB;
-                getStyle: (colorSpace?: import("three").ColorSpace | undefined) => string;
-                offsetHSL: (h: number, s: number, l: number) => import("three").Color;
-                add: (color: import("three").Color) => import("three").Color;
-                addColors: (color1: import("three").Color, color2: import("three").Color) => import("three").Color;
-                addScalar: (s: number) => import("three").Color;
-                applyMatrix3: (m: import("three").Matrix3) => import("three").Color;
-                sub: (color: import("three").Color) => import("three").Color;
-                multiply: (color: import("three").Color) => import("three").Color;
-                multiplyScalar: (s: number) => import("three").Color;
-                lerp: (color: import("three").Color, alpha: number) => import("three").Color;
-                lerpColors: (color1: import("three").Color, color2: import("three").Color, alpha: number) => import("three").Color;
-                lerpHSL: (color: import("three").Color, alpha: number) => import("three").Color;
-                equals: (color: import("three").Color) => boolean;
-                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Color;
+                set: (...args: [color: import('three').ColorRepresentation] | [r: number, g: number, b: number]) => import('three').Color;
+                setFromVector3: (vector: import('three').Vector3) => import('three').Color;
+                setScalar: (scalar: number) => import('three').Color;
+                setHex: (hex: number, colorSpace?: import('three').ColorSpace) => import('three').Color;
+                setRGB: (r: number, g: number, b: number, colorSpace?: import('three').ColorSpace) => import('three').Color;
+                setHSL: (h: number, s: number, l: number, colorSpace?: import('three').ColorSpace) => import('three').Color;
+                setStyle: (style: string, colorSpace?: import('three').ColorSpace) => import('three').Color;
+                setColorName: (style: string, colorSpace?: import('three').ColorSpace) => import('three').Color;
+                clone: () => import('three').Color;
+                copy: (color: import('three').Color) => import('three').Color;
+                copySRGBToLinear: (color: import('three').Color) => import('three').Color;
+                copyLinearToSRGB: (color: import('three').Color) => import('three').Color;
+                convertSRGBToLinear: () => import('three').Color;
+                convertLinearToSRGB: () => import('three').Color;
+                getHex: (colorSpace?: import('three').ColorSpace) => number;
+                getHexString: (colorSpace?: import('three').ColorSpace) => string;
+                getHSL: (target: import('three').HSL, colorSpace?: import('three').ColorSpace) => import('three').HSL;
+                getRGB: (target: import('three').RGB, colorSpace?: import('three').ColorSpace) => import('three').RGB;
+                getStyle: (colorSpace?: import('three').ColorSpace) => string;
+                offsetHSL: (h: number, s: number, l: number) => import('three').Color;
+                add: (color: import('three').Color) => import('three').Color;
+                addColors: (color1: import('three').Color, color2: import('three').Color) => import('three').Color;
+                addScalar: (s: number) => import('three').Color;
+                applyMatrix3: (m: import('three').Matrix3) => import('three').Color;
+                sub: (color: import('three').Color) => import('three').Color;
+                multiply: (color: import('three').Color) => import('three').Color;
+                multiplyScalar: (s: number) => import('three').Color;
+                lerp: (color: import('three').Color, alpha: number) => import('three').Color;
+                lerpColors: (color1: import('three').Color, color2: import('three').Color, alpha: number) => import('three').Color;
+                lerpHSL: (color: import('three').Color, alpha: number) => import('three').Color;
+                equals: (color: import('three').Color) => boolean;
+                fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Color;
                 toArray: {
-                    (array?: number[] | undefined, offset?: number | undefined): number[];
-                    (xyz: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
+                    (array?: number[], offset?: number): number[];
+                    (xyz: ArrayLike<number>, offset?: number): ArrayLike<number>;
                 };
                 toJSON: () => number;
-                fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => import("three").Color;
-                [Symbol.iterator]: () => Generator<number, void, unknown>;
+                fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Color;
+                [Symbol.iterator]: () => Generator<number, void>;
             };
-            blendDst: import("three").BlendingDstFactor;
+            blendDst: import('three').BlendingDstFactor;
             blendDstAlpha: number | null;
-            blendEquation: import("three").BlendingEquation;
+            blendEquation: import('three').BlendingEquation;
             blendEquationAlpha: number | null;
-            blending: import("three").Blending;
-            blendSrc: 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207 | 208 | 209 | 211 | 212 | 213 | 214 | 210;
+            blending: import('three').Blending;
+            blendSrc: import('three').BlendingSrcFactor | import('three').BlendingDstFactor;
             blendSrcAlpha: number | null;
             clipIntersection: boolean;
             clippingPlanes: {
@@ -3913,125 +3965,125 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                     y: number;
                     z: number;
                     readonly isVector3: true;
-                    set: (x: number, y: number, z: number) => import("three").Vector3;
-                    setScalar: (scalar: number) => import("three").Vector3;
-                    setX: (x: number) => import("three").Vector3;
-                    setY: (y: number) => import("three").Vector3;
-                    setZ: (z: number) => import("three").Vector3;
-                    setComponent: (index: number, value: number) => import("three").Vector3;
+                    set: (x: number, y: number, z: number) => import('three').Vector3;
+                    setScalar: (scalar: number) => import('three').Vector3;
+                    setX: (x: number) => import('three').Vector3;
+                    setY: (y: number) => import('three').Vector3;
+                    setZ: (z: number) => import('three').Vector3;
+                    setComponent: (index: number, value: number) => import('three').Vector3;
                     getComponent: (index: number) => number;
-                    clone: () => import("three").Vector3;
-                    copy: (v: import("three").Vector3Like) => import("three").Vector3;
-                    add: (v: import("three").Vector3Like) => import("three").Vector3;
-                    addScalar: (s: number) => import("three").Vector3;
-                    addVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                    addScaledVector: (v: import("three").Vector3, s: number) => import("three").Vector3;
-                    sub: (a: import("three").Vector3Like) => import("three").Vector3;
-                    subScalar: (s: number) => import("three").Vector3;
-                    subVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                    multiply: (v: import("three").Vector3Like) => import("three").Vector3;
-                    multiplyScalar: (s: number) => import("three").Vector3;
-                    multiplyVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                    applyEuler: (euler: import("three").Euler) => import("three").Vector3;
-                    applyAxisAngle: (axis: import("three").Vector3, angle: number) => import("three").Vector3;
-                    applyMatrix3: (m: import("three").Matrix3) => import("three").Vector3;
-                    applyNormalMatrix: (m: import("three").Matrix3) => import("three").Vector3;
-                    applyMatrix4: (m: import("three").Matrix4) => import("three").Vector3;
-                    applyQuaternion: (q: import("three").QuaternionLike) => import("three").Vector3;
-                    project: (camera: Camera) => import("three").Vector3;
-                    unproject: (camera: Camera) => import("three").Vector3;
-                    transformDirection: (m: import("three").Matrix4) => import("three").Vector3;
-                    divide: (v: import("three").Vector3Like) => import("three").Vector3;
-                    divideScalar: (s: number) => import("three").Vector3;
-                    min: (v: import("three").Vector3Like) => import("three").Vector3;
-                    max: (v: import("three").Vector3Like) => import("three").Vector3;
-                    clamp: (min: import("three").Vector3Like, max: import("three").Vector3Like) => import("three").Vector3;
-                    clampScalar: (min: number, max: number) => import("three").Vector3;
-                    clampLength: (min: number, max: number) => import("three").Vector3;
-                    floor: () => import("three").Vector3;
-                    ceil: () => import("three").Vector3;
-                    round: () => import("three").Vector3;
-                    roundToZero: () => import("three").Vector3;
-                    negate: () => import("three").Vector3;
-                    dot: (v: import("three").Vector3Like) => number;
+                    clone: () => import('three').Vector3;
+                    copy: (v: import('three').Vector3Like) => import('three').Vector3;
+                    add: (v: import('three').Vector3Like) => import('three').Vector3;
+                    addScalar: (s: number) => import('three').Vector3;
+                    addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                    addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
+                    sub: (a: import('three').Vector3Like) => import('three').Vector3;
+                    subScalar: (s: number) => import('three').Vector3;
+                    subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                    multiply: (v: import('three').Vector3Like) => import('three').Vector3;
+                    multiplyScalar: (s: number) => import('three').Vector3;
+                    multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                    applyEuler: (euler: import('three').Euler) => import('three').Vector3;
+                    applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
+                    applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
+                    applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
+                    applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
+                    applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
+                    project: (camera: Camera) => import('three').Vector3;
+                    unproject: (camera: Camera) => import('three').Vector3;
+                    transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
+                    divide: (v: import('three').Vector3Like) => import('three').Vector3;
+                    divideScalar: (s: number) => import('three').Vector3;
+                    min: (v: import('three').Vector3Like) => import('three').Vector3;
+                    max: (v: import('three').Vector3Like) => import('three').Vector3;
+                    clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
+                    clampScalar: (min: number, max: number) => import('three').Vector3;
+                    clampLength: (min: number, max: number) => import('three').Vector3;
+                    floor: () => import('three').Vector3;
+                    ceil: () => import('three').Vector3;
+                    round: () => import('three').Vector3;
+                    roundToZero: () => import('three').Vector3;
+                    negate: () => import('three').Vector3;
+                    dot: (v: import('three').Vector3Like) => number;
                     lengthSq: () => number;
                     length: () => number;
                     manhattanLength: () => number;
-                    normalize: () => import("three").Vector3;
-                    setLength: (l: number) => import("three").Vector3;
-                    lerp: (v: import("three").Vector3Like, alpha: number) => import("three").Vector3;
-                    lerpVectors: (v1: import("three").Vector3Like, v2: import("three").Vector3Like, alpha: number) => import("three").Vector3;
-                    cross: (a: import("three").Vector3Like) => import("three").Vector3;
-                    crossVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                    projectOnVector: (v: import("three").Vector3) => import("three").Vector3;
-                    projectOnPlane: (planeNormal: import("three").Vector3) => import("three").Vector3;
-                    reflect: (vector: import("three").Vector3Like) => import("three").Vector3;
-                    angleTo: (v: import("three").Vector3) => number;
-                    distanceTo: (v: import("three").Vector3Like) => number;
-                    distanceToSquared: (v: import("three").Vector3Like) => number;
-                    manhattanDistanceTo: (v: import("three").Vector3Like) => number;
-                    setFromSpherical: (s: import("three").Spherical) => import("three").Vector3;
-                    setFromSphericalCoords: (r: number, phi: number, theta: number) => import("three").Vector3;
-                    setFromCylindrical: (s: import("three").Cylindrical) => import("three").Vector3;
-                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => import("three").Vector3;
-                    setFromMatrixPosition: (m: import("three").Matrix4) => import("three").Vector3;
-                    setFromMatrixScale: (m: import("three").Matrix4) => import("three").Vector3;
-                    setFromMatrixColumn: (matrix: import("three").Matrix4, index: number) => import("three").Vector3;
-                    setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => import("three").Vector3;
-                    setFromEuler: (e: import("three").Euler) => import("three").Vector3;
-                    setFromColor: (color: import("three").RGB) => import("three").Vector3;
-                    equals: (v: import("three").Vector3Like) => boolean;
-                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector3;
+                    normalize: () => import('three').Vector3;
+                    setLength: (l: number) => import('three').Vector3;
+                    lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
+                    lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
+                    cross: (a: import('three').Vector3Like) => import('three').Vector3;
+                    crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                    projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
+                    projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
+                    reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
+                    angleTo: (v: import('three').Vector3) => number;
+                    distanceTo: (v: import('three').Vector3Like) => number;
+                    distanceToSquared: (v: import('three').Vector3Like) => number;
+                    manhattanDistanceTo: (v: import('three').Vector3Like) => number;
+                    setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
+                    setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
+                    setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
+                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
+                    setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
+                    setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
+                    setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
+                    setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
+                    setFromEuler: (e: import('three').Euler) => import('three').Vector3;
+                    setFromColor: (color: import('three').RGB) => import('three').Vector3;
+                    equals: (v: import('three').Vector3Like) => boolean;
+                    fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector3;
                     toArray: {
-                        (array?: number[] | undefined, offset?: number | undefined): number[];
-                        (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
-                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
+                        (array?: number[], offset?: number): number[];
+                        (array?: import('three').Vector3Tuple, offset?: 0): import('three').Vector3Tuple;
+                        (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                     };
-                    fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => import("three").Vector3;
-                    random: () => import("three").Vector3;
-                    randomDirection: () => import("three").Vector3;
-                    [Symbol.iterator]: () => Iterator<number, any, undefined>;
+                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
+                    random: () => import('three').Vector3;
+                    randomDirection: () => import('three').Vector3;
+                    [Symbol.iterator]: () => Iterator<number>;
                 };
                 constant: number;
                 readonly isPlane: true;
-                set: (normal: import("three").Vector3, constant: number) => import("three").Plane;
-                setComponents: (x: number, y: number, z: number, w: number) => import("three").Plane;
-                setFromNormalAndCoplanarPoint: (normal: import("three").Vector3, point: import("three").Vector3) => import("three").Plane;
-                setFromCoplanarPoints: (a: import("three").Vector3, b: import("three").Vector3, c: import("three").Vector3) => import("three").Plane;
-                clone: () => import("three").Plane;
-                copy: (plane: import("three").Plane) => import("three").Plane;
-                normalize: () => import("three").Plane;
-                negate: () => import("three").Plane;
-                distanceToPoint: (point: import("three").Vector3) => number;
-                distanceToSphere: (sphere: import("three").Sphere) => number;
-                projectPoint: (point: import("three").Vector3, target: import("three").Vector3) => import("three").Vector3;
-                intersectLine: (line: import("three").Line3, target: import("three").Vector3) => import("three").Vector3 | null;
-                intersectsLine: (line: import("three").Line3) => boolean;
-                intersectsBox: (box: import("three").Box3) => boolean;
-                intersectsSphere: (sphere: import("three").Sphere) => boolean;
-                coplanarPoint: (target: import("three").Vector3) => import("three").Vector3;
-                applyMatrix4: (matrix: import("three").Matrix4, optionalNormalMatrix?: import("three").Matrix3 | undefined) => import("three").Plane;
-                translate: (offset: import("three").Vector3) => import("three").Plane;
-                equals: (plane: import("three").Plane) => boolean;
+                set: (normal: import('three').Vector3, constant: number) => import('three').Plane;
+                setComponents: (x: number, y: number, z: number, w: number) => import('three').Plane;
+                setFromNormalAndCoplanarPoint: (normal: import('three').Vector3, point: import('three').Vector3) => import('three').Plane;
+                setFromCoplanarPoints: (a: import('three').Vector3, b: import('three').Vector3, c: import('three').Vector3) => import('three').Plane;
+                clone: () => import('three').Plane;
+                copy: (plane: import('three').Plane) => import('three').Plane;
+                normalize: () => import('three').Plane;
+                negate: () => import('three').Plane;
+                distanceToPoint: (point: import('three').Vector3) => number;
+                distanceToSphere: (sphere: import('three').Sphere) => number;
+                projectPoint: (point: import('three').Vector3, target: import('three').Vector3) => import('three').Vector3;
+                intersectLine: (line: import('three').Line3, target: import('three').Vector3) => import('three').Vector3 | null;
+                intersectsLine: (line: import('three').Line3) => boolean;
+                intersectsBox: (box: import('three').Box3) => boolean;
+                intersectsSphere: (sphere: import('three').Sphere) => boolean;
+                coplanarPoint: (target: import('three').Vector3) => import('three').Vector3;
+                applyMatrix4: (matrix: import('three').Matrix4, optionalNormalMatrix?: import('three').Matrix3) => import('three').Plane;
+                translate: (offset: import('three').Vector3) => import('three').Plane;
+                equals: (plane: import('three').Plane) => boolean;
                 isIntersectionLine: (l: any) => any;
             }[] | null;
             clipShadows: boolean;
             colorWrite: boolean;
-            defines: {
+            defines: undefined | {
                 [key: string]: any;
-            } | undefined;
-            depthFunc: import("three").DepthModes;
+            };
+            depthFunc: import('three').DepthModes;
             depthTest: boolean;
             depthWrite: boolean;
             id: number;
             stencilWrite: boolean;
-            stencilFunc: import("three").StencilFunc;
+            stencilFunc: import('three').StencilFunc;
             stencilRef: number;
             stencilWriteMask: number;
             stencilFuncMask: number;
-            stencilFail: import("three").StencilOp;
-            stencilZFail: import("three").StencilOp;
-            stencilZPass: import("three").StencilOp;
+            stencilFail: import('three').StencilOp;
+            stencilZFail: import('three').StencilOp;
+            stencilZPass: import('three').StencilOp;
             name: string;
             opacity: number;
             polygonOffset: boolean;
@@ -4041,8 +4093,8 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
             premultipliedAlpha: boolean;
             forceSinglePass: boolean;
             dithering: boolean;
-            side: import("three").Side;
-            shadowSide: import("three").Side | null;
+            side: import('three').Side;
+            shadowSide: import('three').Side | null;
             toneMapped: boolean;
             transparent: boolean;
             type: string;
@@ -4052,37 +4104,37 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
             userData: Record<string, any>;
             version: number;
             alphaTest: number;
-            onBuild: (object: import("three").Object3D<import("three").Object3DEventMap>, parameters: import("three").WebGLProgramParametersWithUniforms, renderer: import("three").WebGLRenderer) => void;
-            onBeforeRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: Camera, geometry: import("three").BufferGeometry<import("three").NormalBufferAttributes>, object: import("three").Object3D<import("three").Object3DEventMap>, group: import("three").Group<import("three").Object3DEventMap>) => void;
-            onBeforeCompile: (parameters: import("three").WebGLProgramParametersWithUniforms, renderer: import("three").WebGLRenderer) => void;
+            onBeforeCompile: (parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
             customProgramCacheKey: () => string;
-            setValues: (values: import("three").MaterialParameters) => void;
+            setValues: (values: import('three').MaterialParameters) => void;
             toJSON: (meta?: any) => any;
-            clone: () => import("three").Material;
-            copy: (material: import("three").Material) => import("three").Material;
+            clone: () => import('three').Material;
+            copy: (material: import('three').Material) => import('three').Material;
             dispose: () => void;
             needsUpdate: boolean;
+            onBuild: (object: import('three').Object3D, parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
+            onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry, object: import('three').Object3D, group: import('three').Group) => void;
             addEventListener: {
-                <T extends "dispose">(type: T, listener: import("three").EventListener<{
+                <T extends "dispose">(type: T, listener: import('three').EventListener<{
                     dispose: {};
-                }[T], T, import("three").Material>): void;
-                <T_1 extends string>(type: T_1, listener: import("three").EventListener<{}, T_1, import("three").Material>): void;
+                }[T], T, import('three').Material>): void;
+                <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Material>): void;
             };
             hasEventListener: {
-                <T_2 extends "dispose">(type: T_2, listener: import("three").EventListener<{
+                <T extends "dispose">(type: T, listener: import('three').EventListener<{
                     dispose: {};
-                }[T_2], T_2, import("three").Material>): boolean;
-                <T_3 extends string>(type: T_3, listener: import("three").EventListener<{}, T_3, import("three").Material>): boolean;
+                }[T], T, import('three').Material>): boolean;
+                <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Material>): boolean;
             };
             removeEventListener: {
-                <T_4 extends "dispose">(type: T_4, listener: import("three").EventListener<{
+                <T extends "dispose">(type: T, listener: import('three').EventListener<{
                     dispose: {};
-                }[T_4], T_4, import("three").Material>): void;
-                <T_5 extends string>(type: T_5, listener: import("three").EventListener<{}, T_5, import("three").Material>): void;
+                }[T], T, import('three').Material>): void;
+                <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Material>): void;
             };
-            dispatchEvent: <T_6 extends "dispose">(event: import("three").BaseEvent<T_6> & {
+            dispatchEvent: <T extends "dispose">(event: import('three').BaseEvent<T> & {
                 dispose: {};
-            }[T_6]) => void;
+            }[T]) => void;
         } | undefined;
         customDistanceMaterial?: {
             readonly isMaterial: true;
@@ -4094,52 +4146,52 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                 r: number;
                 g: number;
                 b: number;
-                set: (...args: [color: import("three").ColorRepresentation] | [r: number, g: number, b: number]) => import("three").Color;
-                setFromVector3: (vector: import("three").Vector3) => import("three").Color;
-                setScalar: (scalar: number) => import("three").Color;
-                setHex: (hex: number, colorSpace?: import("three").ColorSpace | undefined) => import("three").Color;
-                setRGB: (r: number, g: number, b: number, colorSpace?: import("three").ColorSpace | undefined) => import("three").Color;
-                setHSL: (h: number, s: number, l: number, colorSpace?: import("three").ColorSpace | undefined) => import("three").Color;
-                setStyle: (style: string, colorSpace?: import("three").ColorSpace | undefined) => import("three").Color;
-                setColorName: (style: string, colorSpace?: import("three").ColorSpace | undefined) => import("three").Color;
-                clone: () => import("three").Color;
-                copy: (color: import("three").Color) => import("three").Color;
-                copySRGBToLinear: (color: import("three").Color) => import("three").Color;
-                copyLinearToSRGB: (color: import("three").Color) => import("three").Color;
-                convertSRGBToLinear: () => import("three").Color;
-                convertLinearToSRGB: () => import("three").Color;
-                getHex: (colorSpace?: import("three").ColorSpace | undefined) => number;
-                getHexString: (colorSpace?: import("three").ColorSpace | undefined) => string;
-                getHSL: (target: import("three").HSL, colorSpace?: import("three").ColorSpace | undefined) => import("three").HSL;
-                getRGB: (target: import("three").RGB, colorSpace?: import("three").ColorSpace | undefined) => import("three").RGB;
-                getStyle: (colorSpace?: import("three").ColorSpace | undefined) => string;
-                offsetHSL: (h: number, s: number, l: number) => import("three").Color;
-                add: (color: import("three").Color) => import("three").Color;
-                addColors: (color1: import("three").Color, color2: import("three").Color) => import("three").Color;
-                addScalar: (s: number) => import("three").Color;
-                applyMatrix3: (m: import("three").Matrix3) => import("three").Color;
-                sub: (color: import("three").Color) => import("three").Color;
-                multiply: (color: import("three").Color) => import("three").Color;
-                multiplyScalar: (s: number) => import("three").Color;
-                lerp: (color: import("three").Color, alpha: number) => import("three").Color;
-                lerpColors: (color1: import("three").Color, color2: import("three").Color, alpha: number) => import("three").Color;
-                lerpHSL: (color: import("three").Color, alpha: number) => import("three").Color;
-                equals: (color: import("three").Color) => boolean;
-                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Color;
+                set: (...args: [color: import('three').ColorRepresentation] | [r: number, g: number, b: number]) => import('three').Color;
+                setFromVector3: (vector: import('three').Vector3) => import('three').Color;
+                setScalar: (scalar: number) => import('three').Color;
+                setHex: (hex: number, colorSpace?: import('three').ColorSpace) => import('three').Color;
+                setRGB: (r: number, g: number, b: number, colorSpace?: import('three').ColorSpace) => import('three').Color;
+                setHSL: (h: number, s: number, l: number, colorSpace?: import('three').ColorSpace) => import('three').Color;
+                setStyle: (style: string, colorSpace?: import('three').ColorSpace) => import('three').Color;
+                setColorName: (style: string, colorSpace?: import('three').ColorSpace) => import('three').Color;
+                clone: () => import('three').Color;
+                copy: (color: import('three').Color) => import('three').Color;
+                copySRGBToLinear: (color: import('three').Color) => import('three').Color;
+                copyLinearToSRGB: (color: import('three').Color) => import('three').Color;
+                convertSRGBToLinear: () => import('three').Color;
+                convertLinearToSRGB: () => import('three').Color;
+                getHex: (colorSpace?: import('three').ColorSpace) => number;
+                getHexString: (colorSpace?: import('three').ColorSpace) => string;
+                getHSL: (target: import('three').HSL, colorSpace?: import('three').ColorSpace) => import('three').HSL;
+                getRGB: (target: import('three').RGB, colorSpace?: import('three').ColorSpace) => import('three').RGB;
+                getStyle: (colorSpace?: import('three').ColorSpace) => string;
+                offsetHSL: (h: number, s: number, l: number) => import('three').Color;
+                add: (color: import('three').Color) => import('three').Color;
+                addColors: (color1: import('three').Color, color2: import('three').Color) => import('three').Color;
+                addScalar: (s: number) => import('three').Color;
+                applyMatrix3: (m: import('three').Matrix3) => import('three').Color;
+                sub: (color: import('three').Color) => import('three').Color;
+                multiply: (color: import('three').Color) => import('three').Color;
+                multiplyScalar: (s: number) => import('three').Color;
+                lerp: (color: import('three').Color, alpha: number) => import('three').Color;
+                lerpColors: (color1: import('three').Color, color2: import('three').Color, alpha: number) => import('three').Color;
+                lerpHSL: (color: import('three').Color, alpha: number) => import('three').Color;
+                equals: (color: import('three').Color) => boolean;
+                fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Color;
                 toArray: {
-                    (array?: number[] | undefined, offset?: number | undefined): number[];
-                    (xyz: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
+                    (array?: number[], offset?: number): number[];
+                    (xyz: ArrayLike<number>, offset?: number): ArrayLike<number>;
                 };
                 toJSON: () => number;
-                fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => import("three").Color;
-                [Symbol.iterator]: () => Generator<number, void, unknown>;
+                fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Color;
+                [Symbol.iterator]: () => Generator<number, void>;
             };
-            blendDst: import("three").BlendingDstFactor;
+            blendDst: import('three').BlendingDstFactor;
             blendDstAlpha: number | null;
-            blendEquation: import("three").BlendingEquation;
+            blendEquation: import('three').BlendingEquation;
             blendEquationAlpha: number | null;
-            blending: import("three").Blending;
-            blendSrc: 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207 | 208 | 209 | 211 | 212 | 213 | 214 | 210;
+            blending: import('three').Blending;
+            blendSrc: import('three').BlendingSrcFactor | import('three').BlendingDstFactor;
             blendSrcAlpha: number | null;
             clipIntersection: boolean;
             clippingPlanes: {
@@ -4148,125 +4200,125 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
                     y: number;
                     z: number;
                     readonly isVector3: true;
-                    set: (x: number, y: number, z: number) => import("three").Vector3;
-                    setScalar: (scalar: number) => import("three").Vector3;
-                    setX: (x: number) => import("three").Vector3;
-                    setY: (y: number) => import("three").Vector3;
-                    setZ: (z: number) => import("three").Vector3;
-                    setComponent: (index: number, value: number) => import("three").Vector3;
+                    set: (x: number, y: number, z: number) => import('three').Vector3;
+                    setScalar: (scalar: number) => import('three').Vector3;
+                    setX: (x: number) => import('three').Vector3;
+                    setY: (y: number) => import('three').Vector3;
+                    setZ: (z: number) => import('three').Vector3;
+                    setComponent: (index: number, value: number) => import('three').Vector3;
                     getComponent: (index: number) => number;
-                    clone: () => import("three").Vector3;
-                    copy: (v: import("three").Vector3Like) => import("three").Vector3;
-                    add: (v: import("three").Vector3Like) => import("three").Vector3;
-                    addScalar: (s: number) => import("three").Vector3;
-                    addVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                    addScaledVector: (v: import("three").Vector3, s: number) => import("three").Vector3;
-                    sub: (a: import("three").Vector3Like) => import("three").Vector3;
-                    subScalar: (s: number) => import("three").Vector3;
-                    subVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                    multiply: (v: import("three").Vector3Like) => import("three").Vector3;
-                    multiplyScalar: (s: number) => import("three").Vector3;
-                    multiplyVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                    applyEuler: (euler: import("three").Euler) => import("three").Vector3;
-                    applyAxisAngle: (axis: import("three").Vector3, angle: number) => import("three").Vector3;
-                    applyMatrix3: (m: import("three").Matrix3) => import("three").Vector3;
-                    applyNormalMatrix: (m: import("three").Matrix3) => import("three").Vector3;
-                    applyMatrix4: (m: import("three").Matrix4) => import("three").Vector3;
-                    applyQuaternion: (q: import("three").QuaternionLike) => import("three").Vector3;
-                    project: (camera: Camera) => import("three").Vector3;
-                    unproject: (camera: Camera) => import("three").Vector3;
-                    transformDirection: (m: import("three").Matrix4) => import("three").Vector3;
-                    divide: (v: import("three").Vector3Like) => import("three").Vector3;
-                    divideScalar: (s: number) => import("three").Vector3;
-                    min: (v: import("three").Vector3Like) => import("three").Vector3;
-                    max: (v: import("three").Vector3Like) => import("three").Vector3;
-                    clamp: (min: import("three").Vector3Like, max: import("three").Vector3Like) => import("three").Vector3;
-                    clampScalar: (min: number, max: number) => import("three").Vector3;
-                    clampLength: (min: number, max: number) => import("three").Vector3;
-                    floor: () => import("three").Vector3;
-                    ceil: () => import("three").Vector3;
-                    round: () => import("three").Vector3;
-                    roundToZero: () => import("three").Vector3;
-                    negate: () => import("three").Vector3;
-                    dot: (v: import("three").Vector3Like) => number;
+                    clone: () => import('three').Vector3;
+                    copy: (v: import('three').Vector3Like) => import('three').Vector3;
+                    add: (v: import('three').Vector3Like) => import('three').Vector3;
+                    addScalar: (s: number) => import('three').Vector3;
+                    addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                    addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
+                    sub: (a: import('three').Vector3Like) => import('three').Vector3;
+                    subScalar: (s: number) => import('three').Vector3;
+                    subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                    multiply: (v: import('three').Vector3Like) => import('three').Vector3;
+                    multiplyScalar: (s: number) => import('three').Vector3;
+                    multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                    applyEuler: (euler: import('three').Euler) => import('three').Vector3;
+                    applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
+                    applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
+                    applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
+                    applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
+                    applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
+                    project: (camera: Camera) => import('three').Vector3;
+                    unproject: (camera: Camera) => import('three').Vector3;
+                    transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
+                    divide: (v: import('three').Vector3Like) => import('three').Vector3;
+                    divideScalar: (s: number) => import('three').Vector3;
+                    min: (v: import('three').Vector3Like) => import('three').Vector3;
+                    max: (v: import('three').Vector3Like) => import('three').Vector3;
+                    clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
+                    clampScalar: (min: number, max: number) => import('three').Vector3;
+                    clampLength: (min: number, max: number) => import('three').Vector3;
+                    floor: () => import('three').Vector3;
+                    ceil: () => import('three').Vector3;
+                    round: () => import('three').Vector3;
+                    roundToZero: () => import('three').Vector3;
+                    negate: () => import('three').Vector3;
+                    dot: (v: import('three').Vector3Like) => number;
                     lengthSq: () => number;
                     length: () => number;
                     manhattanLength: () => number;
-                    normalize: () => import("three").Vector3;
-                    setLength: (l: number) => import("three").Vector3;
-                    lerp: (v: import("three").Vector3Like, alpha: number) => import("three").Vector3;
-                    lerpVectors: (v1: import("three").Vector3Like, v2: import("three").Vector3Like, alpha: number) => import("three").Vector3;
-                    cross: (a: import("three").Vector3Like) => import("three").Vector3;
-                    crossVectors: (a: import("three").Vector3Like, b: import("three").Vector3Like) => import("three").Vector3;
-                    projectOnVector: (v: import("three").Vector3) => import("three").Vector3;
-                    projectOnPlane: (planeNormal: import("three").Vector3) => import("three").Vector3;
-                    reflect: (vector: import("three").Vector3Like) => import("three").Vector3;
-                    angleTo: (v: import("three").Vector3) => number;
-                    distanceTo: (v: import("three").Vector3Like) => number;
-                    distanceToSquared: (v: import("three").Vector3Like) => number;
-                    manhattanDistanceTo: (v: import("three").Vector3Like) => number;
-                    setFromSpherical: (s: import("three").Spherical) => import("three").Vector3;
-                    setFromSphericalCoords: (r: number, phi: number, theta: number) => import("three").Vector3;
-                    setFromCylindrical: (s: import("three").Cylindrical) => import("three").Vector3;
-                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => import("three").Vector3;
-                    setFromMatrixPosition: (m: import("three").Matrix4) => import("three").Vector3;
-                    setFromMatrixScale: (m: import("three").Matrix4) => import("three").Vector3;
-                    setFromMatrixColumn: (matrix: import("three").Matrix4, index: number) => import("three").Vector3;
-                    setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => import("three").Vector3;
-                    setFromEuler: (e: import("three").Euler) => import("three").Vector3;
-                    setFromColor: (color: import("three").RGB) => import("three").Vector3;
-                    equals: (v: import("three").Vector3Like) => boolean;
-                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector3;
+                    normalize: () => import('three').Vector3;
+                    setLength: (l: number) => import('three').Vector3;
+                    lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
+                    lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
+                    cross: (a: import('three').Vector3Like) => import('three').Vector3;
+                    crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
+                    projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
+                    projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
+                    reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
+                    angleTo: (v: import('three').Vector3) => number;
+                    distanceTo: (v: import('three').Vector3Like) => number;
+                    distanceToSquared: (v: import('three').Vector3Like) => number;
+                    manhattanDistanceTo: (v: import('three').Vector3Like) => number;
+                    setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
+                    setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
+                    setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
+                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
+                    setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
+                    setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
+                    setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
+                    setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
+                    setFromEuler: (e: import('three').Euler) => import('three').Vector3;
+                    setFromColor: (color: import('three').RGB) => import('three').Vector3;
+                    equals: (v: import('three').Vector3Like) => boolean;
+                    fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector3;
                     toArray: {
-                        (array?: number[] | undefined, offset?: number | undefined): number[];
-                        (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
-                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
+                        (array?: number[], offset?: number): number[];
+                        (array?: import('three').Vector3Tuple, offset?: 0): import('three').Vector3Tuple;
+                        (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                     };
-                    fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => import("three").Vector3;
-                    random: () => import("three").Vector3;
-                    randomDirection: () => import("three").Vector3;
-                    [Symbol.iterator]: () => Iterator<number, any, undefined>;
+                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
+                    random: () => import('three').Vector3;
+                    randomDirection: () => import('three').Vector3;
+                    [Symbol.iterator]: () => Iterator<number>;
                 };
                 constant: number;
                 readonly isPlane: true;
-                set: (normal: import("three").Vector3, constant: number) => import("three").Plane;
-                setComponents: (x: number, y: number, z: number, w: number) => import("three").Plane;
-                setFromNormalAndCoplanarPoint: (normal: import("three").Vector3, point: import("three").Vector3) => import("three").Plane;
-                setFromCoplanarPoints: (a: import("three").Vector3, b: import("three").Vector3, c: import("three").Vector3) => import("three").Plane;
-                clone: () => import("three").Plane;
-                copy: (plane: import("three").Plane) => import("three").Plane;
-                normalize: () => import("three").Plane;
-                negate: () => import("three").Plane;
-                distanceToPoint: (point: import("three").Vector3) => number;
-                distanceToSphere: (sphere: import("three").Sphere) => number;
-                projectPoint: (point: import("three").Vector3, target: import("three").Vector3) => import("three").Vector3;
-                intersectLine: (line: import("three").Line3, target: import("three").Vector3) => import("three").Vector3 | null;
-                intersectsLine: (line: import("three").Line3) => boolean;
-                intersectsBox: (box: import("three").Box3) => boolean;
-                intersectsSphere: (sphere: import("three").Sphere) => boolean;
-                coplanarPoint: (target: import("three").Vector3) => import("three").Vector3;
-                applyMatrix4: (matrix: import("three").Matrix4, optionalNormalMatrix?: import("three").Matrix3 | undefined) => import("three").Plane;
-                translate: (offset: import("three").Vector3) => import("three").Plane;
-                equals: (plane: import("three").Plane) => boolean;
+                set: (normal: import('three').Vector3, constant: number) => import('three').Plane;
+                setComponents: (x: number, y: number, z: number, w: number) => import('three').Plane;
+                setFromNormalAndCoplanarPoint: (normal: import('three').Vector3, point: import('three').Vector3) => import('three').Plane;
+                setFromCoplanarPoints: (a: import('three').Vector3, b: import('three').Vector3, c: import('three').Vector3) => import('three').Plane;
+                clone: () => import('three').Plane;
+                copy: (plane: import('three').Plane) => import('three').Plane;
+                normalize: () => import('three').Plane;
+                negate: () => import('three').Plane;
+                distanceToPoint: (point: import('three').Vector3) => number;
+                distanceToSphere: (sphere: import('three').Sphere) => number;
+                projectPoint: (point: import('three').Vector3, target: import('three').Vector3) => import('three').Vector3;
+                intersectLine: (line: import('three').Line3, target: import('three').Vector3) => import('three').Vector3 | null;
+                intersectsLine: (line: import('three').Line3) => boolean;
+                intersectsBox: (box: import('three').Box3) => boolean;
+                intersectsSphere: (sphere: import('three').Sphere) => boolean;
+                coplanarPoint: (target: import('three').Vector3) => import('three').Vector3;
+                applyMatrix4: (matrix: import('three').Matrix4, optionalNormalMatrix?: import('three').Matrix3) => import('three').Plane;
+                translate: (offset: import('three').Vector3) => import('three').Plane;
+                equals: (plane: import('three').Plane) => boolean;
                 isIntersectionLine: (l: any) => any;
             }[] | null;
             clipShadows: boolean;
             colorWrite: boolean;
-            defines: {
+            defines: undefined | {
                 [key: string]: any;
-            } | undefined;
-            depthFunc: import("three").DepthModes;
+            };
+            depthFunc: import('three').DepthModes;
             depthTest: boolean;
             depthWrite: boolean;
             id: number;
             stencilWrite: boolean;
-            stencilFunc: import("three").StencilFunc;
+            stencilFunc: import('three').StencilFunc;
             stencilRef: number;
             stencilWriteMask: number;
             stencilFuncMask: number;
-            stencilFail: import("three").StencilOp;
-            stencilZFail: import("three").StencilOp;
-            stencilZPass: import("three").StencilOp;
+            stencilFail: import('three').StencilOp;
+            stencilZFail: import('three').StencilOp;
+            stencilZPass: import('three').StencilOp;
             name: string;
             opacity: number;
             polygonOffset: boolean;
@@ -4276,8 +4328,8 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
             premultipliedAlpha: boolean;
             forceSinglePass: boolean;
             dithering: boolean;
-            side: import("three").Side;
-            shadowSide: import("three").Side | null;
+            side: import('three').Side;
+            shadowSide: import('three').Side | null;
             toneMapped: boolean;
             transparent: boolean;
             type: string;
@@ -4287,105 +4339,105 @@ export declare const useCamera: ({ sizes, scene }: Pick<TresContext, "sizes"> &
             userData: Record<string, any>;
             version: number;
             alphaTest: number;
-            onBuild: (object: import("three").Object3D<import("three").Object3DEventMap>, parameters: import("three").WebGLProgramParametersWithUniforms, renderer: import("three").WebGLRenderer) => void;
-            onBeforeRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: Camera, geometry: import("three").BufferGeometry<import("three").NormalBufferAttributes>, object: import("three").Object3D<import("three").Object3DEventMap>, group: import("three").Group<import("three").Object3DEventMap>) => void;
-            onBeforeCompile: (parameters: import("three").WebGLProgramParametersWithUniforms, renderer: import("three").WebGLRenderer) => void;
+            onBeforeCompile: (parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
             customProgramCacheKey: () => string;
-            setValues: (values: import("three").MaterialParameters) => void;
+            setValues: (values: import('three').MaterialParameters) => void;
             toJSON: (meta?: any) => any;
-            clone: () => import("three").Material;
-            copy: (material: import("three").Material) => import("three").Material;
+            clone: () => import('three').Material;
+            copy: (material: import('three').Material) => import('three').Material;
             dispose: () => void;
             needsUpdate: boolean;
+            onBuild: (object: import('three').Object3D, parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
+            onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry, object: import('three').Object3D, group: import('three').Group) => void;
             addEventListener: {
-                <T extends "dispose">(type: T, listener: import("three").EventListener<{
+                <T extends "dispose">(type: T, listener: import('three').EventListener<{
                     dispose: {};
-                }[T], T, import("three").Material>): void;
-                <T_1 extends string>(type: T_1, listener: import("three").EventListener<{}, T_1, import("three").Material>): void;
+                }[T], T, import('three').Material>): void;
+                <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Material>): void;
             };
             hasEventListener: {
-                <T_2 extends "dispose">(type: T_2, listener: import("three").EventListener<{
+                <T extends "dispose">(type: T, listener: import('three').EventListener<{
                     dispose: {};
-                }[T_2], T_2, import("three").Material>): boolean;
-                <T_3 extends string>(type: T_3, listener: import("three").EventListener<{}, T_3, import("three").Material>): boolean;
+                }[T], T, import('three').Material>): boolean;
+                <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Material>): boolean;
             };
             removeEventListener: {
-                <T_4 extends "dispose">(type: T_4, listener: import("three").EventListener<{
+                <T extends "dispose">(type: T, listener: import('three').EventListener<{
                     dispose: {};
-                }[T_4], T_4, import("three").Material>): void;
-                <T_5 extends string>(type: T_5, listener: import("three").EventListener<{}, T_5, import("three").Material>): void;
+                }[T], T, import('three').Material>): void;
+                <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Material>): void;
             };
-            dispatchEvent: <T_6 extends "dispose">(event: import("three").BaseEvent<T_6> & {
+            dispatchEvent: <T extends "dispose">(event: import('three').BaseEvent<T> & {
                 dispose: {};
-            }[T_6]) => void;
+            }[T]) => void;
         } | undefined;
-        onBeforeShadow: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, shadowCamera: Camera, geometry: import("three").BufferGeometry<import("three").NormalBufferAttributes>, depthMaterial: import("three").Material, group: import("three").Group<import("three").Object3DEventMap>) => void;
-        onAfterShadow: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, shadowCamera: Camera, geometry: import("three").BufferGeometry<import("three").NormalBufferAttributes>, depthMaterial: import("three").Material, group: import("three").Group<import("three").Object3DEventMap>) => void;
-        onBeforeRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: Camera, geometry: import("three").BufferGeometry<import("three").NormalBufferAttributes>, material: import("three").Material, group: import("three").Group<import("three").Object3DEventMap>) => void;
-        onAfterRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: Camera, geometry: import("three").BufferGeometry<import("three").NormalBufferAttributes>, material: import("three").Material, group: import("three").Group<import("three").Object3DEventMap>) => void;
-        applyMatrix4: (matrix: import("three").Matrix4) => void;
-        applyQuaternion: (quaternion: import("three").Quaternion) => Camera;
-        setRotationFromAxisAngle: (axis: import("three").Vector3, angle: number) => void;
-        setRotationFromEuler: (euler: import("three").Euler) => void;
-        setRotationFromMatrix: (m: import("three").Matrix4) => void;
-        setRotationFromQuaternion: (q: import("three").Quaternion) => void;
-        rotateOnAxis: (axis: import("three").Vector3, angle: number) => Camera;
-        rotateOnWorldAxis: (axis: import("three").Vector3, angle: number) => Camera;
+        onBeforeShadow: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, shadowCamera: Camera, geometry: import('three').BufferGeometry, depthMaterial: import('three').Material, group: import('three').Group) => void;
+        onAfterShadow: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, shadowCamera: Camera, geometry: import('three').BufferGeometry, depthMaterial: import('three').Material, group: import('three').Group) => void;
+        onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry, material: import('three').Material, group: import('three').Group) => void;
+        onAfterRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry, material: import('three').Material, group: import('three').Group) => void;
+        applyMatrix4: (matrix: import('three').Matrix4) => void;
+        applyQuaternion: (quaternion: import('three').Quaternion) => Camera;
+        setRotationFromAxisAngle: (axis: import('three').Vector3, angle: number) => void;
+        setRotationFromEuler: (euler: import('three').Euler) => void;
+        setRotationFromMatrix: (m: import('three').Matrix4) => void;
+        setRotationFromQuaternion: (q: import('three').Quaternion) => void;
+        rotateOnAxis: (axis: import('three').Vector3, angle: number) => Camera;
+        rotateOnWorldAxis: (axis: import('three').Vector3, angle: number) => Camera;
         rotateX: (angle: number) => Camera;
         rotateY: (angle: number) => Camera;
         rotateZ: (angle: number) => Camera;
-        translateOnAxis: (axis: import("three").Vector3, distance: number) => Camera;
+        translateOnAxis: (axis: import('three').Vector3, distance: number) => Camera;
         translateX: (distance: number) => Camera;
         translateY: (distance: number) => Camera;
         translateZ: (distance: number) => Camera;
-        localToWorld: (vector: import("three").Vector3) => import("three").Vector3;
-        worldToLocal: (vector: import("three").Vector3) => import("three").Vector3;
+        localToWorld: (vector: import('three').Vector3) => import('three').Vector3;
+        worldToLocal: (vector: import('three').Vector3) => import('three').Vector3;
         lookAt: {
-            (vector: import("three").Vector3): void;
+            (vector: import('three').Vector3): void;
             (x: number, y: number, z: number): void;
         };
-        add: (...object: import("three").Object3D<import("three").Object3DEventMap>[]) => Camera;
-        remove: (...object: import("three").Object3D<import("three").Object3DEventMap>[]) => Camera;
+        add: (...object: import('three').Object3D[]) => Camera;
+        remove: (...object: import('three').Object3D[]) => Camera;
         removeFromParent: () => Camera;
         clear: () => Camera;
-        attach: (object: import("three").Object3D<import("three").Object3DEventMap>) => Camera;
-        getObjectById: (id: number) => import("three").Object3D<import("three").Object3DEventMap> | undefined;
-        getObjectByName: (name: string) => import("three").Object3D<import("three").Object3DEventMap> | undefined;
-        getObjectByProperty: (name: string, value: any) => import("three").Object3D<import("three").Object3DEventMap> | undefined;
-        getObjectsByProperty: (name: string, value: any, optionalTarget?: import("three").Object3D<import("three").Object3DEventMap>[] | undefined) => import("three").Object3D<import("three").Object3DEventMap>[];
-        getWorldPosition: (target: import("three").Vector3) => import("three").Vector3;
-        getWorldQuaternion: (target: import("three").Quaternion) => import("three").Quaternion;
-        getWorldScale: (target: import("three").Vector3) => import("three").Vector3;
-        raycast: (raycaster: import("three").Raycaster, intersects: import("three").Intersection<import("three").Object3D<import("three").Object3DEventMap>>[]) => void;
-        traverse: (callback: (object: import("three").Object3D<import("three").Object3DEventMap>) => any) => void;
-        traverseVisible: (callback: (object: import("three").Object3D<import("three").Object3DEventMap>) => any) => void;
-        traverseAncestors: (callback: (object: import("three").Object3D<import("three").Object3DEventMap>) => any) => void;
+        attach: (object: import('three').Object3D) => Camera;
+        getObjectById: (id: number) => import('three').Object3D | undefined;
+        getObjectByName: (name: string) => import('three').Object3D | undefined;
+        getObjectByProperty: (name: string, value: any) => import('three').Object3D | undefined;
+        getObjectsByProperty: (name: string, value: any, optionalTarget?: import('three').Object3D[]) => import('three').Object3D[];
+        getWorldPosition: (target: import('three').Vector3) => import('three').Vector3;
+        getWorldQuaternion: (target: import('three').Quaternion) => import('three').Quaternion;
+        getWorldScale: (target: import('three').Vector3) => import('three').Vector3;
+        raycast: (raycaster: import('three').Raycaster, intersects: import('three').Intersection[]) => void;
+        traverse: (callback: (object: import('three').Object3D) => any) => void;
+        traverseVisible: (callback: (object: import('three').Object3D) => any) => void;
+        traverseAncestors: (callback: (object: import('three').Object3D) => any) => void;
         updateMatrix: () => void;
-        updateMatrixWorld: (force?: boolean | undefined) => void;
+        updateMatrixWorld: (force?: boolean) => void;
         updateWorldMatrix: (updateParents: boolean, updateChildren: boolean) => void;
         toJSON: (meta?: {
             geometries: any;
             materials: any;
             textures: any;
             images: any;
-        } | undefined) => any;
-        clone: (recursive?: boolean | undefined) => Camera;
-        copy: (source: Camera, recursive?: boolean | undefined) => Camera;
+        }) => any;
+        clone: (recursive?: boolean) => Camera;
+        copy: (object: import('three').Object3D, recursive?: boolean) => Camera;
         addEventListener: {
-            <T_14 extends keyof import("three").Object3DEventMap>(type: T_14, listener: import("three").EventListener<import("three").Object3DEventMap[T_14], T_14, Camera>): void;
-            <T_15 extends string>(type: T_15, listener: import("three").EventListener<{}, T_15, Camera>): void;
+            <T extends keyof import('three').Object3DEventMap>(type: T, listener: import('three').EventListener<import('three').Object3DEventMap[T], T, Camera>): void;
+            <T extends string>(type: T, listener: import('three').EventListener<{}, T, Camera>): void;
         };
         hasEventListener: {
-            <T_16 extends keyof import("three").Object3DEventMap>(type: T_16, listener: import("three").EventListener<import("three").Object3DEventMap[T_16], T_16, Camera>): boolean;
-            <T_17 extends string>(type: T_17, listener: import("three").EventListener<{}, T_17, Camera>): boolean;
+            <T extends keyof import('three').Object3DEventMap>(type: T, listener: import('three').EventListener<import('three').Object3DEventMap[T], T, Camera>): boolean;
+            <T extends string>(type: T, listener: import('three').EventListener<{}, T, Camera>): boolean;
         };
         removeEventListener: {
-            <T_18 extends keyof import("three").Object3DEventMap>(type: T_18, listener: import("three").EventListener<import("three").Object3DEventMap[T_18], T_18, Camera>): void;
-            <T_19 extends string>(type: T_19, listener: import("three").EventListener<{}, T_19, Camera>): void;
+            <T extends keyof import('three').Object3DEventMap>(type: T, listener: import('three').EventListener<import('three').Object3DEventMap[T], T, Camera>): void;
+            <T extends string>(type: T, listener: import('three').EventListener<{}, T, Camera>): void;
         };
-        dispatchEvent: <T_13 extends keyof import("three").Object3DEventMap>(event: import("three").BaseEvent<T_13> & import("three").Object3DEventMap[T_13]) => void;
+        dispatchEvent: <T extends keyof import('three').Object3DEventMap>(event: import('three').BaseEvent<T> & import('three').Object3DEventMap[T]) => void;
     }[]>;
-    registerCamera: (newCamera: Camera, active?: boolean) => void;
-    deregisterCamera: (camera: Camera) => void;
+    registerCamera: (maybeCamera: unknown, active?: boolean) => void;
+    deregisterCamera: (maybeCamera: unknown) => void;
     setCameraActive: (cameraOrUuid: string | Camera) => void;
 };
diff --git a/node_modules/@tresjs/core/dist/src/composables/useLoader/index.d.ts b/node_modules/@tresjs/core/dist/src/composables/useLoader/index.d.ts
new file mode 100644
index 0000000..7879b1d
--- /dev/null
+++ b/node_modules/@tresjs/core/dist/src/composables/useLoader/index.d.ts
@@ -0,0 +1,45 @@
+import { Loader, LoadingManager, Object3D } from 'three';
+
+export interface TresLoader<T> extends Loader {
+    load: (url: string, onLoad: (result: T) => void, onProgress?: (event: ProgressEvent) => void, onError?: (event: ErrorEvent) => void) => void;
+    loadAsync: (url: string, onProgress?: (event: ProgressEvent) => void) => Promise<T>;
+}
+export type LoaderProto<T> = new (manager?: LoadingManager) => TresLoader<T>;
+export type LoaderReturnType<T, L extends LoaderProto<T>> = T extends unknown ? Awaited<ReturnType<InstanceType<L>['loadAsync']>> : T;
+/**
+ * Traverse an object and return all the nodes and materials
+ *
+ * @export
+ * @param {Object3D} object
+ * @return { [key: string]: any }
+ */
+export declare function trasverseObjects(object: Object3D): {
+    [key: string]: any;
+};
+export type Extensions<T extends {
+    prototype: LoaderProto<any>;
+}> = (loader: T['prototype']) => void;
+/**
+ * Load resources using THREE loaders and return the result as a promise
+ *
+ * @see https://tresjs.org/api/composables.html#useloader
+ * @see https://threejs.org/docs/index.html?q=loader#api/en/loaders/Loader
+ *
+ * ```ts
+ * import { useLoader } from '@tresjs/core'
+ * import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader'
+ *
+ * const { scene } = await useLoader(THREE.GLTFLoader, 'path/to/asset.gltf')
+ * ```
+ *
+ * @export
+ * @template LoaderProto<T>
+ * @template string | string[],
+ * @param {LoaderProto<T>} Loader
+ * @param {string | string[],} url
+ * @param {Extensions<TresLoader<T>>} [extensions]
+ * @param {(event: ProgressEvent<EventTarget>) => void} [onProgress]
+ * @param {(proto: TresLoader<T>) => void} [cb]
+ * @return {*}
+ */
+export declare function useLoader<T>(Loader: LoaderProto<T>, url: string | string[], extensions?: (loader: TresLoader<T>) => void, onProgress?: (event: ProgressEvent<EventTarget>) => void, cb?: (proto: TresLoader<T>) => void): Promise<T | T[]>;
diff --git a/node_modules/@tresjs/core/dist/src/composables/useLoop/index.d.ts b/node_modules/@tresjs/core/dist/src/composables/useLoop/index.d.ts
new file mode 100644
index 0000000..015aef5
--- /dev/null
+++ b/node_modules/@tresjs/core/dist/src/composables/useLoop/index.d.ts
@@ -0,0 +1,18 @@
+import { LoopCallbackFn } from './../../core/loop';
+
+export declare function useLoop(): {
+    pause: import('@vueuse/core').Fn;
+    resume: import('@vueuse/core').Fn;
+    pauseRender: import('@vueuse/core').Fn;
+    resumeRender: import('@vueuse/core').Fn;
+    isActive: import('vue').Ref<boolean>;
+    onBeforeRender: (cb: LoopCallbackFn, index?: number) => {
+        off: import('@vueuse/core').Fn;
+    };
+    render: (cb: LoopCallbackFn) => {
+        off: import('@vueuse/core').Fn;
+    };
+    onAfterRender: (cb: LoopCallbackFn, index?: number) => {
+        off: import('@vueuse/core').Fn;
+    };
+};
diff --git a/node_modules/@tresjs/core/dist/src/composables/usePointerEventHandler/index.d.ts b/node_modules/@tresjs/core/dist/src/composables/usePointerEventHandler/index.d.ts
deleted file mode 100644
index a66b5c5..0000000
--- a/node_modules/@tresjs/core/dist/src/composables/usePointerEventHandler/index.d.ts
+++ /dev/null
@@ -1,20 +0,0 @@
-import { TresContext } from '../useTresContextProvider';
-import { TresScene } from 'src/types';
-import { Intersection, Event, Object3D } from 'three';
-
-type CallbackFn = (intersection: Intersection<Object3D<Event>>, event: PointerEvent) => void;
-type CallbackFnPointerLeave = (object: Object3D<Event>, event: PointerEvent) => void;
-export interface EventProps {
-    onClick?: CallbackFn;
-    onPointerEnter?: CallbackFn;
-    onPointerMove?: CallbackFn;
-    onPointerLeave?: CallbackFnPointerLeave;
-}
-export declare const usePointerEventHandler: ({ scene, contextParts }: {
-    scene: TresScene;
-    contextParts: Pick<TresContext, 'renderer' | 'camera' | 'raycaster'>;
-}) => {
-    registerObject: (object: Object3D & EventProps) => void;
-    deregisterObject: (object: Object3D) => void;
-};
-export {};
diff --git a/node_modules/@tresjs/core/dist/src/composables/useRaycaster/index.d.ts b/node_modules/@tresjs/core/dist/src/composables/useRaycaster/index.d.ts
new file mode 100644
index 0000000..6dad20b
--- /dev/null
+++ b/node_modules/@tresjs/core/dist/src/composables/useRaycaster/index.d.ts
@@ -0,0 +1,17 @@
+import { Intersection, Object3D, Object3DEventMap } from 'three';
+import { ShallowRef } from 'vue';
+import { TresEvent, TresInstance } from 'src/types';
+import { TresContext } from '../useTresContextProvider';
+
+export declare const useRaycaster: (objectsWithEvents: ShallowRef<TresInstance[]>, ctx: TresContext) => {
+    intersects: ShallowRef<Intersection<Object3D<Object3DEventMap>>[]>;
+    onClick: (fn: (value: TresEvent) => void) => () => void;
+    onDblClick: (fn: (value: TresEvent) => void) => () => void;
+    onContextMenu: (fn: (value: TresEvent) => void) => () => void;
+    onPointerMove: (fn: (value: TresEvent) => void) => () => void;
+    onPointerUp: (fn: (value: TresEvent) => void) => () => void;
+    onPointerDown: (fn: (value: TresEvent) => void) => () => void;
+    onPointerMissed: (fn: (value: TresEvent) => void) => () => void;
+    onWheel: (fn: (value: TresEvent) => void) => () => void;
+    forceUpdate: () => void;
+};
diff --git a/node_modules/@tresjs/core/dist/src/composables/useRenderLoop/index.d.ts b/node_modules/@tresjs/core/dist/src/composables/useRenderLoop/index.d.ts
index 110ebd5..81ce385 100644
--- a/node_modules/@tresjs/core/dist/src/composables/useRenderLoop/index.d.ts
+++ b/node_modules/@tresjs/core/dist/src/composables/useRenderLoop/index.d.ts
@@ -1,6 +1,6 @@
-import { Clock } from 'three';
-import { Ref } from 'vue';
 import { EventHookOn, Fn } from '@vueuse/core';
+import { Ref } from 'vue';
+import { Clock } from 'three';
 
 export interface RenderLoop {
     delta: number;
diff --git a/node_modules/@tresjs/core/dist/src/composables/useRenderer/const.d.ts b/node_modules/@tresjs/core/dist/src/composables/useRenderer/const.d.ts
index 82beb39..7506782 100644
--- a/node_modules/@tresjs/core/dist/src/composables/useRenderer/const.d.ts
+++ b/node_modules/@tresjs/core/dist/src/composables/useRenderer/const.d.ts
@@ -10,5 +10,9 @@ export declare const rendererPresets: {
             type: 2;
         };
     };
+    flat: {
+        toneMapping: 0;
+        toneMappingExposure: number;
+    };
 };
 export type RendererPresetsType = keyof typeof rendererPresets;
diff --git a/node_modules/@tresjs/core/dist/src/composables/useRenderer/index.d.ts b/node_modules/@tresjs/core/dist/src/composables/useRenderer/index.d.ts
index 683362d..4c8729b 100644
--- a/node_modules/@tresjs/core/dist/src/composables/useRenderer/index.d.ts
+++ b/node_modules/@tresjs/core/dist/src/composables/useRenderer/index.d.ts
@@ -1,9 +1,9 @@
-import { RendererPresetsType } from './const';
-import { TresContext } from '../useTresContextProvider';
-import { TresColor } from '../../types';
-import { MaybeRefOrGetter } from '@vueuse/core';
+import { WebGLRenderer, ColorSpace, Scene, ShadowMapType, ToneMapping, WebGLRendererParameters } from 'three';
 import { MaybeRef } from 'vue';
-import { WebGLRenderer, Scene, ToneMapping, ColorSpace, ShadowMapType, WebGLRendererParameters } from 'three';
+import { MaybeRefOrGetter } from '@vueuse/core';
+import { EmitEventFn, TresColor } from '../../types';
+import { TresContext } from '../useTresContextProvider';
+import { RendererPresetsType } from './const';
 
 type TransformToMaybeRefOrGetter<T> = {
     [K in keyof T]: MaybeRefOrGetter<T[K]> | MaybeRefOrGetter<T[K]>;
@@ -52,7 +52,7 @@ export interface UseRendererOptions extends TransformToMaybeRefOrGetter<WebGLRen
      * CineonToneMapping, ACESFilmicToneMapping,
      * CustomToneMapping
      *
-     * @default NoToneMapping
+     * @default ACESFilmicToneMapping
      */
     toneMapping?: MaybeRefOrGetter<ToneMapping>;
     /**
@@ -69,18 +69,22 @@ export interface UseRendererOptions extends TransformToMaybeRefOrGetter<WebGLRen
     clearColor?: MaybeRefOrGetter<TresColor>;
     windowSize?: MaybeRefOrGetter<boolean | string>;
     preset?: MaybeRefOrGetter<RendererPresetsType>;
+    renderMode?: MaybeRefOrGetter<'always' | 'on-demand' | 'manual'>;
+    /**
+     * A `number` sets the renderer's device pixel ratio.
+     * `[number, number]` clamp's the renderer's device pixel ratio.
+     */
+    dpr?: MaybeRefOrGetter<number | [number, number]>;
 }
-/**
- * Reactive three.js WebGLRenderer instance
- *
- * @param canvas
- * @param {UseRendererOptions} [options]
- */
-export declare function useRenderer({ scene, canvas, options, disableRender, contextParts: { sizes, camera }, }: {
+export declare function useRenderer({ canvas, options, contextParts: { sizes, render, invalidate, advance }, }: {
     canvas: MaybeRef<HTMLCanvasElement>;
     scene: Scene;
     options: UseRendererOptions;
-    contextParts: Pick<TresContext, 'sizes' | 'camera'>;
+    emit: EmitEventFn;
+    contextParts: Pick<TresContext, 'sizes' | 'camera' | 'render'> & {
+        invalidate: () => void;
+        advance: () => void;
+    };
     disableRender: MaybeRefOrGetter<boolean>;
 }): {
     renderer: import('vue').ShallowRef<WebGLRenderer>;
diff --git a/node_modules/@tresjs/core/dist/src/composables/useSeek/index.d.ts b/node_modules/@tresjs/core/dist/src/composables/useSeek/index.d.ts
new file mode 100644
index 0000000..85655a1
--- /dev/null
+++ b/node_modules/@tresjs/core/dist/src/composables/useSeek/index.d.ts
@@ -0,0 +1,21 @@
+import { Object3D, Scene } from 'three';
+
+/**
+ * Seek composable return type
+ *
+ * @export
+ * @interface UseSeekReturn
+ */
+export interface UseSeekReturn {
+    seek: (parent: Scene | Object3D, property: string, value: string) => Object3D | null;
+    seekByName: (parent: Scene | Object3D, value: string) => Object3D | null;
+    seekAll: (parent: Scene | Object3D, property: string, value: string) => Object3D[];
+    seekAllByName: (parent: Scene | Object3D, value: string) => Object3D[];
+}
+/**
+ * Composable that provides utilities to easily traverse and navigate through complex scenes and object children graphs
+ *
+ * @export
+ * @return {*}  {UseSeekReturn}
+ */
+export declare function useSeek(): UseSeekReturn;
diff --git a/node_modules/@tresjs/core/dist/src/composables/useSizes/index.d.ts b/node_modules/@tresjs/core/dist/src/composables/useSizes/index.d.ts
index 77d0207..7b3bb8f 100644
--- a/node_modules/@tresjs/core/dist/src/composables/useSizes/index.d.ts
+++ b/node_modules/@tresjs/core/dist/src/composables/useSizes/index.d.ts
@@ -1,4 +1,4 @@
-import { MaybeRefOrGetter, MaybeRef, ComputedRef, Ref } from 'vue';
+import { ComputedRef, MaybeRef, MaybeRefOrGetter, Ref } from 'vue';
 
 export interface SizesType {
     height: Readonly<Ref<number>>;
diff --git a/node_modules/@tresjs/core/dist/src/composables/useTresContextProvider/index.d.ts b/node_modules/@tresjs/core/dist/src/composables/useTresContextProvider/index.d.ts
index a0c1f1c..f951b4b 100644
--- a/node_modules/@tresjs/core/dist/src/composables/useTresContextProvider/index.d.ts
+++ b/node_modules/@tresjs/core/dist/src/composables/useTresContextProvider/index.d.ts
@@ -1,41 +1,76 @@
-import { SizesType } from '../useSizes';
-import { UseRendererOptions } from '../useRenderer';
+import { Camera, WebGLRenderer, Raycaster } from 'three';
 import { ComputedRef, DeepReadonly, MaybeRef, MaybeRefOrGetter, Ref, ShallowRef } from 'vue';
-import { Camera, EventDispatcher, Scene, WebGLRenderer, Raycaster } from 'three';
+import { UseRendererOptions } from '../useRenderer';
+import { EmitEventFn, TresControl, TresObject, TresScene } from '../../types';
+import { TresEventManager } from '../useTresEventManager';
+import { SizesType } from '../useSizes';
+import { RendererLoop } from '../../core/loop';
 
+export interface InternalState {
+    priority: Ref<number>;
+    frames: Ref<number>;
+    maxFrames: number;
+}
+export interface RenderState {
+    /**
+     * If set to 'on-demand', the scene will only be rendered when the current frame is invalidated
+     * If set to 'manual', the scene will only be rendered when advance() is called
+     * If set to 'always', the scene will be rendered every frame
+     */
+    mode: Ref<'always' | 'on-demand' | 'manual'>;
+    priority: Ref<number>;
+    frames: Ref<number>;
+    maxFrames: number;
+    canBeInvalidated: ComputedRef<boolean>;
+}
+export interface PerformanceState {
+    maxFrames: number;
+    fps: {
+        value: number;
+        accumulator: number[];
+    };
+    memory: {
+        currentMem: number;
+        allocatedMem: number;
+        accumulator: number[];
+    };
+}
 export interface TresContext {
-    scene: ShallowRef<Scene>;
+    scene: ShallowRef<TresScene>;
     sizes: SizesType;
     extend: (objects: any) => void;
     camera: ComputedRef<Camera | undefined>;
     cameras: DeepReadonly<Ref<Camera[]>>;
-    controls: Ref<(EventDispatcher & {
-        enabled: boolean;
-    }) | null>;
+    controls: Ref<TresControl | null>;
     renderer: ShallowRef<WebGLRenderer>;
     raycaster: ShallowRef<Raycaster>;
-    perf: {
-        maxFrames: number;
-        fps: {
-            value: number;
-            accumulator: number[];
-        };
-        memory: {
-            currentMem: number;
-            allocatedMem: number;
-            accumulator: number[];
-        };
-    };
-    registerCamera: (camera: Camera) => void;
+    perf: PerformanceState;
+    render: RenderState;
+    loop: RendererLoop;
+    /**
+     * Invalidates the current frame when renderMode === 'on-demand'
+     */
+    invalidate: () => void;
+    /**
+     * Advance one frame when renderMode === 'manual'
+     */
+    advance: () => void;
+    registerCamera: (maybeCamera: unknown) => void;
     setCameraActive: (cameraOrUuid: Camera | string) => void;
-    deregisterCamera: (camera: Camera) => void;
+    deregisterCamera: (maybeCamera: unknown) => void;
+    eventManager?: TresEventManager;
+    registerObjectAtPointerEventHandler?: (object: TresObject) => void;
+    deregisterObjectAtPointerEventHandler?: (object: TresObject) => void;
+    registerBlockingObjectAtPointerEventHandler?: (object: TresObject) => void;
+    deregisterBlockingObjectAtPointerEventHandler?: (object: TresObject) => void;
 }
-export declare function useTresContextProvider({ scene, canvas, windowSize, disableRender, rendererOptions, }: {
-    scene: Scene;
+export declare function useTresContextProvider({ scene, canvas, windowSize, disableRender, rendererOptions, emit, }: {
+    scene: TresScene;
     canvas: MaybeRef<HTMLCanvasElement>;
     windowSize: MaybeRefOrGetter<boolean>;
     disableRender: MaybeRefOrGetter<boolean>;
     rendererOptions: UseRendererOptions;
+    emit: EmitEventFn;
 }): TresContext;
 export declare function useTresContext(): TresContext;
 export declare const useTres: typeof useTresContext;
diff --git a/node_modules/@tresjs/core/dist/src/composables/useTresEventManager/index.d.ts b/node_modules/@tresjs/core/dist/src/composables/useTresEventManager/index.d.ts
new file mode 100644
index 0000000..af140bf
--- /dev/null
+++ b/node_modules/@tresjs/core/dist/src/composables/useTresEventManager/index.d.ts
@@ -0,0 +1,26 @@
+import { Scene } from 'three';
+import { EmitEventFn } from 'src/types';
+import { TresContext } from '../useTresContextProvider';
+
+export interface TresEventManager {
+    /**
+     * Forces the event system to refire events with the previous mouse event
+     */
+    forceUpdate: () => void;
+    /**
+     * pointer-missed events by definition are fired when the pointer missed every object in the scene
+     * So we need to track them separately
+     * Note: These are used in nodeOps
+     */
+    registerObject: (object: unknown) => void;
+    deregisterObject: (object: unknown) => void;
+    registerPointerMissedObject: (object: unknown) => void;
+    deregisterPointerMissedObject: (object: unknown) => void;
+}
+export declare function useTresEventManager(scene: Scene, context: TresContext, emit: EmitEventFn): {
+    forceUpdate: () => void;
+    registerObject: (maybeTresObject: unknown) => void;
+    deregisterObject: (maybeTresObject: unknown) => void;
+    registerPointerMissedObject: (maybeTresObject: unknown) => void;
+    deregisterPointerMissedObject: (maybeTresObject: unknown) => void;
+};
diff --git a/node_modules/@tresjs/core/dist/src/composables/useTresReady/createReadyEventHook/index.d.ts b/node_modules/@tresjs/core/dist/src/composables/useTresReady/createReadyEventHook/index.d.ts
new file mode 100644
index 0000000..3219075
--- /dev/null
+++ b/node_modules/@tresjs/core/dist/src/composables/useTresReady/createReadyEventHook/index.d.ts
@@ -0,0 +1,5 @@
+import { EventHook } from '@vueuse/core';
+
+export declare function createReadyEventHook<T>(getIsReady: () => boolean, triggerParams: T, pollIntervalMs?: number): EventHook<T> & {
+    cancel: () => void;
+};
diff --git a/node_modules/@tresjs/core/dist/src/composables/useTresReady/index.d.ts b/node_modules/@tresjs/core/dist/src/composables/useTresReady/index.d.ts
new file mode 100644
index 0000000..e8b9098
--- /dev/null
+++ b/node_modules/@tresjs/core/dist/src/composables/useTresReady/index.d.ts
@@ -0,0 +1,8 @@
+import { TresContext } from '../useTresContextProvider';
+
+export declare function useTresReady(ctx?: TresContext): import('@vueuse/core').EventHook<TresContext> & {
+    cancel: () => void;
+};
+export declare function onTresReady(fn: (ctx: TresContext) => void): {
+    off: () => void;
+} | undefined;
diff --git a/node_modules/@tresjs/core/dist/src/core/catalogue.d.ts b/node_modules/@tresjs/core/dist/src/core/catalogue.d.ts
index f6bac6b..535bbcb 100644
--- a/node_modules/@tresjs/core/dist/src/core/catalogue.d.ts
+++ b/node_modules/@tresjs/core/dist/src/core/catalogue.d.ts
@@ -1,5 +1,5 @@
-import { TresCatalogue } from '../types';
 import { Ref } from 'vue';
+import { TresCatalogue } from '../types';
 
 export declare const catalogue: Ref<TresCatalogue>;
 export declare const extend: (objects: any) => any;
diff --git a/node_modules/@tresjs/core/dist/src/core/loop.d.ts b/node_modules/@tresjs/core/dist/src/core/loop.d.ts
new file mode 100644
index 0000000..eaab018
--- /dev/null
+++ b/node_modules/@tresjs/core/dist/src/core/loop.d.ts
@@ -0,0 +1,39 @@
+import { Ref } from 'vue';
+import { Camera, EventDispatcher, Raycaster, Scene, WebGLRenderer, Clock } from 'three';
+import { Fn } from '@vueuse/core';
+
+export type LoopStage = 'before' | 'render' | 'after';
+export interface LoopCallback {
+    delta: number;
+    elapsed: number;
+    clock: Clock;
+}
+export interface LoopCallbackWithCtx extends LoopCallback {
+    camera: Camera;
+    scene: Scene;
+    renderer: WebGLRenderer;
+    raycaster: Raycaster;
+    controls: Ref<(EventDispatcher<object> & {
+        enabled: boolean;
+    }) | null>;
+    invalidate: Fn;
+    advance: Fn;
+}
+export type LoopCallbackFn = (params: LoopCallbackWithCtx) => void;
+export interface RendererLoop {
+    loopId: string;
+    register: (callback: LoopCallbackFn, stage: LoopStage, index?: number) => {
+        off: Fn;
+    };
+    start: Fn;
+    stop: Fn;
+    pause: Fn;
+    resume: Fn;
+    pauseRender: Fn;
+    resumeRender: Fn;
+    isActive: Ref<boolean>;
+    isRenderPaused: Ref<boolean>;
+    setContext: (newContext: Record<string, any>) => void;
+    setReady: (isReady: boolean) => void;
+}
+export declare function createRenderLoop(): RendererLoop;
diff --git a/node_modules/@tresjs/core/dist/src/core/nodeOps.d.ts b/node_modules/@tresjs/core/dist/src/core/nodeOps.d.ts
index 3f49c96..8d22a48 100644
--- a/node_modules/@tresjs/core/dist/src/core/nodeOps.d.ts
+++ b/node_modules/@tresjs/core/dist/src/core/nodeOps.d.ts
@@ -1,4 +1,5 @@
-import { TresObject } from '../types';
 import { RendererOptions } from 'vue';
+import { TresContext } from '../composables';
+import { TresObject } from '../types';
 
-export declare const nodeOps: RendererOptions<TresObject, TresObject>;
+export declare const nodeOps: (context: TresContext) => RendererOptions<TresObject, TresObject | null>;
diff --git a/node_modules/@tresjs/core/dist/src/core/renderer.d.ts b/node_modules/@tresjs/core/dist/src/core/renderer.d.ts
deleted file mode 100644
index 4e82f80..0000000
--- a/node_modules/@tresjs/core/dist/src/core/renderer.d.ts
+++ /dev/null
@@ -1,5 +0,0 @@
-export declare const render: import('vue').RootRenderFunction<import("src").TresObject>;
-declare const _default: {
-    extend: (objects: any) => any;
-};
-export default _default;
diff --git a/node_modules/@tresjs/core/dist/src/devtools/highlight.d.ts b/node_modules/@tresjs/core/dist/src/devtools/highlight.d.ts
index 6b2bc1a..5c31c56 100644
--- a/node_modules/@tresjs/core/dist/src/devtools/highlight.d.ts
+++ b/node_modules/@tresjs/core/dist/src/devtools/highlight.d.ts
@@ -2,6 +2,6 @@ import * as THREE from 'three';
 export declare class HightlightMesh extends THREE.Mesh {
     type: string;
     createTime: number;
-    constructor(...args: THREE.Mesh['args']);
+    constructor(...args: any[]);
     onBeforeRender(): void;
 }
diff --git a/node_modules/@tresjs/core/dist/src/devtools/plugin.d.ts b/node_modules/@tresjs/core/dist/src/devtools/plugin.d.ts
index 043feda..0634f72 100644
--- a/node_modules/@tresjs/core/dist/src/devtools/plugin.d.ts
+++ b/node_modules/@tresjs/core/dist/src/devtools/plugin.d.ts
@@ -1,5 +1,5 @@
-import { TresContext } from '../composables';
 import { App as DevtoolsApp } from '@vue/devtools-api';
+import { TresContext } from '../composables';
 
 export interface Tags {
     label: string;
diff --git a/node_modules/@tresjs/core/dist/src/directives/index.d.ts b/node_modules/@tresjs/core/dist/src/directives/index.d.ts
index d0a71c0..9bd2898 100644
--- a/node_modules/@tresjs/core/dist/src/directives/index.d.ts
+++ b/node_modules/@tresjs/core/dist/src/directives/index.d.ts
@@ -1,6 +1,5 @@
-import { vDistanceTo } from './vDistanceTo';
-import { vAlwaysLookAt } from './vAlwaysLookAt';
-import { vLightHelper } from './vLightHelper';
 import { vLog } from './vLog';
+import { vLightHelper } from './vLightHelper';
+import { vDistanceTo } from './vDistanceTo';
 
-export { vLog, vLightHelper, vAlwaysLookAt, vDistanceTo };
+export { vLog, vLightHelper, vDistanceTo };
diff --git a/node_modules/@tresjs/core/dist/src/directives/vAlwaysLookAt.d.ts b/node_modules/@tresjs/core/dist/src/directives/vAlwaysLookAt.d.ts
deleted file mode 100644
index e4918aa..0000000
--- a/node_modules/@tresjs/core/dist/src/directives/vAlwaysLookAt.d.ts
+++ /dev/null
@@ -1,7 +0,0 @@
-import { TresVector3 } from '../types';
-import { Ref } from 'vue';
-import { Object3D } from 'three';
-
-export declare const vAlwaysLookAt: {
-    updated: (el: Object3D, binding: Ref<TresVector3>) => void;
-};
diff --git a/node_modules/@tresjs/core/dist/src/directives/vDistanceTo.d.ts b/node_modules/@tresjs/core/dist/src/directives/vDistanceTo.d.ts
index e6edc47..38439b5 100644
--- a/node_modules/@tresjs/core/dist/src/directives/vDistanceTo.d.ts
+++ b/node_modules/@tresjs/core/dist/src/directives/vDistanceTo.d.ts
@@ -1,5 +1,5 @@
-import { TresObject } from '../types';
 import { Ref } from 'vue';
+import { TresObject } from '../types';
 
 export declare const vDistanceTo: {
     updated: (el: TresObject, binding: Ref<TresObject>) => void;
diff --git a/node_modules/@tresjs/core/dist/src/index.d.ts b/node_modules/@tresjs/core/dist/src/index.d.ts
index b6a3d8f..173b312 100644
--- a/node_modules/@tresjs/core/dist/src/index.d.ts
+++ b/node_modules/@tresjs/core/dist/src/index.d.ts
@@ -1,12 +1,14 @@
-import { default as templateCompilerOptions } from './utils/template-compiler-options';
-import { normalizeColor, normalizeVectorFlexibleParam } from './utils/normalize';
 import { App } from 'vue';
+import { normalizeColor, normalizeVectorFlexibleParam } from './utils/normalize';
+import { default as templateCompilerOptions } from './utils/template-compiler-options';
+import { disposeObject3D as dispose } from './utils';
 
 export * from './composables';
 export * from './core/catalogue';
 export * from './components';
 export * from './types';
 export * from './directives';
+export * from './core/loop';
 export interface TresOptions {
     extends?: Record<string, unknown>;
 }
@@ -16,4 +18,5 @@ export interface TresPlugin {
 }
 declare const plugin: TresPlugin;
 export default plugin;
-export { normalizeColor, normalizeVectorFlexibleParam, templateCompilerOptions, };
+export { normalizeColor, normalizeVectorFlexibleParam, templateCompilerOptions, dispose, };
+export type { VectorFlexibleParams } from './utils/normalize';
diff --git a/node_modules/@tresjs/core/dist/src/types/index.d.ts b/node_modules/@tresjs/core/dist/src/types/index.d.ts
index f27d0d0..f53d56a 100644
--- a/node_modules/@tresjs/core/dist/src/types/index.d.ts
+++ b/node_modules/@tresjs/core/dist/src/types/index.d.ts
@@ -1,9 +1,10 @@
-import { EventProps as PointerEventHandlerEventProps } from '../composables/usePointerEventHandler';
 import { DefineComponent, VNode, VNodeRef } from 'vue';
+import { TresContext } from '../composables/useTresContextProvider';
 
 import type * as THREE from 'three';
-export type AttachFnType<O = any> = (parent: any, self: O) => () => void;
-export type AttachType<O = any> = string | AttachFnType<O>;
+export type AttachFnType = (parent: any, self: TresInstance) => () => void;
+export type AttachType = string | AttachFnType;
+export type DisposeType = ((self: TresInstance) => void) | boolean | 'default';
 export type ConstructorRepresentation = new (...args: any[]) => any;
 export type NonFunctionKeys<P> = {
     [K in keyof P]-?: P[K] extends Function ? never : K;
@@ -17,39 +18,53 @@ export type Args<T> = T extends ConstructorRepresentation ? ConstructorParameter
 export interface TresCatalogue {
     [name: string]: ConstructorRepresentation;
 }
+export type EmitEventName = 'render' | 'ready' | 'click' | 'double-click' | 'context-menu' | 'pointer-move' | 'pointer-up' | 'pointer-down' | 'pointer-enter' | 'pointer-leave' | 'pointer-over' | 'pointer-out' | 'pointer-missed' | 'wheel';
+export type EmitEventFn = (event: EmitEventName, ...args: any[]) => void;
 export type TresCamera = THREE.OrthographicCamera | THREE.PerspectiveCamera;
 export interface InstanceProps<T = any, P = any> {
     args?: Args<P>;
     object?: T;
     visible?: boolean;
     dispose?: null;
-    attach?: AttachType<T>;
+    [prop: string]: any;
 }
 interface TresBaseObject {
-    attach?: string;
     removeFromParent?: () => void;
     dispose?: () => void;
     [prop: string]: any;
 }
-export interface TresObject3D extends THREE.Object3D {
-    geometry?: THREE.BufferGeometry & TresBaseObject;
-    material?: THREE.Material & TresBaseObject;
-    userData: {
-        tres__materialViaProp: boolean;
-        tres__geometryViaProp: boolean;
+export interface LocalState {
+    type: string;
+    eventCount: number;
+    root: TresContext;
+    handlers: Partial<EventHandlers>;
+    memoizedProps: {
         [key: string]: any;
     };
+    objects: TresObject[];
+    parent: TresObject | null;
+    primitive?: boolean;
+    dispose?: DisposeType;
+    attach?: AttachType;
+    previousAttach: any;
+}
+export interface TresObject3D extends THREE.Object3D<THREE.Object3DEventMap> {
+    geometry?: THREE.BufferGeometry & TresBaseObject;
+    material?: THREE.Material & TresBaseObject;
 }
-export type TresObject = TresBaseObject & (TresObject3D | THREE.BufferGeometry | THREE.Material | THREE.Fog);
+export type TresObject = TresBaseObject & (TresObject3D | THREE.BufferGeometry | THREE.Material | THREE.Fog) & {
+    __tres?: LocalState;
+};
+export type TresInstance = TresObject & {
+    __tres: LocalState;
+};
+export type TresPrimitive = TresInstance & {
+    object: TresInstance;
+    isPrimitive: true;
+};
 export interface TresScene extends THREE.Scene {
-    userData: {
-        tres__registerCamera?: (newCamera: THREE.Camera, active?: boolean) => void;
-        tres__deregisterCamera?: (camera: THREE.Camera) => void;
-        tres__registerAtPointerEventHandler?: (object: THREE.Object3D & PointerEventHandlerEventProps) => void;
-        tres__deregisterAtPointerEventHandler?: (object: THREE.Object3D) => void;
-        tres__registerBlockingObjectAtPointerEventHandler?: (object: THREE.Object3D) => void;
-        tres__deregisterBlockingObjectAtPointerEventHandler?: (object: THREE.Object3D) => void;
-        [key: string]: any;
+    __tres: {
+        root: TresContext;
     };
 }
 export interface Intersection extends THREE.Intersection {
@@ -80,6 +95,14 @@ export interface IntersectionEvent<TSourceEvent> extends Intersection {
 }
 export type ThreeEvent<TEvent> = IntersectionEvent<TEvent> & Properties<TEvent>;
 export type DomEvent = PointerEvent | MouseEvent | WheelEvent;
+export interface TresEvent {
+    eventObject: TresObject;
+    event: DomEvent;
+    stopPropagation: () => void;
+    stopPropagating: boolean;
+    intersections: Intersection[];
+    intersects: Intersection[];
+}
 export interface Events {
     onClick: EventListener;
     onContextMenu: EventListener;
@@ -108,10 +131,10 @@ export interface EventHandlers {
     onWheel?: (event: ThreeEvent<WheelEvent>) => void;
 }
 interface MathRepresentation {
-    set(...args: number[] | [THREE.ColorRepresentation]): any;
+    set: (...args: number[] | [THREE.ColorRepresentation]) => any;
 }
 interface VectorRepresentation extends MathRepresentation {
-    setScalar(s: number): any;
+    setScalar: (s: number) => any;
 }
 export interface VectorCoordinates {
     x: number;
@@ -119,22 +142,27 @@ export interface VectorCoordinates {
     z: number;
 }
 export type MathType<T extends MathRepresentation | THREE.Euler> = T extends THREE.Color ? ConstructorParameters<typeof THREE.Color> | THREE.ColorRepresentation : T extends VectorRepresentation | THREE.Layers | THREE.Euler ? T | Parameters<T['set']> | number | VectorCoordinates : T | Parameters<T['set']>;
-export type TresVector2 = MathType<THREE.Vector2>;
-export type TresVector3 = MathType<THREE.Vector3>;
-export type TresVector4 = MathType<THREE.Vector4>;
-export type TresColor = MathType<THREE.Color>;
-export type TresLayers = MathType<THREE.Layers>;
-export type TresQuaternion = MathType<THREE.Quaternion>;
-export type TresEuler = MathType<THREE.Euler>;
+type VectorLike<VectorClass extends THREE.Vector2 | THREE.Vector3 | THREE.Vector4> = VectorClass | Parameters<VectorClass['set']> | Readonly<Parameters<VectorClass['set']>> | Parameters<VectorClass['setScalar']>[0];
+export type TresVector2 = VectorLike<THREE.Vector2>;
+export type TresVector3 = VectorLike<THREE.Vector3>;
+export type TresVector4 = VectorLike<THREE.Vector4>;
+export type TresColor = ConstructorParameters<typeof THREE.Color> | THREE.Color | number | string;
+export type TresColorArray = typeof THREE.Color | [color: THREE.ColorRepresentation];
+export type TresLayers = THREE.Layers | Parameters<THREE.Layers['set']>[0];
+export type TresQuaternion = THREE.Quaternion | Parameters<THREE.Quaternion['set']>;
+export type TresEuler = THREE.Euler;
+export type TresControl = THREE.EventDispatcher & {
+    enabled: boolean;
+};
 type WithMathProps<P> = {
     [K in keyof P]: P[K] extends MathRepresentation | THREE.Euler ? MathType<P[K]> : P[K];
 };
 interface RaycastableRepresentation {
-    raycast(raycaster: THREE.Raycaster, intersects: THREE.Intersection[]): void;
+    raycast: (raycaster: THREE.Raycaster, intersects: THREE.Intersection[]) => void;
 }
 type EventProps<P> = P extends RaycastableRepresentation ? Partial<EventHandlers> : unknown;
 export interface VueProps<P> {
-    children?: VNode[];
+    children?: VNode<P>[];
     ref?: VNodeRef;
     key?: string | number | symbol;
 }
@@ -156,4 +184,12 @@ declare module 'vue' {
     interface GlobalComponents extends TresComponents {
     }
 }
+declare module '@vue/runtime-core' {
+    interface GlobalComponents extends TresComponents {
+    }
+}
+declare module '@vue/runtime-dom' {
+    interface GlobalComponents extends TresComponents {
+    }
+}
 export {};
diff --git a/node_modules/@tresjs/core/dist/src/utils/createPriorityEventHook.d.ts b/node_modules/@tresjs/core/dist/src/utils/createPriorityEventHook.d.ts
new file mode 100644
index 0000000..048eb2f
--- /dev/null
+++ b/node_modules/@tresjs/core/dist/src/utils/createPriorityEventHook.d.ts
@@ -0,0 +1,18 @@
+import { EventHookOff, IsAny } from '@vueuse/core';
+
+export type Callback<T> = IsAny<T> extends true ? (param: any) => void : ([
+    T
+] extends [void] ? () => void : (param: T) => void);
+export type PriorityEventHookOn<T> = (fn: Callback<T>, priority?: number) => {
+    off: () => void;
+};
+export type PriorityEventHookOff<T> = EventHookOff<T>;
+export type PriorityEventHookTrigger<T = any> = (param?: T) => void;
+export interface PriorityEventHook<T = any> {
+    on: PriorityEventHookOn<T>;
+    off: EventHookOff<T>;
+    trigger: PriorityEventHookTrigger<T>;
+    dispose: () => void;
+    count: number;
+}
+export declare function createPriorityEventHook<T>(): PriorityEventHook<T>;
diff --git a/node_modules/@tresjs/core/dist/src/utils/index.d.ts b/node_modules/@tresjs/core/dist/src/utils/index.d.ts
index 70df0ac..edfa46a 100644
--- a/node_modules/@tresjs/core/dist/src/utils/index.d.ts
+++ b/node_modules/@tresjs/core/dist/src/utils/index.d.ts
@@ -1,10 +1,14 @@
-import { MeshBasicMaterial, Vector3, Mesh, Scene, Object3D } from 'three';
+import { Material, Mesh, MeshBasicMaterial, Scene, Vector3 } from 'three';
+import { AttachType, LocalState, TresInstance, TresObject, TresPrimitive } from 'src/types';
+import { nodeOps } from 'src/core/nodeOps';
+import { TresContext } from '../composables/useTresContextProvider';
 
 export declare function toSetMethodName(key: string): string;
 export declare const merge: (target: any, source: any) => any;
 export declare const isHTMLTag: (key: string) => boolean;
 export declare function isDOMElement(obj: any): obj is HTMLElement;
 export declare function kebabToCamel(str: string): string;
+export declare function hyphenate(str: string): string;
 export declare function makeMap(str: string, expectsLowerCase?: boolean): (key: string) => boolean;
 export declare const uniqueBy: <T, K>(array: T[], iteratee: (value: T) => K) => T[];
 export declare const get: <T>(obj: any, path: string | string[]) => T | undefined;
@@ -19,5 +23,30 @@ export declare function editSceneObject(scene: Scene, objectUuid: string, proper
 export declare function createHighlightMaterial(): MeshBasicMaterial;
 export declare function animateHighlight(highlightMesh: Mesh, startTime: number): void;
 export declare function stopHighlightAnimation(): void;
-export declare function createHighlightMesh(object: Object3D): Mesh;
+export declare function createHighlightMesh(object: TresObject): Mesh;
 export declare function extractBindingPosition(binding: any): Vector3;
+export declare function disposeMaterial(material: Material): void;
+export declare function disposeObject3D(object: TresObject): void;
+/**
+ * Like Array.filter, but modifies the array in place.
+ * @param array - Array to modify
+ * @param callbackFn - A function called for each element of the array. It should return a truthy value to keep the element in the array.
+ */
+export declare function filterInPlace<T>(array: T[], callbackFn: (element: T, index: number) => unknown): T[];
+export declare function resolve(obj: Record<string, any>, key: string): {
+    target: Record<string, any>;
+    key: string;
+};
+export declare function attach(parent: TresInstance, child: TresInstance, type: AttachType): void;
+export declare function detach(parent: any, child: TresInstance, type: AttachType): void;
+export declare function prepareTresInstance<T extends TresObject>(obj: T, state: Partial<LocalState>, context: TresContext): TresInstance;
+export declare function invalidateInstance(instance: TresObject): void;
+export declare function noop(fn: string): any;
+export declare function setPixelRatio(renderer: {
+    setPixelRatio?: (dpr: number) => void;
+    getPixelRatio?: () => number;
+}, systemDpr: number, userDpr?: number | [number, number]): void;
+export declare function setPrimitiveObject(newObject: TresObject, primitive: TresPrimitive, setTarget: (object: TresObject) => void, nodeOpsFns: Pick<ReturnType<typeof nodeOps>, 'patchProp' | 'insert' | 'remove'>, context: TresContext): boolean;
+export declare function unboxTresPrimitive<T>(maybePrimitive: T): T | TresInstance;
+export declare function doRemoveDetach(node: TresObject, context: TresContext): void;
+export declare function doRemoveDeregister(node: TresObject, context: TresContext): void;
diff --git a/node_modules/@tresjs/core/dist/src/utils/is.d.ts b/node_modules/@tresjs/core/dist/src/utils/is.d.ts
new file mode 100644
index 0000000..77509fa
--- /dev/null
+++ b/node_modules/@tresjs/core/dist/src/utils/is.d.ts
@@ -0,0 +1,19 @@
+import { TresObject, TresPrimitive } from 'src/types';
+import { BufferGeometry, Camera, Fog, Light, Material, Object3D, Scene } from 'three';
+
+export declare function und(u: unknown): u is undefined;
+export declare function arr(u: unknown): u is any[];
+export declare function num(u: unknown): u is number;
+export declare function str(u: unknown): u is string;
+export declare function bool(u: unknown): u is boolean;
+export declare function fun(u: unknown): u is Function;
+export declare function obj(u: unknown): u is Record<string | number | symbol, unknown>;
+export declare function object3D(u: unknown): u is Object3D;
+export declare function camera(u: unknown): u is Camera;
+export declare function bufferGeometry(u: unknown): u is BufferGeometry;
+export declare function material(u: unknown): u is Material;
+export declare function light(u: unknown): u is Light;
+export declare function fog(u: unknown): u is Fog;
+export declare function scene(u: unknown): u is Scene;
+export declare function tresObject(u: unknown): u is TresObject;
+export declare function tresPrimitive(u: unknown): u is TresPrimitive;
diff --git a/node_modules/@tresjs/core/dist/src/utils/normalize.d.ts b/node_modules/@tresjs/core/dist/src/utils/normalize.d.ts
index 44e865e..b7bd8cd 100644
--- a/node_modules/@tresjs/core/dist/src/utils/normalize.d.ts
+++ b/node_modules/@tresjs/core/dist/src/utils/normalize.d.ts
@@ -1,4 +1,4 @@
-import { ColorRepresentation, Vector3, Color } from 'three';
+import { ColorRepresentation, Color, Vector3 } from 'three';
 
 export type SizeFlexibleParams = number[] | {
     width: number;
diff --git a/node_modules/@tresjs/core/dist/src/utils/perf.d.ts b/node_modules/@tresjs/core/dist/src/utils/perf.d.ts
index 814db72..c960b74 100644
--- a/node_modules/@tresjs/core/dist/src/utils/perf.d.ts
+++ b/node_modules/@tresjs/core/dist/src/utils/perf.d.ts
@@ -1,5 +1,5 @@
-import { TresObject } from './../types';
 import { Scene } from 'three';
+import { TresObject } from './../types';
 
 export declare function calculateMemoryUsage(object: TresObject | Scene): number;
 export declare function bytesToKB(bytes: number): string;
diff --git a/node_modules/@tresjs/core/dist/src/utils/primitive/createRetargetingProxy.d.ts b/node_modules/@tresjs/core/dist/src/utils/primitive/createRetargetingProxy.d.ts
new file mode 100644
index 0000000..2f2e39c
--- /dev/null
+++ b/node_modules/@tresjs/core/dist/src/utils/primitive/createRetargetingProxy.d.ts
@@ -0,0 +1 @@
+export declare function createRetargetingProxy<T extends Record<string | number | symbol, any>, K extends keyof T & string & symbol>(target: T, getters?: Record<string | number | symbol, (t: T) => unknown>, setters?: Partial<Record<K, (val: T[K], t: T, proxy: T, setTarget: (newTarget: T) => void) => boolean>>): T;
diff --git a/node_modules/@tresjs/core/dist/src/utils/test-utils.d.ts b/node_modules/@tresjs/core/dist/src/utils/test-utils.d.ts
index 42f4b0c..2d18dc2 100644
--- a/node_modules/@tresjs/core/dist/src/utils/test-utils.d.ts
+++ b/node_modules/@tresjs/core/dist/src/utils/test-utils.d.ts
@@ -1 +1,3 @@
-export declare function withSetup(composable: any): (import('vue').App<Element> | undefined)[];
+import { Fn } from '@vueuse/core';
+
+export declare function withSetup(composable: Fn): (import('vue').App<Element> | undefined)[];
diff --git a/node_modules/@tresjs/core/dist/tres.js b/node_modules/@tresjs/core/dist/tres.js
index e4d5298..4233d17 100644
--- a/node_modules/@tresjs/core/dist/tres.js
+++ b/node_modules/@tresjs/core/dist/tres.js
@@ -1,607 +1,1050 @@
 /**
  * name: @tresjs/core
- * version: v3.8.0
+ * version: v4.2.5
  * (c) 2024
  * description: Declarative ThreeJS using Vue Components
  * author: Alvaro Saburido <hola@alvarosaburido.dev> (https://github.com/alvarosabu/)
  */
-var De = Object.defineProperty;
-var Be = (e, r, t) => r in e ? De(e, r, { enumerable: !0, configurable: !0, writable: !0, value: t }) : e[r] = t;
-var J = (e, r, t) => (Be(e, typeof r != "symbol" ? r + "" : r, t), t);
-import { ref as R, computed as T, watchEffect as D, onUnmounted as G, shallowRef as j, watch as ge, reactive as ve, readonly as q, provide as K, inject as je, createRenderer as He, defineComponent as ne, useSlots as Re, getCurrentInstance as se, onMounted as Ie, openBlock as $e, createElementBlock as Ne, normalizeClass as Ve, unref as ze, normalizeStyle as We, h as ie, Fragment as Ue } from "vue";
-import * as he from "three";
-import { PerspectiveCamera as X, OrthographicCamera as Fe, Camera as Ge, Clock as Je, Vector3 as ye, Color as W, MeshBasicMaterial as we, DoubleSide as Qe, REVISION as Ye, SRGBColorSpace as qe, ACESFilmicToneMapping as Ke, PCFSoftShadowMap as Xe, WebGLRenderer as Q, TextureLoader as Ze, Vector2 as et, Raycaster as tt, BufferAttribute as rt, Scene as ot, Line as nt, BufferGeometry as ae, Float32BufferAttribute as le, LineBasicMaterial as st, Mesh as it, BackSide as at, DirectionalLightHelper as lt, PointLightHelper as ut, SpotLightHelper as ct, HemisphereLightHelper as dt, ArrowHelper as ft } from "three";
-import { createEventHook as H, useRafFn as be, toValue as _, unrefElement as pt, useDevicePixelRatio as mt, usePointer as gt, useElementBounding as vt, useWindowSize as ht, useElementSize as yt, refDebounced as ue, useFps as wt, useMemory as bt } from "@vueuse/core";
-const _t = "@tresjs/core", Et = "module", Ct = "3.8.0", Mt = "pnpm@8.15.6", xt = "Declarative ThreeJS using Vue Components", St = "Alvaro Saburido <hola@alvarosaburido.dev> (https://github.com/alvarosabu/)", Pt = "MIT", kt = [
+var bt = Object.defineProperty;
+var Pt = (e, t, n) => t in e ? bt(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
+var me = (e, t, n) => Pt(e, typeof t != "symbol" ? t + "" : t, n);
+import { ref as H, computed as V, watchEffect as Te, onUnmounted as K, shallowRef as $, watch as ce, readonly as ye, unref as J, provide as _e, inject as Mt, isRef as Ct, reactive as Et, defineComponent as Be, useSlots as Tt, getCurrentInstance as Ie, onMounted as St, openBlock as At, createElementBlock as kt, normalizeClass as xt, normalizeStyle as Lt, createRenderer as Rt, h as He, Fragment as Ot } from "vue";
+import * as et from "three";
+import { PerspectiveCamera as we, Camera as Dt, Clock as tt, Vector3 as Se, Color as Z, Scene as nt, MathUtils as rt, MeshBasicMaterial as ot, DoubleSide as jt, REVISION as Bt, SRGBColorSpace as It, ACESFilmicToneMapping as st, PCFSoftShadowMap as Ht, NoToneMapping as $t, WebGLRenderer as he, TextureLoader as Ut, Vector2 as ge, Raycaster as Ft, BufferAttribute as Wt, Object3D as Nt, Line as zt, BufferGeometry as $e, Float32BufferAttribute as Ue, LineBasicMaterial as Gt, Mesh as Vt, BackSide as Yt, DirectionalLightHelper as qt, PointLightHelper as Jt, SpotLightHelper as Kt, HemisphereLightHelper as Qt, ArrowHelper as Xt } from "three";
+import { createEventHook as j, useRafFn as it, toValue as k, unrefElement as Zt, useDevicePixelRatio as en, usePointer as tn, useElementBounding as nn, useWindowSize as rn, useElementSize as on, refDebounced as Fe, tryOnScopeDispose as sn, useFps as an, useMemory as ln } from "@vueuse/core";
+const cn = "@tresjs/core", un = "module", fn = "4.2.5", dn = "pnpm@9.1.4", pn = "Declarative ThreeJS using Vue Components", mn = "Alvaro Saburido <hola@alvarosaburido.dev> (https://github.com/alvarosabu/)", hn = "MIT", gn = [
   "vue",
   "3d",
   "threejs",
   "three",
   "threejs-vue"
-], Tt = !1, At = {
+], vn = !1, yn = {
   ".": {
     types: "./dist/index.d.ts",
-    require: "./dist/tres.umd.cjs",
-    import: "./dist/tres.js"
+    import: "./dist/tres.js",
+    require: "./dist/tres.umd.cjs"
   },
   "./components": {
-    types: "./dist/components/index.d.ts"
+    types: "./dist/src/components/index.d.ts"
   },
   "./composables": {
-    types: "./dist/composables/index.d.ts"
+    types: "./dist/src/composables/index.d.ts"
   },
   "./types": {
-    types: "./dist/types/index.d.ts"
+    types: "./dist/src/types/index.d.ts"
   },
   "./utils": {
-    types: "./dist/utils/index.d.ts"
+    types: "./dist/src/utils/index.d.ts"
   },
   "./*": "./*"
-}, Lt = "./dist/tres.js", Ot = "./dist/tres.js", Dt = "./dist/index.d.ts", Bt = [
-  "dist",
-  "*.d.ts"
-], jt = {
+}, _n = "./dist/tres.js", wn = "./dist/tres.js", bn = "./dist/index.d.ts", Pn = [
+  "*.d.ts",
+  "dist"
+], Mn = {
   access: "public"
-}, Ht = {
+}, Cn = {
   dev: "cd playground && npm run dev",
   build: "vite build",
   playground: "cd playground && npm run dev",
   test: "vitest",
   "test:ci": "vitest run",
-  "test:ui": "vitest --ui",
+  "test:ui": "vitest --ui --coverage.enabled=true",
   release: "release-it",
   coverage: "vitest run --coverage",
-  lint: "eslint . --ext .js,.jsx,.ts,.tsx,.vue",
+  lint: "eslint .",
+  "lint:fix": "eslint . --fix",
   "docs:dev": "vitepress dev docs",
   "docs:build": "vitepress build docs",
   "docs:serve": "vitepress serve docs",
   "docs:preview": "vitepress preview docs",
-  "docs:contributors": "esno scripts/update-contributors.ts"
-}, Rt = {
+  "docs:contributors": "esno scripts/update-contributors.ts",
+  prepare: "node .husky/install.mjs"
+}, En = {
   three: ">=0.133",
-  vue: ">=3.3"
-}, It = {
-  "@alvarosabu/utils": "^3.1.1",
-  "@vue/devtools-api": "^6.6.1",
-  "@vueuse/core": "^10.7.0"
-}, $t = {
+  vue: ">=3.4"
+}, Tn = {
+  "@alvarosabu/utils": "^3.2.0",
+  "@vue/devtools-api": "^6.6.3",
+  "@vueuse/core": "^10.11.0"
+}, Sn = {
   "@release-it/conventional-changelog": "^8.0.1",
-  "@stackblitz/sdk": "^1.9.0",
-  "@tresjs/cientos": "3.8.0",
-  "@tresjs/eslint-config-vue": "^0.2.1",
-  "@types/three": "^0.163.0",
-  "@typescript-eslint/eslint-plugin": "^7.5.0",
-  "@typescript-eslint/parser": "^7.5.0",
-  "@vitejs/plugin-vue": "^5.0.4",
+  "@stackblitz/sdk": "^1.11.0",
+  "@tresjs/cientos": "3.9.0",
+  "@tresjs/eslint-config": "^1.1.0",
+  "@types/three": "^0.166.0",
+  "@typescript-eslint/eslint-plugin": "^7.16.0",
+  "@typescript-eslint/parser": "^7.16.0",
+  "@vitejs/plugin-vue": "^5.0.5",
   "@vitest/coverage-c8": "^0.33.0",
-  "@vitest/ui": "^1.0.4",
-  "@vue/test-utils": "^2.4.3",
-  eslint: "^8.55.0",
-  "eslint-plugin-vue": "^9.19.2",
-  esno: "^4.0.0",
-  gsap: "^3.12.3",
-  jsdom: "^24.0.0",
+  "@vitest/coverage-v8": "^2.0.2",
+  "@vitest/ui": "^2.0.2",
+  "@vue/test-utils": "^2.4.6",
+  eslint: "^9.6.0",
+  "eslint-plugin-vue": "^9.27.0",
+  esno: "^4.7.0",
+  gsap: "^3.12.5",
+  husky: "^9.0.11",
+  jsdom: "^24.1.0",
   kolorist: "^1.8.0",
   ohmyfetch: "^0.4.21",
-  pathe: "^1.1.1",
-  "release-it": "^17.0.1",
+  pathe: "^1.1.2",
+  "release-it": "^17.5.0",
   "rollup-plugin-analyzer": "^4.0.0",
   "rollup-plugin-copy": "^3.5.0",
-  "rollup-plugin-visualizer": "^5.11.0",
-  three: "^0.163.0",
-  unocss: "^0.58.0",
-  unplugin: "^1.10.1",
-  "unplugin-vue-components": "^0.26.0",
-  vite: "^5.2.7",
+  "rollup-plugin-visualizer": "^5.12.0",
+  sponsorkit: "^0.14.6",
+  three: "^0.166.1",
+  unocss: "^0.61.3",
+  unplugin: "^1.11.0",
+  "unplugin-vue-components": "^0.27.2",
+  vite: "^5.3.3",
   "vite-plugin-banner": "^0.7.1",
-  "vite-plugin-dts": "3.8.1",
-  "vite-plugin-inspect": "^0.8.1",
+  "vite-plugin-dts": "3.9.1",
+  "vite-plugin-inspect": "^0.8.4",
   "vite-plugin-require-transform": "^1.0.21",
   "vite-svg-loader": "^5.1.0",
-  vitepress: "1.0.2",
-  vitest: "^1.0.4",
-  vue: "^3.3.11",
-  "vue-demi": "^0.14.6"
-}, Nt = {
-  name: _t,
-  type: Et,
-  version: Ct,
-  packageManager: Mt,
-  description: xt,
-  author: St,
-  license: Pt,
-  keywords: kt,
-  sideEffects: Tt,
-  exports: At,
-  main: Lt,
-  module: Ot,
-  types: Dt,
-  files: Bt,
-  publishConfig: jt,
-  scripts: Ht,
-  peerDependencies: Rt,
-  dependencies: It,
-  devDependencies: $t
-}, Vt = ({ sizes: e, scene: r }) => {
-  const t = R([]), o = T(
+  vitepress: "1.3.0",
+  vitest: "^2.0.2",
+  vue: "^3.4.31",
+  "vue-demi": "^0.14.8"
+}, An = {
+  name: cn,
+  type: un,
+  version: fn,
+  packageManager: dn,
+  description: pn,
+  author: mn,
+  license: hn,
+  keywords: gn,
+  sideEffects: vn,
+  exports: yn,
+  main: _n,
+  module: wn,
+  types: bn,
+  files: Pn,
+  publishConfig: Mn,
+  scripts: Cn,
+  peerDependencies: En,
+  dependencies: Tn,
+  devDependencies: Sn
+};
+function be(e) {
+  return typeof e > "u";
+}
+function de(e) {
+  return Array.isArray(e);
+}
+function kn(e) {
+  return typeof e == "number";
+}
+function at(e) {
+  return typeof e == "string";
+}
+function G(e) {
+  return typeof e == "function";
+}
+function U(e) {
+  return e === Object(e) && !de(e) && !G(e);
+}
+function N(e) {
+  return U(e) && "isObject3D" in e && !!e.isObject3D;
+}
+function We(e) {
+  return U(e) && "isCamera" in e && !!e.isCamera;
+}
+function xn(e) {
+  return U(e) && "isBufferGeometry" in e && !!e.isBufferGeometry;
+}
+function Ln(e) {
+  return U(e) && "isMaterial" in e && !!e.isMaterial;
+}
+function Rn(e) {
+  return U(e) && "isLight" in e && !!e.isLight;
+}
+function On(e) {
+  return U(e) && "isFog" in e && !!e.isFog;
+}
+function Dn(e) {
+  return U(e) && "isScene" in e && !!e.isScene;
+}
+function oe(e) {
+  return N(e) || xn(e) || Ln(e) || On(e);
+}
+function jn(e) {
+  return U(e) && !!e.isPrimitive;
+}
+const Bn = ({ sizes: e }) => {
+  const t = H([]), n = V(
     () => t.value[0]
-  ), s = (a, l = !1) => {
-    t.value.some(({ uuid: c }) => c === a.uuid) || (l ? n(a) : t.value.push(a));
-  }, i = (a) => {
-    t.value = t.value.filter(({ uuid: l }) => l !== a.uuid);
-  }, n = (a) => {
-    const l = a instanceof Ge ? a : t.value.find((m) => m.uuid === a);
+  ), r = (i) => {
+    const l = i instanceof Dt ? i : t.value.find((o) => o.uuid === i);
     if (!l)
       return;
-    const c = t.value.filter(({ uuid: m }) => m !== l.uuid);
+    const c = t.value.filter(({ uuid: o }) => o !== l.uuid);
     t.value = [l, ...c];
+  }, s = (i, l = !1) => {
+    if (We(i)) {
+      const c = i;
+      if (t.value.some(({ uuid: o }) => o === c.uuid))
+        return;
+      l ? r(c) : t.value.push(c);
+    }
+  }, a = (i) => {
+    if (We(i)) {
+      const l = i;
+      t.value = t.value.filter(({ uuid: c }) => c !== l.uuid);
+    }
   };
-  return D(() => {
-    e.aspectRatio.value && t.value.forEach((a) => {
-      a instanceof X && (a.aspect = e.aspectRatio.value), (a instanceof X || a instanceof Fe) && a.updateProjectionMatrix();
+  return Te(() => {
+    e.aspectRatio.value && t.value.forEach((i) => {
+      !i.manual && (i instanceof we || In(i)) && (i instanceof we ? i.aspect = e.aspectRatio.value : (i.left = e.width.value * -0.5, i.right = e.width.value * 0.5, i.top = e.height.value * 0.5, i.bottom = e.height.value * -0.5), i.updateProjectionMatrix());
     });
-  }), r.userData.tres__registerCamera = s, r.userData.tres__deregisterCamera = i, G(() => {
+  }), K(() => {
     t.value = [];
   }), {
-    camera: o,
+    camera: n,
     cameras: t,
     registerCamera: s,
-    deregisterCamera: i,
-    setCameraActive: n
+    deregisterCamera: a,
+    setCameraActive: r
   };
-}, _e = H(), Ee = H(), te = H(), B = new Je();
-let U = 0, F = 0;
-const { pause: zt, resume: Wt, isActive: Ut } = be(
+};
+function In(e) {
+  return e.hasOwnProperty("isOrthographicCamera") && e.isOrthographicCamera;
+}
+const lt = j(), ct = j(), Ae = j(), ee = new tt();
+let ue = 0, fe = 0;
+const { pause: Hn, resume: Ne, isActive: $n } = it(
   () => {
-    _e.trigger({ delta: U, elapsed: F, clock: B }), Ee.trigger({ delta: U, elapsed: F, clock: B }), te.trigger({ delta: U, elapsed: F, clock: B });
+    lt.trigger({ delta: ue, elapsed: fe, clock: ee }), ct.trigger({ delta: ue, elapsed: fe, clock: ee }), Ae.trigger({ delta: ue, elapsed: fe, clock: ee });
   },
   { immediate: !1 }
 );
-te.on(() => {
-  U = B.getDelta(), F = B.getElapsedTime();
+Ae.on(() => {
+  ue = ee.getDelta(), fe = ee.getElapsedTime();
 });
-const re = () => ({
-  onBeforeLoop: _e.on,
-  onLoop: Ee.on,
-  onAfterLoop: te.on,
-  pause: zt,
-  resume: Wt,
-  isActive: Ut
-}), Rr = !0, $ = "[TresJS ▲ ■ ●] ";
-function A() {
-  function e(...o) {
-    typeof o[0] == "string" ? o[0] = $ + o[0] : o.unshift($), console.error(...o);
+let ze = !1;
+const Ur = () => (ze || (ze = !0, Ne()), {
+  onBeforeLoop: lt.on,
+  onLoop: ct.on,
+  onAfterLoop: Ae.on,
+  pause: Hn,
+  resume: Ne,
+  isActive: $n
+}), Fr = !0, se = "[TresJS ▲ ■ ●] ";
+function Y() {
+  function e(...r) {
+    typeof r[0] == "string" ? r[0] = se + r[0] : r.unshift(se), console.error(...r);
   }
-  function r(...o) {
-    typeof o[0] == "string" ? o[0] = $ + o[0] : o.unshift($), console.warn(...o);
+  function t(...r) {
+    typeof r[0] == "string" ? r[0] = se + r[0] : r.unshift(se), console.warn(...r);
   }
-  function t(o, s) {
+  function n(r, s) {
   }
   return {
     logError: e,
-    logWarning: r,
-    logMessage: t
+    logWarning: t,
+    logMessage: n
   };
 }
-function Ir(e) {
-  return typeof e == "number" ? [e, e, e] : e instanceof ye ? [e.x, e.y, e.z] : e;
+function Wr(e) {
+  return typeof e == "number" ? [e, e, e] : e instanceof Se ? [e.x, e.y, e.z] : e;
 }
-function Ft(e) {
-  return e instanceof W ? e : Array.isArray(e) ? new W(...e) : new W(e);
+function Un(e) {
+  return e instanceof Z ? e : Array.isArray(e) ? new Z(...e) : new Z(e);
 }
-class Gt extends he.Mesh {
-  constructor(...t) {
-    super(...t);
-    J(this, "type", "HightlightMesh");
-    J(this, "createTime");
+class Fn extends et.Mesh {
+  constructor(...n) {
+    super(...n);
+    me(this, "type", "HightlightMesh");
+    me(this, "createTime");
     this.createTime = Date.now();
   }
   onBeforeRender() {
-    const o = (Date.now() - this.createTime) / 1e3, n = 1 + 0.07 * Math.sin(2.5 * o);
-    this.scale.set(n, n, n);
+    const r = (Date.now() - this.createTime) / 1e3, i = 1 + 0.07 * Math.sin(2.5 * r);
+    this.scale.set(i, i, i);
   }
 }
-const Ce = (e, r) => {
-  for (const t of Object.keys(r))
-    r[t] instanceof Object && Object.assign(r[t], Ce(e[t], r[t]));
-  return Object.assign(e || {}, r), e;
-}, Jt = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot", Qt = /* @__PURE__ */ Yt(Jt);
-function ce(e) {
+const ut = (e, t) => {
+  for (const n of Object.keys(t))
+    t[n] instanceof Object && Object.assign(t[n], ut(e[n], t[n]));
+  return Object.assign(e || {}, t), e;
+}, Wn = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot", Nn = /* @__PURE__ */ Vn(Wn);
+function Ge(e) {
   return e && e.nodeType === 1;
 }
-function N(e) {
-  return e.replace(/-([a-z])/g, (r, t) => t.toUpperCase());
-}
-function Yt(e, r) {
-  const t = /* @__PURE__ */ Object.create(null), o = e.split(",");
-  for (let s = 0; s < o.length; s++)
-    t[o[s]] = !0;
-  return r ? (s) => !!t[s.toLowerCase()] : (s) => !!t[s];
-}
-const qt = (e, r) => {
-  const t = /* @__PURE__ */ new Set(), o = [];
-  for (const s of e) {
-    const i = r(s);
-    t.has(i) || (t.add(i), o.push(s));
-  }
-  return o;
-}, de = (e, r) => {
-  if (!r)
+function ie(e) {
+  return e.replace(/-([a-z])/g, (t, n) => n.toUpperCase());
+}
+const zn = /\B([A-Z])/g;
+function Gn(e) {
+  return e.replace(zn, "-$1").toLowerCase();
+}
+function Vn(e, t) {
+  const n = /* @__PURE__ */ Object.create(null), r = e.split(",");
+  for (let s = 0; s < r.length; s++)
+    n[r[s]] = !0;
+  return (s) => !!n[s];
+}
+const Ve = (e, t) => {
+  if (!t)
     return;
-  const t = Array.isArray(r) ? r : r.match(/([^[.\]])+/g);
-  return t == null ? void 0 : t.reduce((o, s) => o && o[s], e);
-}, Kt = (e, r, t) => {
-  const o = Array.isArray(r) ? r : r.match(/([^[.\]])+/g);
-  o && o.reduce((s, i, n) => (s[i] === void 0 && (s[i] = {}), n === o.length - 1 && (s[i] = t), s[i]), e);
+  const n = Array.isArray(t) ? t : t.match(/([^[.\]])+/g);
+  return n == null ? void 0 : n.reduce((r, s) => r && r[s], e);
+}, Yn = (e, t, n) => {
+  const r = Array.isArray(t) ? t : t.match(/([^[.\]])+/g);
+  r && r.reduce((s, a, i) => (s[a] === void 0 && (s[a] = {}), i === r.length - 1 && (s[a] = n), s[a]), e);
 };
-function Me(e, r) {
-  if (ce(e) && ce(r)) {
-    const s = e.attributes, i = r.attributes;
-    return s.length !== i.length ? !1 : Array.from(s).every(({ name: n, value: a }) => r.getAttribute(n) === a);
+function ft(e, t) {
+  if (Ge(e) && Ge(t)) {
+    const s = e.attributes, a = t.attributes;
+    return s.length !== a.length ? !1 : Array.from(s).every(({ name: i, value: l }) => t.getAttribute(i) === l);
   }
-  if (e === r)
+  if (e === t)
     return !0;
-  if (e === null || typeof e != "object" || r === null || typeof r != "object")
+  if (e === null || typeof e != "object" || t === null || typeof t != "object")
     return !1;
-  const t = Object.keys(e), o = Object.keys(r);
-  if (t.length !== o.length)
+  const n = Object.keys(e), r = Object.keys(t);
+  if (n.length !== r.length)
     return !1;
-  for (const s of t)
-    if (!o.includes(s) || !Me(e[s], r[s]))
+  for (const s of n)
+    if (!r.includes(s) || !ft(e[s], t[s]))
       return !1;
   return !0;
 }
-function Xt(e, r) {
-  if (!Array.isArray(e) || !Array.isArray(r) || e.length !== r.length)
+function qn(e, t) {
+  if (!Array.isArray(e) || !Array.isArray(t) || e.length !== t.length)
     return !1;
-  for (let t = 0; t < e.length; t++)
-    if (!Me(e[t], r[t]))
+  for (let n = 0; n < e.length; n++)
+    if (!ft(e[n], t[n]))
       return !1;
   return !0;
 }
-const Zt = Array.isArray;
-function er(e, r, t, o) {
-  const s = (l) => {
-    if (l.uuid === r)
-      return l;
-    for (const c of l.children) {
-      const m = s(c);
-      if (m)
-        return m;
+const Jn = Array.isArray;
+function Kn(e, t, n, r) {
+  const s = (c) => {
+    if (c.uuid === t)
+      return c;
+    for (const o of c.children) {
+      const u = s(o);
+      if (u)
+        return u;
     }
-  }, i = s(e);
-  if (!i) {
+  }, a = s(e);
+  if (!a) {
     console.warn("Object with UUID not found in the scene.");
     return;
   }
-  let n = i;
-  for (let l = 0; l < t.length - 1; l++)
-    if (n[t[l]] !== void 0)
-      n = n[t[l]];
+  let i = a;
+  for (let c = 0; c < n.length - 1; c++)
+    if (i[n[c]] !== void 0)
+      i = i[n[c]];
     else {
-      console.warn(`Property path is not valid: ${t.join(".")}`);
+      console.warn(`Property path is not valid: ${n.join(".")}`);
       return;
     }
-  const a = t[t.length - 1];
-  n[a] !== void 0 ? n[a] = o : console.warn(`Property path is not valid: ${t.join(".")}`);
+  const l = n[n.length - 1];
+  i[l] !== void 0 ? i[l] = r : console.warn(`Property path is not valid: ${n.join(".")}`);
 }
-function tr(e) {
-  const r = new we({
+function Qn(e) {
+  const t = new ot({
     color: 11003607,
     // Highlight color, e.g., yellow
     transparent: !0,
     opacity: 0.2,
     depthTest: !1,
     // So the highlight is always visible
-    side: Qe
+    side: jt
     // To e
   });
-  return new Gt(e.geometry.clone(), r);
+  return new Fn(e.geometry.clone(), t);
+}
+function Xn(e) {
+  var n;
+  let t = e.value;
+  return e.value && ((n = e.value) != null && n.isMesh) && (t = e.value.position), Array.isArray(e.value) && (t = new Se(...t)), t;
+}
+function Zn(e) {
+  return "map" in e;
+}
+function Ye(e) {
+  Zn(e) && e.map && e.map.dispose(), e.dispose();
+}
+function dt(e) {
+  var n, r;
+  if (e.parent && ((n = e.removeFromParent) == null || n.call(e)), delete e.__tres, [...e.children].forEach((s) => dt(s)), !(e instanceof nt)) {
+    const s = e;
+    e && ((r = e.dispose) == null || r.call(e)), s.geometry && (s.geometry.dispose(), delete s.geometry), Array.isArray(s.material) ? (s.material.forEach((a) => Ye(a)), delete s.material) : s.material && (Ye(s.material), delete s.material);
+  }
+}
+function er(e, t) {
+  let n = 0;
+  for (let r = 0; r < e.length; r++)
+    t(e[r], r) && (e[n] = e[r], n++);
+  return e.length = n, e;
+}
+function Pe(e, t) {
+  let n = e;
+  if (t.includes("-")) {
+    const r = t.split("-");
+    let s = r.shift();
+    for (; n && r.length; )
+      s in n ? (n = n[s], s = r.shift()) : s = qe(s, r.shift());
+    return { target: n, key: qe(s, ...r) };
+  } else
+    return { target: n, key: t };
+}
+function qe(...e) {
+  return e.map((t, n) => n === 0 ? t : t.charAt(0).toUpperCase() + t.slice(1)).join("");
+}
+const Je = /-\d+$/;
+function tr(e, t, n) {
+  if (at(n)) {
+    if (Je.test(n)) {
+      const a = n.replace(Je, ""), { target: i, key: l } = Pe(e, a);
+      if (!Array.isArray(i[l])) {
+        const c = i[l], o = [];
+        o.__tresDetach = () => {
+          o.every((u) => be(u)) && (i[l] = c);
+        }, i[l] = o;
+      }
+    }
+    const { target: r, key: s } = Pe(e, n);
+    t.__tres.previousAttach = r[s], r[s] = Q(t);
+  } else
+    t.__tres.previousAttach = n(e, t);
+}
+function nr(e, t, n) {
+  var r, s, a;
+  if (at(n)) {
+    const { target: i, key: l } = Pe(e, n), c = t.__tres.previousAttach;
+    c === void 0 ? delete i[l] : i[l] = c, "__tresDetach" in i && i.__tresDetach();
+  } else
+    (s = (r = t.__tres) == null ? void 0 : r.previousAttach) == null || s.call(r, e, t);
+  (a = t.__tres) == null || delete a.previousAttach;
+}
+function z(e, t, n) {
+  const r = e;
+  return r.__tres = {
+    type: "unknown",
+    eventCount: 0,
+    root: n,
+    handlers: {},
+    memoizedProps: {},
+    objects: [],
+    parent: null,
+    previousAttach: null,
+    ...t
+  }, r.__tres.attach || (r.isMaterial ? r.__tres.attach = "material" : r.isBufferGeometry ? r.__tres.attach = "geometry" : r.isFog && (r.__tres.attach = "fog")), r;
+}
+function pt(e) {
+  var n;
+  const t = (n = e == null ? void 0 : e.__tres) == null ? void 0 : n.root;
+  t && t.render && t.render.canBeInvalidated.value && t.invalidate();
+}
+function rr(e, t, n) {
+  var s;
+  if (!G(e.setPixelRatio))
+    return;
+  let r = 0;
+  if (de(n) && n.length >= 2) {
+    const [a, i] = n;
+    r = rt.clamp(t, a, i);
+  } else kn(n) ? r = n : r = t;
+  r !== ((s = e.getPixelRatio) == null ? void 0 : s.call(e)) && e.setPixelRatio(r);
+}
+function or(e, t, n, r, s) {
+  const a = [...t.__tres.objects], i = Q(t);
+  if (e = Q(e), i === e)
+    return !0;
+  const l = z(e, t.__tres ?? {}, s), c = t.parent ?? t.__tres.parent ?? null, o = { ...t.__tres.memoizedProps };
+  delete o.object;
+  for (const u of a)
+    mt(u, s), ht(u, s);
+  i.__tres.objects = [], r.remove(t);
+  for (const [u, y] of Object.entries(o))
+    r.patchProp(l, u, l[u], y);
+  n(e), r.insert(t, c);
+  for (const u of a)
+    r.insert(u, t);
+  return !0;
+}
+function Q(e) {
+  return jn(e) ? (e.object.__tres = e.__tres, e.object) : e;
+}
+function mt(e, t) {
+  var r, s, a, i;
+  const n = ((r = e.__tres) == null ? void 0 : r.parent) || t.scene.value;
+  e.__tres && (e.__tres.parent = null), n && n.__tres && "objects" in n.__tres && er(n.__tres.objects, (l) => l !== e), (s = e.__tres) != null && s.attach ? nr(n, e, e.__tres.attach) : ((i = (a = e.parent) == null ? void 0 : a.remove) == null || i.call(a, Q(e)), e.parent = null);
 }
-function xe(e) {
-  var t;
-  let r = e.value;
-  return e.value && ((t = e.value) != null && t.isMesh) && (r = e.value.position), Array.isArray(e.value) && (r = new ye(...r)), r;
+function ht(e, t) {
+  var n;
+  (n = e.traverse) == null || n.call(e, (r) => {
+    var s;
+    t.deregisterCamera(r), (s = t.eventManager) == null || s.deregisterPointerMissedObject(r);
+  }), t.deregisterCamera(e), pt(e);
 }
-const rr = Number.parseInt(Ye.replace("dev", "")), V = {
+const sr = Number.parseInt(Bt.replace("dev", "")), ae = {
   realistic: {
     shadows: !0,
     physicallyCorrectLights: !0,
-    outputColorSpace: qe,
-    toneMapping: Ke,
+    outputColorSpace: It,
+    toneMapping: st,
     toneMappingExposure: 3,
     shadowMap: {
       enabled: !0,
-      type: Xe
+      type: Ht
     }
+  },
+  flat: {
+    toneMapping: $t,
+    toneMappingExposure: 1
   }
 };
-function or({
-  scene: e,
-  canvas: r,
+function ir({
+  canvas: e,
   options: t,
-  disableRender: o,
-  contextParts: { sizes: s, camera: i }
+  contextParts: { sizes: n, render: r, invalidate: s, advance: a }
 }) {
-  const n = T(() => ({
-    alpha: _(t.alpha),
-    depth: _(t.depth),
-    canvas: pt(r),
-    context: _(t.context),
-    stencil: _(t.stencil),
-    antialias: _(t.antialias) === void 0 ? !0 : _(t.antialias),
-    precision: _(t.precision),
-    powerPreference: _(t.powerPreference),
-    premultipliedAlpha: _(t.premultipliedAlpha),
-    preserveDrawingBuffer: _(t.preserveDrawingBuffer),
-    logarithmicDepthBuffer: _(t.logarithmicDepthBuffer),
-    failIfMajorPerformanceCaveat: _(t.failIfMajorPerformanceCaveat)
-  })), a = j(new Q(n.value));
-  ge(n, () => {
-    a.value.dispose(), a.value = new Q(n.value);
-  }), D(() => {
-    a.value.setSize(s.width.value, s.height.value);
-  });
-  const { pixelRatio: l } = mt();
-  D(() => {
-    a.value.setPixelRatio(l.value);
-  });
-  const { logError: c } = A(), d = (() => {
-    const p = new Q(), y = {
+  const i = V(() => ({
+    alpha: k(t.alpha) ?? !0,
+    depth: k(t.depth),
+    canvas: Zt(e),
+    context: k(t.context),
+    stencil: k(t.stencil),
+    antialias: k(t.antialias) ?? !0,
+    precision: k(t.precision),
+    powerPreference: k(t.powerPreference),
+    premultipliedAlpha: k(t.premultipliedAlpha),
+    preserveDrawingBuffer: k(t.preserveDrawingBuffer),
+    logarithmicDepthBuffer: k(t.logarithmicDepthBuffer),
+    failIfMajorPerformanceCaveat: k(t.failIfMajorPerformanceCaveat)
+  })), l = $(new he(i.value));
+  function c() {
+    t.renderMode === "on-demand" && s();
+  }
+  ce(i, () => {
+    l.value.dispose(), l.value = new he(i.value), c();
+  }), ce([n.width, n.height], () => {
+    l.value.setSize(n.width.value, n.height.value), c();
+  }, {
+    immediate: !0
+  }), ce(() => t.clearColor, c);
+  const { pixelRatio: o } = en(), { logError: u } = Y(), f = (() => {
+    const v = new he(), b = {
       shadowMap: {
-        enabled: p.shadowMap.enabled,
-        type: p.shadowMap.type
+        enabled: v.shadowMap.enabled,
+        type: v.shadowMap.type
       },
-      toneMapping: p.toneMapping,
-      toneMappingExposure: p.toneMappingExposure,
-      outputColorSpace: p.outputColorSpace
+      toneMapping: v.toneMapping,
+      toneMappingExposure: v.toneMappingExposure,
+      outputColorSpace: v.outputColorSpace
     };
-    return p.dispose(), y;
-  })();
-  D(() => {
-    const p = _(t.preset);
-    p && (p in V || c(`Renderer Preset must be one of these: ${Object.keys(V).join(", ")}`), Ce(a.value, V[p]));
-    const y = (C, M) => {
-      const w = _(C), S = () => {
-        if (p)
-          return de(V[p], M);
+    return v.dispose(), b;
+  })(), g = k(t.renderMode);
+  return g === "on-demand" && s(), g === "manual" && setTimeout(() => {
+    a();
+  }, 100), Te(() => {
+    const v = k(t.preset);
+    v && (v in ae || u(`Renderer Preset must be one of these: ${Object.keys(ae).join(", ")}`), ut(l.value, ae[v])), rr(l.value, o.value, k(t.dpr)), g === "always" && (r.frames.value = Math.max(1, r.frames.value));
+    const b = (C, E) => {
+      const P = k(C), S = () => {
+        if (v)
+          return Ve(ae[v], E);
       };
-      if (w !== void 0)
-        return w;
-      const v = S();
-      return v !== void 0 ? v : de(d, M);
-    }, b = (C, M) => Kt(a.value, M, y(C, M));
-    b(t.shadows, "shadowMap.enabled"), b(t.toneMapping, "toneMapping"), b(t.shadowMapType, "shadowMap.type"), rr < 150 && b(!t.useLegacyLights, "physicallyCorrectLights"), b(t.outputColorSpace, "outputColorSpace"), b(t.toneMappingExposure, "toneMappingExposure");
-    const x = y(t.clearColor, "clearColor");
-    x && a.value.setClearColor(
-      x ? Ft(x) : new W(0)
+      if (P !== void 0)
+        return P;
+      const M = S();
+      return M !== void 0 ? M : Ve(f, E);
+    }, m = (C, E) => Yn(l.value, E, b(C, E));
+    m(t.shadows, "shadowMap.enabled"), m(t.toneMapping ?? st, "toneMapping"), m(t.shadowMapType, "shadowMap.type"), sr < 150 && m(!t.useLegacyLights, "physicallyCorrectLights"), m(t.outputColorSpace, "outputColorSpace"), m(t.toneMappingExposure, "toneMappingExposure");
+    const d = b(t.clearColor, "clearColor");
+    d && l.value.setClearColor(
+      d ? Un(d) : new Z(0)
       // default clear color is not easily/efficiently retrievable from three
     );
-  });
-  const { pause: u, resume: f, onLoop: h } = re();
-  return h(() => {
-    i.value && !_(o) && a.value.render(e, i.value);
-  }), f(), G(() => {
-    u(), a.value.dispose(), a.value.forceContextLoss();
+  }), K(() => {
+    l.value.dispose(), l.value.forceContextLoss();
   }), {
-    renderer: a
+    renderer: l
   };
 }
-const fe = (e) => typeof e == "function", nr = (e) => !!e && e.constructor === Array;
-function sr(e) {
-  const r = { nodes: {}, materials: {} };
-  return e && e.traverse((t) => {
-    t.name && (r.nodes[t.name] = t), t.material && !r.materials[t.material.name] && (r.materials[t.material.name] = t.material);
-  }), r;
-}
-async function $r(e, r, t, o, s) {
-  const { logError: i } = A(), n = new e();
-  s && s(n), t && t(n);
-  const l = (Array.isArray(r) ? r : [r]).map(
-    (c) => new Promise((m, d) => {
-      n.load(
-        c,
-        (u) => {
-          u.scene && Object.assign(u, sr(u.scene)), m(u);
-        },
+const ar = (e) => !!e && e.constructor === Array;
+function lr(e) {
+  const t = { nodes: {}, materials: {} };
+  return e && e.traverse((n) => {
+    n.name && (t.nodes[n.name] = n), n.material && !t.materials[n.material.name] && (t.materials[n.material.name] = n.material);
+  }), t;
+}
+async function Nr(e, t, n, r, s) {
+  const { logError: a } = Y(), i = new e();
+  s && s(i), n && n(i);
+  const c = (Array.isArray(t) ? t : [t]).map(
+    (o) => new Promise((u, y) => {
+      i.load(
         o,
-        (u) => d(i("[useLoader] - Failed to load resource", u))
+        (f) => {
+          const g = f;
+          g.scene && Object.assign(g, lr(g.scene)), u(g);
+        },
+        r,
+        (f) => y(a("[useLoader] - Failed to load resource", f))
       );
     })
   );
-  return nr(r) ? await Promise.all(l) : await l[0];
+  return ar(t) ? await Promise.all(c) : await c[0];
 }
-async function Nr(e, r) {
-  const t = new Ze(r), o = (s) => new Promise((i, n) => {
-    t.load(
+async function zr(e, t) {
+  const n = new Ut(t), r = (s) => new Promise((a, i) => {
+    n.load(
       s,
-      (a) => i(a),
+      (l) => a(l),
       () => null,
       () => {
-        n(new Error("[useTextures] - Failed to load texture"));
+        i(new Error("[useTextures] - Failed to load texture"));
       }
     );
   });
-  if (Zt(e)) {
-    const s = await Promise.all(e.map((i) => o(i)));
+  if (Jn(e)) {
+    const s = await Promise.all(e.map((a) => r(a)));
     return e.length > 1 ? s : s[0];
   } else {
     const {
       map: s,
-      displacementMap: i,
-      normalMap: n,
-      roughnessMap: a,
-      metalnessMap: l,
-      aoMap: c,
-      alphaMap: m,
-      matcap: d
+      displacementMap: a,
+      normalMap: i,
+      roughnessMap: l,
+      metalnessMap: c,
+      aoMap: o,
+      alphaMap: u,
+      matcap: y
     } = e;
     return {
-      map: s ? await o(s) : null,
-      displacementMap: i ? await o(i) : null,
-      normalMap: n ? await o(n) : null,
-      roughnessMap: a ? await o(a) : null,
-      metalnessMap: l ? await o(l) : null,
-      aoMap: c ? await o(c) : null,
-      alphaMap: m ? await o(m) : null,
-      matcap: d ? await o(d) : null
+      map: s ? await r(s) : null,
+      displacementMap: a ? await r(a) : null,
+      normalMap: i ? await r(i) : null,
+      roughnessMap: l ? await r(l) : null,
+      metalnessMap: c ? await r(c) : null,
+      aoMap: o ? await r(o) : null,
+      alphaMap: u ? await r(u) : null,
+      matcap: y ? await r(y) : null
     };
   }
 }
-const ir = (e, { renderer: r, camera: t, raycaster: o }) => {
-  const s = T(() => r.value.domElement), { x: i, y: n } = gt({ target: s }), { width: a, height: l, top: c, left: m } = vt(s), d = ({ x: v, y: E }) => {
-    if (s.value)
+const cr = (e, t) => {
+  const n = V(() => t.renderer.value.domElement), r = $([]), { x: s, y: a } = tn({ target: n });
+  let i = 0;
+  const { width: l, height: c, top: o, left: u } = nn(n), y = ({ x: h, y: T }) => {
+    if (n.value)
       return {
-        x: (v - m.value) / a.value * 2 - 1,
-        y: -((E - c.value) / l.value) * 2 + 1
+        x: (h - u.value) / l.value * 2 - 1,
+        y: -((T - o.value) / c.value) * 2 + 1
       };
-  }, u = ({ x: v, y: E }) => {
-    if (t.value)
-      return o.value.setFromCamera(new et(v, E), t.value), o.value.intersectObjects(e.value, !1);
-  }, f = (v) => {
-    const E = d({
-      x: (v == null ? void 0 : v.clientX) ?? i.value,
-      y: (v == null ? void 0 : v.clientY) ?? n.value
+  }, f = ({ x: h, y: T }) => {
+    if (t.camera.value)
+      return t.raycaster.value.setFromCamera(new ge(h, T), t.camera.value), r.value = t.raycaster.value.intersectObjects(e.value, !0), r.value;
+  }, g = (h) => {
+    const T = y({
+      x: (h == null ? void 0 : h.clientX) ?? s.value,
+      y: (h == null ? void 0 : h.clientY) ?? a.value
+    });
+    return T ? f(T) || [] : [];
+  }, v = j(), b = j(), m = j(), d = j(), C = j(), E = j(), P = j(), S = j();
+  function M(h) {
+    const T = {};
+    for (const F in h)
+      typeof F != "function" && (T[F] = h[F]);
+    return T;
+  }
+  const _ = (h, T) => {
+    var Oe, De, je;
+    const F = M(T), re = new Se(T == null ? void 0 : T.clientX, T == null ? void 0 : T.clientY, 0).unproject((Oe = t.camera) == null ? void 0 : Oe.value);
+    h.trigger({
+      ...F,
+      intersections: r.value,
+      // The unprojectedPoint is wrong, math needs to be fixed
+      unprojectedPoint: re,
+      ray: (De = t.raycaster) == null ? void 0 : De.value.ray,
+      camera: (je = t.camera) == null ? void 0 : je.value,
+      sourceEvent: T,
+      delta: i,
+      stopPropagating: !1
     });
-    return E ? u(E) || [] : [];
-  }, h = T(() => f()), p = H(), y = H(), b = (v, E) => {
-    v.trigger({ event: E, intersects: f(E) });
-  }, x = (v) => {
-    b(y, v);
   };
-  let C;
-  const M = (v) => {
-    var E;
-    C = (E = f(v)[0]) == null ? void 0 : E.object;
-  }, w = (v) => {
-    var E;
-    v instanceof PointerEvent && C === ((E = f(v)[0]) == null ? void 0 : E.object) && b(p, v);
-  }, S = (v) => y.trigger({ event: v, intersects: [] });
-  return s.value.addEventListener("pointerup", w), s.value.addEventListener("pointerdown", M), s.value.addEventListener("pointermove", x), s.value.addEventListener("pointerleave", S), G(() => {
-    s != null && s.value && (s.value.removeEventListener("pointerup", w), s.value.removeEventListener("pointerdown", M), s.value.removeEventListener("pointermove", x), s.value.removeEventListener("pointerleave", S));
+  let L;
+  const x = (h) => {
+    g(h), _(m, h), L = h;
+  }, p = () => {
+    L && x(L);
+  };
+  let w, A, D;
+  const O = (h) => {
+    var T;
+    w = (T = r.value[0]) == null ? void 0 : T.object, i = 0, A = new ge(
+      (h == null ? void 0 : h.clientX) ?? s.value,
+      (h == null ? void 0 : h.clientY) ?? a.value
+    ), _(C, h);
+  };
+  let B, R = !1;
+  const ne = (h) => {
+    var T, F, re;
+    h instanceof PointerEvent && (r.value.length === 0 && _(E, h), w === ((T = r.value[0]) == null ? void 0 : T.object) && (D = new ge(
+      (h == null ? void 0 : h.clientX) ?? s.value,
+      (h == null ? void 0 : h.clientY) ?? a.value
+    ), i = A == null ? void 0 : A.distanceTo(D), h.button === 0 ? (_(v, h), B === ((F = r.value[0]) == null ? void 0 : F.object) ? R = !0 : (B = (re = r.value[0]) == null ? void 0 : re.object, R = !1)) : h.button === 2 && _(P, h)), _(d, h));
+  }, xe = (h) => {
+    R && (_(b, h), B = void 0, R = !1);
+  }, Le = (h) => _(m, h), Re = (h) => _(S, h);
+  return n.value.addEventListener("pointerup", ne), n.value.addEventListener("pointerdown", O), n.value.addEventListener("pointermove", x), n.value.addEventListener("pointerleave", Le), n.value.addEventListener("dblclick", xe), n.value.addEventListener("wheel", Re), K(() => {
+    n != null && n.value && (n.value.removeEventListener("pointerup", ne), n.value.removeEventListener("pointerdown", O), n.value.removeEventListener("pointermove", x), n.value.removeEventListener("pointerleave", Le), n.value.removeEventListener("dblclick", xe), n.value.removeEventListener("wheel", Re));
   }), {
-    intersects: h,
-    onClick: (v) => p.on(v).off,
-    onPointerMove: (v) => y.on(v).off
+    intersects: r,
+    onClick: (h) => v.on(h).off,
+    onDblClick: (h) => b.on(h).off,
+    onContextMenu: (h) => P.on(h).off,
+    onPointerMove: (h) => m.on(h).off,
+    onPointerUp: (h) => d.on(h).off,
+    onPointerDown: (h) => C.on(h).off,
+    onPointerMissed: (h) => E.on(h).off,
+    onWheel: (h) => S.on(h).off,
+    forceUpdate: p
   };
 };
-function Vr() {
-  const { logWarning: e } = A();
-  function r(i, n, a) {
-    let l = null;
-    return i.traverse((c) => {
-      c[n] === a && (l = c);
-    }), l || e(`Child with ${n} '${a}' not found.`), l;
+function Gr() {
+  const { logWarning: e } = Y();
+  function t(a, i, l) {
+    let c = null;
+    return a.traverse((o) => {
+      o[i] === l && (c = o);
+    }), c || e(`Child with ${i} '${l}' not found.`), c;
   }
-  function t(i, n, a) {
-    const l = [];
-    return i.traverse((c) => {
-      c[n].includes(a) && l.push(c);
-    }), l.length || e(`Children with ${n} '${a}' not found.`), l;
+  function n(a, i, l) {
+    const c = [];
+    return a.traverse((o) => {
+      o[i].includes(l) && c.push(o);
+    }), c.length || e(`Children with ${i} '${l}' not found.`), c;
   }
-  function o(i, n) {
-    return r(i, "name", n);
+  function r(a, i) {
+    return t(a, "name", i);
   }
-  function s(i, n) {
-    return t(i, "name", n);
+  function s(a, i) {
+    return n(a, "name", i);
   }
   return {
-    seek: r,
-    seekByName: o,
-    seekAll: t,
+    seek: t,
+    seekByName: r,
+    seekAll: n,
     seekAllByName: s
   };
 }
-const ar = ({ scene: e, contextParts: r }) => {
-  const t = ve({
-    click: /* @__PURE__ */ new Map(),
-    pointerMove: /* @__PURE__ */ new Map(),
-    pointerEnter: /* @__PURE__ */ new Map(),
-    pointerLeave: /* @__PURE__ */ new Map()
-  }), o = R(/* @__PURE__ */ new Set()), s = (u) => {
-    o.value.add(u);
-  }, i = (u) => {
-    o.value.delete(u);
-  }, n = (u) => {
-    Object.values(t).forEach((f) => f.delete(u)), i(u);
-  }, a = (u) => {
-    const { onClick: f, onPointerMove: h, onPointerEnter: p, onPointerLeave: y } = u;
-    f && t.click.set(u, f), h && t.pointerMove.set(u, h), p && t.pointerEnter.set(u, p), y && t.pointerLeave.set(u, y);
-  };
-  e.userData.tres__registerAtPointerEventHandler = a, e.userData.tres__deregisterAtPointerEventHandler = n, e.userData.tres__registerBlockingObjectAtPointerEventHandler = s, e.userData.tres__deregisterBlockingObjectAtPointerEventHandler = i;
-  const l = T(
-    () => qt(
-      [
-        ...Array.from(o.value),
-        ...Object.values(t).map((u) => Array.from(u.keys())).flat()
-      ],
-      ({ uuid: u }) => u
-    )
-  ), { onClick: c, onPointerMove: m } = ir(l, r);
-  c(({ intersects: u, event: f }) => {
-    var h;
-    u.length && ((h = t.click.get(u[0].object)) == null || h(u[0], f));
-  });
-  let d;
-  return m(({ intersects: u, event: f }) => {
-    var x, C, M, w;
-    const h = (x = u == null ? void 0 : u[0]) == null ? void 0 : x.object, { pointerLeave: p, pointerEnter: y, pointerMove: b } = t;
-    d && d !== h && ((C = p.get(d)) == null || C(d, f)), h && (d !== h && ((M = y.get(h)) == null || M(u[0], f)), (w = b.get(h)) == null || w(u[0], f)), d = h || null;
-  }), {
-    registerObject: a,
-    deregisterObject: n
-  };
-};
-function Se(e) {
-  let r = 0;
-  return e.traverse((t) => {
-    if (t.isMesh && t.geometry) {
-      const o = t.geometry, s = o.attributes.position.count * 3 * Float32Array.BYTES_PER_ELEMENT, i = o.index ? o.index.count * Uint32Array.BYTES_PER_ELEMENT : 0, n = o.attributes.normal ? o.attributes.normal.count * 3 * Float32Array.BYTES_PER_ELEMENT : 0, a = o.attributes.uv ? o.attributes.uv.count * 2 * Float32Array.BYTES_PER_ELEMENT : 0, l = s + i + n + a;
-      r += l;
+function ke(e) {
+  let t = 0;
+  return e.traverse((n) => {
+    if (n.isMesh && n.geometry && n.type !== "HightlightMesh") {
+      const r = n.geometry, s = r.attributes.position.count * 3 * Float32Array.BYTES_PER_ELEMENT, a = r.index ? r.index.count * Uint32Array.BYTES_PER_ELEMENT : 0, i = r.attributes.normal ? r.attributes.normal.count * 3 * Float32Array.BYTES_PER_ELEMENT : 0, l = r.attributes.uv ? r.attributes.uv.count * 2 * Float32Array.BYTES_PER_ELEMENT : 0, c = s + a + i + l;
+      t += c;
     }
-  }), r;
+  }), t;
 }
-function lr(e) {
+function ur(e) {
   return (e / 1024).toFixed(2);
 }
-const Z = R({}), oe = (e) => Object.assign(Z.value, e);
-function ur(e, r, t = 10) {
-  const o = _(e) ? ht() : yt(T(() => _(r).parentElement)), s = q(ue(o.width, t)), i = q(ue(o.height, t)), n = T(() => s.value / i.value);
+const Me = H({}), Ce = (e) => Object.assign(Me.value, e);
+function fr(e, t, n) {
+  var x;
+  const r = $(), s = $();
+  e && (r.value = e), t && (s.value = t);
+  const a = (p) => {
+    var w;
+    return ((w = p.__tres) == null ? void 0 : w.eventCount) > 0;
+  }, i = (p) => {
+    var w;
+    return ((w = p.children) == null ? void 0 : w.some((A) => i(A))) || a(p);
+  }, l = $(((x = r.value) == null ? void 0 : x.children).filter(i) || []);
+  function c(p, w) {
+    if (Array.isArray(p))
+      for (const A of p)
+        A(w);
+    typeof p == "function" && p(w);
+  }
+  function o(p, w) {
+    const A = [], D = () => w.stopPropagating = !0;
+    w.stopPropagation = D;
+    for (const O of w == null ? void 0 : w.intersections) {
+      if (w.stopPropagating)
+        return;
+      w = { ...w, ...O };
+      const { object: B } = O;
+      w.eventObject = B, c(B[p], w), A.push(B);
+      let R = B.parent;
+      for (; R !== null && !w.stopPropagating && !A.includes(R); )
+        w.eventObject = R, c(R[p], w), A.push(R), R = R.parent;
+      const ne = Gn(p.slice(2));
+      n(ne, { intersection: O, event: w });
+    }
+  }
+  const {
+    onClick: u,
+    onDblClick: y,
+    onContextMenu: f,
+    onPointerMove: g,
+    onPointerDown: v,
+    onPointerUp: b,
+    onPointerMissed: m,
+    onWheel: d,
+    forceUpdate: C
+  } = cr(l, t);
+  b((p) => o("onPointerUp", p)), v((p) => o("onPointerDown", p)), u((p) => o("onClick", p)), y((p) => o("onDoubleClick", p)), f((p) => o("onContextMenu", p)), d((p) => o("onWheel", p));
+  let E = [];
+  g((p) => {
+    const w = p.intersections.map(({ object: D }) => D), A = p.intersections;
+    E.forEach(({ object: D }) => {
+      w.includes(D) || (p.intersections = E, o("onPointerLeave", p), o("onPointerOut", p));
+    }), p.intersections = A, p.intersections.forEach(({ object: D }) => {
+      E.includes(D) || (o("onPointerEnter", p), o("onPointerOver", p));
+    }), o("onPointerMove", p), E = p.intersections;
+  });
+  const P = [];
+  m((p) => {
+    const w = () => p.stopPropagating = !0;
+    p.stopPropagation = w, P.forEach((A) => {
+      p.stopPropagating || (p.eventObject = A, c(A.onPointerMissed, p));
+    }), n("pointer-missed", { event: p });
+  });
+  function S(p) {
+    oe(p) && N(p) && l.value.push(p);
+  }
+  function M(p) {
+    if (oe(p) && N(p)) {
+      const w = l.value.indexOf(p);
+      w > -1 && l.value.splice(w, 1);
+    }
+  }
+  function _(p) {
+    oe(p) && N(p) && p.onPointerMissed && P.push(p);
+  }
+  function L(p) {
+    if (oe(p) && N(p)) {
+      const w = P.indexOf(p);
+      w > -1 && P.splice(w, 1);
+    }
+  }
+  return t.eventManager = {
+    forceUpdate: C,
+    registerObject: S,
+    deregisterObject: M,
+    registerPointerMissedObject: _,
+    deregisterPointerMissedObject: L
+  }, {
+    forceUpdate: C,
+    registerObject: S,
+    deregisterObject: M,
+    registerPointerMissedObject: _,
+    deregisterPointerMissedObject: L
+  };
+}
+function dr(e, t, n = 10) {
+  const r = k(e) ? rn() : on(V(() => k(t).parentElement)), s = ye(Fe(r.width, n)), a = ye(Fe(r.height, n)), i = V(() => s.value / a.value);
   return {
-    height: i,
+    height: a,
     width: s,
-    aspectRatio: n
+    aspectRatio: i
+  };
+}
+function ve() {
+  const e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Set();
+  let n = 0, r = !1;
+  const s = () => {
+    const o = Array.from(e.entries()).sort((u, y) => {
+      const f = u[1].priority - y[1].priority;
+      return f === 0 ? u[1].addI - y[1].addI : f;
+    });
+    t.clear(), o.forEach((u) => t.add(u[0]));
+  }, a = (o) => {
+    e.delete(o), t.delete(o);
+  };
+  return { on: (o, u = 0) => {
+    e.set(o, { priority: u, addI: n++ });
+    const y = () => a(o);
+    return sn(y), r = !0, {
+      off: y
+    };
+  }, off: a, trigger: (...o) => {
+    r && (s(), r = !1), t.forEach((u) => u(...o));
+  }, dispose: () => {
+    e.clear(), t.clear();
+  }, get count() {
+    return e.size;
+  } };
+}
+function pr() {
+  let e = !0, t = !0, n = !1;
+  const r = new tt(!1), s = H(r.running), a = H(!1);
+  let i;
+  const l = rt.generateUUID();
+  let c = null;
+  const o = ve(), u = ve(), y = ve();
+  M();
+  let f = {};
+  function g(_) {
+    f = _;
+  }
+  function v(_, L, x = 0) {
+    switch (L) {
+      case "before":
+        return o.on(_, x);
+      case "render":
+        return c || (c = _), u.dispose(), u.on(_);
+      case "after":
+        return y.on(_, x);
+    }
+  }
+  function b() {
+    t && (t = !1, M(), S());
+  }
+  function m() {
+    t = !0, M(), cancelAnimationFrame(i);
+  }
+  function d() {
+    n = !1, M();
+  }
+  function C() {
+    n = !0, M();
+  }
+  function E() {
+    a.value = !0;
+  }
+  function P() {
+    a.value = !1;
+  }
+  function S() {
+    if (!e) {
+      i = requestAnimationFrame(S);
+      return;
+    }
+    const _ = r.getDelta(), L = r.getElapsedTime(), x = {
+      camera: J(f.camera),
+      scene: J(f.scene),
+      renderer: J(f.renderer),
+      raycaster: J(f.raycaster),
+      controls: J(f.controls),
+      invalidate: f.invalidate,
+      advance: f.advance
+    }, p = { delta: _, elapsed: L, clock: r, ...x };
+    s.value && o.trigger(p), a.value || (u.count ? u.trigger(p) : c && c(p)), s.value && y.trigger(p), i = requestAnimationFrame(S);
+  }
+  function M() {
+    const _ = !t && !n;
+    r.running !== _ && (r.running ? r.stop() : r.start()), s.value = r.running;
+  }
+  return {
+    loopId: l,
+    register: (_, L, x) => v(_, L, x),
+    start: b,
+    stop: m,
+    pause: C,
+    resume: d,
+    pauseRender: E,
+    resumeRender: P,
+    isRenderPaused: a,
+    isActive: s,
+    setContext: g,
+    setReady: (_) => e = _
   };
 }
-function cr({
+function mr(e, t, n = 100) {
+  n = n <= 0 ? 100 : n;
+  const r = j(), s = /* @__PURE__ */ new Set();
+  let a = !1, i = !1, l = null;
+  function c() {
+    l && clearTimeout(l), !i && !a && e() ? (r.trigger(t), s.forEach((f) => f()), s.clear(), a = !0) : !i && !a && (l = setTimeout(c, n));
+  }
+  function o() {
+    i = !0, l && clearTimeout(l);
+  }
+  c();
+  const u = (f, ...g) => {
+    f(...g);
+  };
+  return {
+    on: (f) => {
+      if (a)
+        return u(f, t), { off: () => {
+        } };
+      {
+        const g = r.on(f);
+        return s.add(g.off), r.on(f);
+      }
+    },
+    off: r.off,
+    trigger: r.trigger,
+    cancel: o
+  };
+}
+const te = /* @__PURE__ */ new WeakMap();
+function gt(e) {
+  if (e = e || pe(), te.has(e))
+    return te.get(e);
+  const t = 100, n = Date.now(), a = mr(() => {
+    if (Date.now() - n >= t)
+      return !0;
+    {
+      const i = e.renderer.value, l = (i == null ? void 0 : i.domElement) || { width: 0, height: 0 };
+      return !!(i && l.width > 0 && l.height > 0);
+    }
+  }, e);
+  return te.set(e, a), a;
+}
+function Vr(e) {
+  const t = pe();
+  if (t)
+    return te.has(t) ? te.get(t).on(e) : gt(t).on(e);
+}
+function hr({
   scene: e,
-  canvas: r,
-  windowSize: t,
-  disableRender: o,
-  rendererOptions: s
+  canvas: t,
+  windowSize: n,
+  disableRender: r,
+  rendererOptions: s,
+  emit: a
 }) {
-  const i = ur(t, r), n = j(e), {
-    camera: a,
-    cameras: l,
-    registerCamera: c,
-    deregisterCamera: m,
-    setCameraActive: d
-  } = Vt({ sizes: i, scene: e }), { renderer: u } = or(
+  const i = $(e), l = dr(n, t), {
+    camera: c,
+    cameras: o,
+    registerCamera: u,
+    deregisterCamera: y,
+    setCameraActive: f
+  } = Bn({ sizes: l, scene: e }), g = {
+    mode: H(s.renderMode || "always"),
+    priority: H(0),
+    frames: H(0),
+    maxFrames: 60,
+    canBeInvalidated: V(() => g.mode.value === "on-demand" && g.frames.value === 0)
+  };
+  function v(O = 1) {
+    s.renderMode === "on-demand" && (g.frames.value = Math.min(g.maxFrames, g.frames.value + O));
+  }
+  function b() {
+    s.renderMode === "manual" && (g.frames.value = 1);
+  }
+  const { renderer: m } = ir(
     {
       scene: e,
-      canvas: r,
+      canvas: t,
       options: s,
-      contextParts: { sizes: i, camera: a },
-      disableRender: o
+      emit: a,
+      // TODO: replace contextParts with full ctx at https://github.com/Tresjs/tres/issues/516
+      contextParts: { sizes: l, camera: c, render: g, invalidate: v, advance: b },
+      disableRender: r
     }
-  ), f = {
-    sizes: i,
-    scene: n,
-    camera: a,
-    cameras: q(l),
-    renderer: u,
-    raycaster: j(new tt()),
-    controls: R(null),
+  ), d = {
+    sizes: l,
+    scene: i,
+    camera: c,
+    cameras: ye(o),
+    renderer: m,
+    raycaster: $(new Ft()),
+    controls: H(null),
     perf: {
       maxFrames: 160,
       fps: {
@@ -614,432 +1057,482 @@ function cr({
         accumulator: []
       }
     },
-    extend: oe,
-    registerCamera: c,
-    setCameraActive: d,
-    deregisterCamera: m
+    render: g,
+    advance: b,
+    extend: Ce,
+    invalidate: v,
+    registerCamera: u,
+    setCameraActive: f,
+    deregisterCamera: y,
+    loop: pr()
   };
-  K("useTres", f);
-  const h = 100, p = wt({ every: h }), { isSupported: y, memory: b } = bt({ interval: h }), x = 160;
-  let C = performance.now();
-  const M = ({ timestamp: I }) => {
-    f.scene.value && (f.perf.memory.allocatedMem = Se(f.scene.value)), I - C >= h && (C = I, f.perf.fps.accumulator.push(p.value), f.perf.fps.accumulator.length > x && f.perf.fps.accumulator.shift(), f.perf.fps.value = p.value, y.value && b.value && (f.perf.memory.accumulator.push(b.value.usedJSHeapSize / 1024 / 1024), f.perf.memory.accumulator.length > x && f.perf.memory.accumulator.shift(), f.perf.memory.currentMem = f.perf.memory.accumulator.reduce((Le, Oe) => Le + Oe, 0) / f.perf.memory.accumulator.length));
+  _e("useTres", d), d.scene.value.__tres = {
+    root: d
+  }, d.loop.register(() => {
+    c.value && g.frames.value > 0 && (m.value.render(e, c.value), a("render", d.renderer.value)), g.priority.value = 0, g.mode.value === "always" ? g.frames.value = 1 : g.frames.value = Math.max(0, g.frames.value - 1);
+  }, "render");
+  const { on: C, cancel: E } = gt(d);
+  d.loop.setReady(!1), d.loop.start(), C(() => {
+    a("ready", d), d.loop.setReady(!0), fr(e, d, a);
+  }), K(() => {
+    E(), d.loop.stop();
+  });
+  const P = 100, S = an({ every: P }), { isSupported: M, memory: _ } = ln({ interval: P }), L = 160;
+  let x = performance.now();
+  const p = ({ timestamp: O }) => {
+    d.scene.value && (d.perf.memory.allocatedMem = ke(d.scene.value)), O - x >= P && (x = O, d.perf.fps.accumulator.push(S.value), d.perf.fps.accumulator.length > L && d.perf.fps.accumulator.shift(), d.perf.fps.value = S.value, M.value && _.value && (d.perf.memory.accumulator.push(_.value.usedJSHeapSize / 1024 / 1024), d.perf.memory.accumulator.length > L && d.perf.memory.accumulator.shift(), d.perf.memory.currentMem = d.perf.memory.accumulator.reduce((B, R) => B + R, 0) / d.perf.memory.accumulator.length));
   };
   let w = 0;
-  const S = 1, { pause: v, resume: E } = be(({ delta: I }) => {
-    window.__TRES__DEVTOOLS__ && (M({ timestamp: performance.now() }), w += I, w >= S && (window.__TRES__DEVTOOLS__.cb(f), w = 0));
+  const A = 1, { pause: D } = it(({ delta: O }) => {
+    window.__TRES__DEVTOOLS__ && (p({ timestamp: performance.now() }), w += O, w >= A && (window.__TRES__DEVTOOLS__.cb(d), w = 0));
   }, { immediate: !0 });
-  return G(() => {
-    v();
-  }), f;
+  return K(() => {
+    D();
+  }), d;
 }
-function dr() {
-  const e = je("useTres");
+function pe() {
+  const e = Mt("useTres");
   if (!e)
     throw new Error("useTresContext must be used together with useTresContextProvider");
   return e;
 }
-const zr = dr;
-let g = null;
-const { logError: pe } = A(), Y = [
+const Yr = pe;
+function qr() {
+  const {
+    camera: e,
+    scene: t,
+    renderer: n,
+    loop: r,
+    raycaster: s,
+    controls: a,
+    invalidate: i,
+    advance: l
+  } = pe();
+  r.setContext({
+    camera: e,
+    scene: t,
+    renderer: n,
+    raycaster: s,
+    controls: a,
+    invalidate: i,
+    advance: l
+  });
+  function c(y, f = 0) {
+    return r.register(y, "before", f);
+  }
+  function o(y) {
+    return r.register(y, "render");
+  }
+  function u(y, f = 0) {
+    return r.register(y, "after", f);
+  }
+  return {
+    pause: r.pause,
+    resume: r.resume,
+    pauseRender: r.pauseRender,
+    resumeRender: r.resumeRender,
+    isActive: r.isActive,
+    onBeforeRender: c,
+    render: o,
+    onAfterRender: u
+  };
+}
+function gr(e, t = {}, n = {}) {
+  let r = e;
+  const s = (l) => {
+    r = l;
+  };
+  let a = new Proxy({}, {});
+  const i = {
+    has(l, c) {
+      return c in t || c in r;
+    },
+    get(l, c, o) {
+      return c in t ? t[c](r) : r[c];
+    },
+    set(l, c, o) {
+      return n[c] ? n[c](o, r, a, s) : r[c] = o, !0;
+    }
+  };
+  return a = new Proxy({}, i), a;
+}
+const { logError: Ke } = Y(), Qe = [
   "onClick",
+  "onContextMenu",
   "onPointerMove",
   "onPointerEnter",
-  "onPointerLeave"
-], fr = {
-  createElement(e, r, t, o) {
-    var n, a;
-    if (o || (o = {}), o.args || (o.args = []), e === "template" || Qt(e))
+  "onPointerLeave",
+  "onPointerOver",
+  "onPointerOut",
+  "onDoubleClick",
+  "onPointerDown",
+  "onPointerUp",
+  "onPointerCancel",
+  "onPointerMissed",
+  "onLostPointerCapture",
+  "onWheel"
+], vr = (e) => {
+  const t = e.scene.value;
+  function n(o, u, y, f) {
+    if (f || (f = {}), f.args || (f.args = []), o === "template" || Nn(o))
       return null;
-    let s = e.replace("Tres", ""), i;
-    if (e === "primitive") {
-      (o == null ? void 0 : o.object) === void 0 && pe("Tres primitives need a prop 'object'");
-      const l = o.object;
-      s = l.type, i = Object.assign(l, { type: s, attach: o.attach, primitive: !0 });
+    let g = o.replace("Tres", ""), v;
+    if (o === "primitive") {
+      (!U(f.object) || Ct(f.object)) && Ke(
+        "Tres primitives need an 'object' prop, whose value is an object or shallowRef<object>"
+      ), g = f.object.type;
+      const b = {};
+      v = gr(
+        f.object,
+        {
+          object: (d) => d,
+          isPrimitive: () => !0,
+          __tres: () => b
+        },
+        {
+          object: (d, C, E, P) => {
+            or(d, E, P, { patchProp: a, remove: s, insert: r }, e);
+          },
+          __tres: (d) => {
+            Object.assign(b, d);
+          }
+        }
+      );
     } else {
-      const l = Z.value[s];
-      l || pe(`${s} is not defined on the THREE namespace. Use extend to add it to the catalog.`), i = new l(...o.args);
+      const b = Me.value[g];
+      b || Ke(
+        `${g} is not defined on the THREE namespace. Use extend to add it to the catalog.`
+      ), v = new b(...f.args);
     }
-    return i.isCamera && (o != null && o.position || i.position.set(3, 3, 3), o != null && o.lookAt || i.lookAt(0, 0, 0)), (o == null ? void 0 : o.attach) === void 0 && (i.isMaterial ? i.attach = "material" : i.isBufferGeometry && (i.attach = "geometry")), i.isObject3D && ((n = o == null ? void 0 : o.material) != null && n.isMaterial && (i.userData.tres__materialViaProp = !0), (a = o == null ? void 0 : o.geometry) != null && a.isBufferGeometry && (i.userData.tres__geometryViaProp = !0)), i.userData = {
-      ...i.userData,
-      tres__name: s
-    }, i;
-  },
-  insert(e, r) {
-    var o, s, i, n;
-    r && r.isScene && (g = r);
-    const t = r || g;
-    if (e != null && e.isObject3D) {
-      if (e != null && e.isCamera) {
-        if (!(g != null && g.userData.tres__registerCamera))
-          throw "could not find tres__registerCamera on scene's userData";
-        (s = g == null ? void 0 : (o = g.userData).tres__registerCamera) == null || s.call(o, e);
-      }
-      if (e && Y.some((a) => e[a])) {
-        if (!(g != null && g.userData.tres__registerAtPointerEventHandler))
-          throw "could not find tres__registerAtPointerEventHandler on scene's userData";
-        (n = g == null ? void 0 : (i = g.userData).tres__registerAtPointerEventHandler) == null || n.call(i, e);
-      }
+    return v ? (v.isCamera && (f != null && f.position || v.position.set(3, 3, 3), f != null && f.lookAt || v.lookAt(0, 0, 0)), v = z(v, {
+      ...v.__tres,
+      type: g,
+      memoizedProps: f,
+      eventCount: 0,
+      primitive: o === "primitive",
+      attach: f.attach
+    }, e), v) : null;
+  }
+  function r(o, u) {
+    var g, v, b;
+    if (!o)
+      return;
+    u = u || t;
+    const y = o.__tres ? o : z(o, {}, e), f = u.__tres ? u : z(u, {}, e);
+    o = Q(y), u = Q(f), o.__tres && ((g = o.__tres) == null ? void 0 : g.eventCount) > 0 && ((v = e.eventManager) == null || v.registerObject(o)), e.registerCamera(o), (b = e.eventManager) == null || b.registerPointerMissedObject(o), y.__tres.attach ? tr(f, y, y.__tres.attach) : N(o) && N(f) && (f.add(o), o.dispatchEvent({ type: "added" })), y.__tres.parent = f, f.__tres.objects && !f.__tres.objects.includes(y) && f.__tres.objects.push(y);
+  }
+  function s(o, u) {
+    var v, b, m, d;
+    if (!o)
+      return;
+    o != null && o.__tres && ((v = o.__tres) == null ? void 0 : v.eventCount) > 0 && ((b = e.eventManager) == null || b.deregisterObject(o)), u = be(u) ? "default" : u;
+    const y = (m = o.__tres) == null ? void 0 : m.dispose;
+    be(y) || (y === null ? u = !1 : u = y);
+    const f = (d = o.__tres) == null ? void 0 : d.primitive, g = u === "default" ? !f : !!u;
+    if (o.__tres && "objects" in o.__tres && [...o.__tres.objects].forEach((C) => s(C, u)), g && o.children && [...o.children].forEach((C) => s(C, u)), mt(o, e), ht(o, e), g && !Dn(o)) {
+      if (G(u))
+        u(o);
+      else if (G(o.dispose))
+        try {
+          o.dispose();
+        } catch {
+        }
     }
-    e != null && e.isObject3D && (t != null && t.isObject3D) ? (t.add(e), e.dispatchEvent({ type: "added" })) : e != null && e.isFog ? t.fog = e : typeof (e == null ? void 0 : e.attach) == "string" && (e.__previousAttach = e[t == null ? void 0 : t.attach], t && (t[e.attach] = e));
-  },
-  remove(e) {
-    var r, t;
-    if (e) {
-      if (e.isObject3D) {
-        const o = e, s = (c) => {
-          var d, u;
-          const m = c;
-          c.userData.tres__materialViaProp || ((d = m.material) == null || d.dispose(), m.material = void 0), c.userData.tres__geometryViaProp || ((u = m.geometry) == null || u.dispose(), m.geometry = void 0);
-        }, i = g == null ? void 0 : g.userData.tres__deregisterAtPointerEventHandler, n = g == null ? void 0 : g.userData.tres__deregisterBlockingObjectAtPointerEventHandler, a = (c) => {
-          var m, d;
-          if (!n)
-            throw "could not find tres__deregisterBlockingObjectAtPointerEventHandler on scene's userData";
-          if ((d = g == null ? void 0 : (m = g.userData).tres__deregisterBlockingObjectAtPointerEventHandler) == null || d.call(m, c), !i)
-            throw "could not find tres__deregisterAtPointerEventHandler on scene's userData";
-          c && Y.some((u) => c[u]) && (i == null || i(c));
-        }, l = (c) => {
-          const m = g == null ? void 0 : g.userData.tres__deregisterCamera;
-          if (!m)
-            throw "could not find tres__deregisterCamera on scene's userData";
-          c.isCamera && (m == null || m(c));
-        };
-        (r = e.removeFromParent) == null || r.call(e), o.traverse((c) => {
-          s(c), l(c), a == null || a(c);
-        }), s(o), l(o), a == null || a(o);
-      }
-      (t = e.dispose) == null || t.call(e);
+    "__tres" in o && delete o.__tres;
+  }
+  function a(o, u, y, f) {
+    var C, E;
+    if (!o)
+      return;
+    let g = o, v = u;
+    if (o.__tres && (o.__tres.memoizedProps[u] = f), u === "attach") {
+      const P = ((C = o.__tres) == null ? void 0 : C.parent) || o.parent;
+      s(o), z(o, { attach: f }, e), P && r(o, P);
+      return;
     }
-  },
-  patchProp(e, r, t, o) {
-    var s, i, n, a;
-    if (e) {
-      let l = e, c = r;
-      if (e.isObject3D && c === "blocks-pointer-events") {
-        o || o === "" ? (i = g == null ? void 0 : (s = g.userData).tres__registerBlockingObjectAtPointerEventHandler) == null || i.call(s, e) : (a = g == null ? void 0 : (n = g.userData).tres__deregisterBlockingObjectAtPointerEventHandler) == null || a.call(n, e);
-        return;
-      }
-      let m = N(c), d = l == null ? void 0 : l[m];
-      if (c === "args") {
-        const f = e, h = t ?? [], p = o ?? [], y = e.userData.tres__name || e.type;
-        y && h.length && !Xt(h, p) && (l = Object.assign(f, new Z.value[y](...o)));
-        return;
-      }
-      if (l.type === "BufferGeometry") {
-        if (c === "args")
-          return;
-        l.setAttribute(
-          N(c),
-          new rt(...o)
-        );
-        return;
-      }
-      if (c.includes("-") && d === void 0) {
-        const f = c.split("-");
-        d = f.reduce((h, p) => h[N(p)], l), c = f.pop(), m = c.toLowerCase(), d != null && d.set || (l = f.reduce((h, p) => h[N(p)], l));
-      }
-      let u = o;
-      if (u === "" && (u = !0), fe(d)) {
-        Y.includes(r) || (Array.isArray(u) ? e[m](...u) : e[m](u));
+    if (u === "dispose") {
+      o.__tres || (o = z(o, {}, e)), o.__tres.dispose = f;
+      return;
+    }
+    if (N(o) && v === "blocks-pointer-events") {
+      f || f === "" ? o[v] = f : delete o[v];
+      return;
+    }
+    Qe.includes(u) && o.__tres && (o.__tres.eventCount += 1);
+    let b = ie(v), m = g == null ? void 0 : g[b];
+    if (v === "args") {
+      const P = o, S = y ?? [], M = f ?? [], _ = ((E = o.__tres) == null ? void 0 : E.type) || o.type;
+      _ && S.length && !qn(S, M) && (g = Object.assign(
+        P,
+        new Me.value[_](...f)
+      ));
+      return;
+    }
+    if (g.type === "BufferGeometry") {
+      if (v === "args")
         return;
-      }
-      !(d != null && d.set) && !fe(d) ? l[m] = u : d.constructor === u.constructor && (d != null && d.copy) ? d == null || d.copy(u) : Array.isArray(u) ? d.set(...u) : !d.isColor && d.setScalar ? d.setScalar(u) : d.set(u);
+      g.setAttribute(
+        ie(v),
+        new Wt(...f)
+      );
+      return;
     }
-  },
-  parentNode(e) {
-    return (e == null ? void 0 : e.parent) || null;
-  },
-  createText: () => void 0,
-  createComment: () => void 0,
-  setText: () => void 0,
-  setElementText: () => void 0,
-  nextSibling: () => void 0,
-  querySelector: () => void 0,
-  setScopeId: () => void 0,
-  cloneNode: () => void 0,
-  insertStaticContent: () => void 0
-}, { render: pr } = He(fr);
-oe(he);
-function mr() {
-  return Pe().__VUE_DEVTOOLS_GLOBAL_HOOK__;
-}
-function Pe() {
+    if (v.includes("-") && m === void 0) {
+      const P = v.split("-");
+      m = P.reduce((S, M) => S[ie(M)], g), v = P.pop(), b = v, m != null && m.set || (g = P.reduce((S, M) => S[ie(M)], g));
+    }
+    let d = f;
+    if (d === "" && (d = !0), G(m)) {
+      Qe.includes(u) || (de(d) ? o[b](...d) : o[b](d)), b.startsWith("on") && G(d) && (g[b] = d);
+      return;
+    }
+    !(m != null && m.set) && !G(m) ? g[b] = d : m.constructor === d.constructor && (m != null && m.copy) ? m == null || m.copy(d) : de(d) ? m.set(...d) : !m.isColor && m.setScalar ? m.setScalar(d) : m.set(d), pt(o);
+  }
+  function i(o) {
+    var u;
+    return ((u = o == null ? void 0 : o.__tres) == null ? void 0 : u.parent) || null;
+  }
+  function l (o) {
+    return null;
+    const u = z(new Nt(), { type: "Comment" }, e);
+    return u.name = o, u;
+  }
+  function c(o) {
+    var g;
+    const u = i(o), y = ((g = u == null ? void 0 : u.__tres) == null ? void 0 : g.objects) || [], f = y.indexOf(o);
+    return f < 0 || f >= y.length - 1 ? null : y[f + 1];
+  }
+  return {
+    insert: r,
+    remove: s,
+    createElement: n,
+    patchProp: a,
+    parentNode: i,
+    createText: () => void 0,
+    createComment: l,
+    setText: () => void 0,
+    setElementText: () => void 0,
+    nextSibling: c,
+    querySelector: () => void 0,
+    setScopeId: () => void 0,
+    cloneNode: () => void 0,
+    insertStaticContent: () => void 0
+  };
+};
+function yr() {
+  return vt().__VUE_DEVTOOLS_GLOBAL_HOOK__;
+}
+function vt() {
   return typeof navigator < "u" && typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : {};
 }
-const gr = typeof Proxy == "function", vr = "devtools-plugin:setup", hr = "plugin:settings:set";
-let L, ee;
-function yr() {
+const _r = typeof Proxy == "function", wr = "devtools-plugin:setup", br = "plugin:settings:set";
+let q, Ee;
+function Pr() {
   var e;
-  return L !== void 0 || (typeof window < "u" && window.performance ? (L = !0, ee = window.performance) : typeof globalThis < "u" && (!((e = globalThis.perf_hooks) === null || e === void 0) && e.performance) ? (L = !0, ee = globalThis.perf_hooks.performance) : L = !1), L;
-}
-function wr() {
-  return yr() ? ee.now() : Date.now();
-}
-class br {
-  constructor(r, t) {
-    this.target = null, this.targetQueue = [], this.onQueue = [], this.plugin = r, this.hook = t;
-    const o = {};
-    if (r.settings)
-      for (const n in r.settings) {
-        const a = r.settings[n];
-        o[n] = a.defaultValue;
+  return q !== void 0 || (typeof window < "u" && window.performance ? (q = !0, Ee = window.performance) : typeof globalThis < "u" && (!((e = globalThis.perf_hooks) === null || e === void 0) && e.performance) ? (q = !0, Ee = globalThis.perf_hooks.performance) : q = !1), q;
+}
+function Mr() {
+  return Pr() ? Ee.now() : Date.now();
+}
+class Cr {
+  constructor(t, n) {
+    this.target = null, this.targetQueue = [], this.onQueue = [], this.plugin = t, this.hook = n;
+    const r = {};
+    if (t.settings)
+      for (const i in t.settings) {
+        const l = t.settings[i];
+        r[i] = l.defaultValue;
       }
-    const s = `__vue-devtools-plugin-settings__${r.id}`;
-    let i = Object.assign({}, o);
+    const s = `__vue-devtools-plugin-settings__${t.id}`;
+    let a = Object.assign({}, r);
     try {
-      const n = localStorage.getItem(s), a = JSON.parse(n);
-      Object.assign(i, a);
+      const i = localStorage.getItem(s), l = JSON.parse(i);
+      Object.assign(a, l);
     } catch {
     }
     this.fallbacks = {
       getSettings() {
-        return i;
+        return a;
       },
-      setSettings(n) {
+      setSettings(i) {
         try {
-          localStorage.setItem(s, JSON.stringify(n));
+          localStorage.setItem(s, JSON.stringify(i));
         } catch {
         }
-        i = n;
+        a = i;
       },
       now() {
-        return wr();
+        return Mr();
       }
-    }, t && t.on(hr, (n, a) => {
-      n === this.plugin.id && this.fallbacks.setSettings(a);
+    }, n && n.on(br, (i, l) => {
+      i === this.plugin.id && this.fallbacks.setSettings(l);
     }), this.proxiedOn = new Proxy({}, {
-      get: (n, a) => this.target ? this.target.on[a] : (...l) => {
+      get: (i, l) => this.target ? this.target.on[l] : (...c) => {
         this.onQueue.push({
-          method: a,
-          args: l
+          method: l,
+          args: c
         });
       }
     }), this.proxiedTarget = new Proxy({}, {
-      get: (n, a) => this.target ? this.target[a] : a === "on" ? this.proxiedOn : Object.keys(this.fallbacks).includes(a) ? (...l) => (this.targetQueue.push({
-        method: a,
-        args: l,
+      get: (i, l) => this.target ? this.target[l] : l === "on" ? this.proxiedOn : Object.keys(this.fallbacks).includes(l) ? (...c) => (this.targetQueue.push({
+        method: l,
+        args: c,
         resolve: () => {
         }
-      }), this.fallbacks[a](...l)) : (...l) => new Promise((c) => {
+      }), this.fallbacks[l](...c)) : (...c) => new Promise((o) => {
         this.targetQueue.push({
-          method: a,
-          args: l,
-          resolve: c
+          method: l,
+          args: c,
+          resolve: o
         });
       })
     });
   }
-  async setRealTarget(r) {
-    this.target = r;
-    for (const t of this.onQueue)
-      this.target.on[t.method](...t.args);
-    for (const t of this.targetQueue)
-      t.resolve(await this.target[t.method](...t.args));
+  async setRealTarget(t) {
+    this.target = t;
+    for (const n of this.onQueue)
+      this.target.on[n.method](...n.args);
+    for (const n of this.targetQueue)
+      n.resolve(await this.target[n.method](...n.args));
   }
 }
-function _r(e, r) {
-  const t = e, o = Pe(), s = mr(), i = gr && t.enableEarlyProxy;
-  if (s && (o.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !i))
-    s.emit(vr, e, r);
+function Er(e, t) {
+  const n = e, r = vt(), s = yr(), a = _r && n.enableEarlyProxy;
+  if (s && (r.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !a))
+    s.emit(wr, e, t);
   else {
-    const n = i ? new br(t, s) : null;
-    (o.__VUE_DEVTOOLS_PLUGINS__ = o.__VUE_DEVTOOLS_PLUGINS__ || []).push({
-      pluginDescriptor: t,
-      setupFn: r,
-      proxy: n
-    }), n && r(n.proxiedTarget);
+    const i = a ? new Cr(n, s) : null;
+    (r.__VUE_DEVTOOLS_PLUGINS__ = r.__VUE_DEVTOOLS_PLUGINS__ || []).push({
+      pluginDescriptor: n,
+      setupFn: t,
+      proxy: i
+    }), i && t(i.proxiedTarget);
   }
 }
-function Er(e, r) {
-  const t = `▲ ■ ●${e}`;
-  typeof __VUE_DEVTOOLS_TOAST__ == "function" ? __VUE_DEVTOOLS_TOAST__(t, r) : r === "error" ? console.error(t) : r === "warn" ? console.warn(t) : console.log(t);
+function Tr(e, t) {
+  const n = `▲ ■ ●${e}`;
+  typeof Xe == "function" ? Xe(n, t) : console.log(n);
+}
+function Xe(e, t) {
+  throw new Error(e + t);
 }
-const ke = (e) => {
-  const r = {
+const yt = (e) => {
+  const t = {
     id: e.uuid,
     label: e.type,
     children: [],
     tags: []
   };
-  e.name !== "" && r.tags.push({
+  e.name !== "" && t.tags.push({
     label: e.name,
     textColor: 5750629,
     backgroundColor: 15793395
   });
-  const t = Se(e);
-  return t > 0 && r.tags.push({
-    label: `${lr(t)} KB`,
+  const n = ke(e);
+  return n > 0 && t.tags.push({
+    label: `${ur(n)} KB`,
     textColor: 15707189,
     backgroundColor: 16775644,
     tooltip: "Memory usage"
-  }), e.type.includes("Light") && (r.tags.push({
+  }), e.type.includes("Light") && (Rn(e) && t.tags.push({
     label: `${e.intensity}`,
     textColor: 9738662,
     backgroundColor: 16316922,
     tooltip: "Intensity"
-  }), r.tags.push({
-    label: `#${e.color.getHexString()}`,
+  }), t.tags.push({
+    label: `#${new Z(e.color).getHexString()}`,
     textColor: 9738662,
     backgroundColor: 16316922,
     tooltip: "Color"
-  })), e.type.includes("Camera") && (r.tags.push({
+  })), e.type.includes("Camera") && (t.tags.push({
     label: `${e.fov}°`,
     textColor: 9738662,
     backgroundColor: 16316922,
     tooltip: "Field of view"
-  }), r.tags.push({
-    // eslint-disable-next-line max-len
+  }), t.tags.push({
     label: `x: ${Math.round(e.position.x)} y: ${Math.round(e.position.y)} z: ${Math.round(e.position.z)}`,
     textColor: 9738662,
     backgroundColor: 16316922,
     tooltip: "Position"
-  })), r;
+  })), t;
 };
-function Te(e, r) {
-  e.children.forEach((t) => {
-    if (t.type === "HightlightMesh")
+function _t(e, t, n = "") {
+  e.children.forEach((r) => {
+    if (r.type === "HightlightMesh" || n && !r.type.includes(n) && !r.name.includes(n))
       return;
-    const o = ke(t);
-    r.children.push(o), Te(t, o);
+    const s = yt(r);
+    t.children.push(s), _t(r, s, n);
   });
 }
-const Cr = [], O = "tres:inspector", Mr = ve({
+const Sr = [], X = "tres:inspector", Ar = Et({
   sceneGraph: null
 });
-function xr(e, r) {
-  _r(
+function kr(e, t) {
+  Er(
     {
       id: "dev.esm.tres",
       label: "TresJS 🪐",
       logo: "https://raw.githubusercontent.com/Tresjs/tres/main/public/favicon.svg",
       packageName: "tresjs",
       homepage: "https://tresjs.org",
-      componentStateTypes: Cr,
+      componentStateTypes: Sr,
       app: e
     },
-    (t) => {
-      typeof t.now != "function" && Er(
-        // eslint-disable-next-line max-len
+    (n) => {
+      typeof n.now != "function" && Tr(
         "You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html."
-      ), t.addInspector({
-        id: O,
+      ), n.addInspector({
+        id: X,
         label: "TresJS 🪐",
         icon: "account_tree",
         treeFilterPlaceholder: "Search instances"
       }), setInterval(() => {
-        t.sendInspectorTree(O);
+        n.sendInspectorTree(X);
       }, 1e3), setInterval(() => {
-        t.notifyComponentUpdate();
-      }, 5e3), t.on.getInspectorTree((i) => {
-        if (i.inspectorId === O) {
-          const n = ke(r.scene.value);
-          Te(r.scene.value, n), Mr.sceneGraph = n, i.rootNodes = [n];
+        n.notifyComponentUpdate();
+      }, 5e3), n.on.getInspectorTree((a) => {
+        if (a.inspectorId === X) {
+          const i = yt(t.scene.value);
+          _t(t.scene.value, i, a.filter), Ar.sceneGraph = i, a.rootNodes = [i];
         }
       });
-      let o = null, s = null;
-      t.on.getInspectorState((i) => {
-        if (i.inspectorId === O) {
-          const [n] = r.scene.value.getObjectsByProperty("uuid", i.nodeId);
-          if (!n)
+      let r = null, s = null;
+      n.on.getInspectorState((a) => {
+        var i;
+        if (a.inspectorId === X) {
+          const [l] = t.scene.value.getObjectsByProperty("uuid", a.nodeId);
+          if (!l)
             return;
-          if (s && o && o.parent && s.remove(o), n.isMesh) {
-            const a = tr(n);
-            n.add(a), o = a, s = n;
+          if (s && r && r.parent && s.remove(r), l.isMesh) {
+            const c = Qn(l);
+            l.add(c), r = c, s = l;
           }
-          i.state = {
-            object: [
-              {
-                key: "uuid",
-                editable: !0,
-                value: n.uuid
-              },
-              {
-                key: "name",
-                editable: !0,
-                value: n.name
-              },
-              {
-                key: "type",
-                editable: !0,
-                value: n.type
-              },
-              {
-                key: "position",
-                editable: !0,
-                value: n.position
-              },
-              {
-                key: "rotation",
-                editable: !0,
-                value: n.rotation
-              },
-              {
-                key: "scale",
-                editable: !0,
-                value: n.scale
-              },
-              {
-                key: "geometry",
-                value: n.geometry
-              },
-              {
-                key: "material",
-                value: n.material
-              },
-              {
-                key: "color",
-                editable: !0,
-                value: n.color
-              },
-              {
-                key: "intensity",
-                editable: !0,
-                value: n.intensity
-              },
-              {
-                key: "castShadow",
-                editable: !0,
-                value: n.castShadow
-              },
-              {
-                key: "receiveShadow",
-                editable: !0,
-                value: n.receiveShadow
-              },
-              {
-                key: "frustumCulled",
-                editable: !0,
-                value: n.frustumCulled
-              },
-              {
-                key: "matrixAutoUpdate",
-                editable: !0,
-                value: n.matrixAutoUpdate
-              },
-              {
-                key: "matrixWorldNeedsUpdate",
-                editable: !0,
-                value: n.matrixWorldNeedsUpdate
-              },
-              {
-                key: "matrixWorld",
-                value: n.matrixWorld
-              },
-              {
-                key: "visible",
-                editable: !0,
-                value: n.visible
-              }
-            ]
-          };
+          a.state = {
+            object: Object.entries(l).map(([c, o]) => c === "children" ? { key: c, value: o.filter((u) => u.type !== "HightlightMesh") } : { key: c, value: o, editable: !0 }).filter(({ key: c }) => c !== "parent")
+          }, l.isScene && (a.state.info = {
+            memory: ke(l),
+            objects: l.children.length,
+            calls: t.renderer.value.info.render.calls,
+            triangles: t.renderer.value.info.render.triangles,
+            points: t.renderer.value.info.render.points,
+            lines: t.renderer.value.info.render.lines
+          }, a.state.programs = ((i = t.renderer.value.info.programs) == null ? void 0 : i.map((c) => ({
+            key: c.name,
+            value: {
+              ...c,
+              vertexShader: c.vertexShader,
+              attributes: c.getAttributes(),
+              uniforms: c.getUniforms()
+            }
+          }))) || []);
         }
-      }), t.on.editInspectorState((i) => {
-        i.inspectorId === O && er(r.scene.value, i.nodeId, i.path, i.state.value);
+      }), n.on.editInspectorState((a) => {
+        a.inspectorId === X && Kn(t.scene.value, a.nodeId, a.path, a.state.value);
       });
     }
   );
 }
-const Sr = ["data-scene", "data-tres"], Pr = /* @__PURE__ */ ne({
+const xr = ["data-scene", "data-tres"], Lr = /* @__PURE__ */ Be({
   __name: "TresCanvas",
   props: {
     shadows: { type: Boolean, default: void 0 },
@@ -1049,6 +1542,8 @@ const Sr = ["data-scene", "data-tres"], Pr = /* @__PURE__ */ ne({
     useLegacyLights: { type: Boolean, default: void 0 },
     outputColorSpace: {},
     toneMappingExposure: {},
+    renderMode: { default: "always" },
+    dpr: {},
     camera: {},
     preset: {},
     windowSize: { type: Boolean, default: void 0 },
@@ -1065,108 +1560,131 @@ const Sr = ["data-scene", "data-tres"], Pr = /* @__PURE__ */ ne({
     logarithmicDepthBuffer: { type: Boolean, default: void 0 },
     failIfMajorPerformanceCaveat: { type: Boolean, default: void 0 }
   },
-  setup(e, { expose: r }) {
-    var h;
-    const t = e, { logWarning: o } = A(), s = R(), i = j(new ot()), { resume: n } = re(), a = Re(), l = (h = se()) == null ? void 0 : h.appContext.app, c = (p) => ne({
+  emits: [
+    "render",
+    "click",
+    "double-click",
+    "context-menu",
+    "pointer-move",
+    "pointer-up",
+    "pointer-down",
+    "pointer-enter",
+    "pointer-leave",
+    "pointer-over",
+    "pointer-out",
+    "pointer-missed",
+    "wheel",
+    "ready"
+  ],
+  setup(e, { expose: t, emit: n }) {
+    var b;
+    const r = e, s = n, a = Tt(), { logWarning: i } = Y(), l = H(), c = $(new nt()), o = (b = Ie()) == null ? void 0 : b.appContext.app;
+    Ce(et);
+    const u = (m) => Be({
       setup() {
-        var b;
-        const y = (b = se()) == null ? void 0 : b.appContext;
-        return y && (y.app = l), K("useTres", p), K("extend", oe), typeof window < "u" && xr(y.app, p), () => ie(Ue, null, a != null && a.default ? a.default() : []);
+        var C;
+        const d = (C = Ie()) == null ? void 0 : C.appContext;
+        return d && (d.app = o), _e("useTres", m), _e("extend", Ce), typeof window < "u" && kr(d == null ? void 0 : d.app, m), () => He(Ot, null, a != null && a.default ? a.default() : []);
       }
-    }), m = (p) => {
-      const y = c(p);
-      pr(ie(y), i.value);
-    }, d = (p, y = !1) => {
-      i.value.children = [], y && (p.renderer.value.dispose(), p.renderer.value.renderLists.dispose(), p.renderer.value.forceContextLoss()), m(p), n();
-    }, u = T(() => t.disableRender), f = j(null);
-    return r({ context: f, dispose: () => d(f.value, !0) }), Ie(() => {
-      const p = s;
-      f.value = cr({
-        scene: i.value,
-        canvas: p,
-        windowSize: t.windowSize,
-        disableRender: u,
-        rendererOptions: t
-      }), ar({ scene: i.value, contextParts: f.value });
-      const { registerCamera: y, camera: b, cameras: x, deregisterCamera: C } = f.value;
-      m(f.value);
-      const M = () => {
-        const w = new X(
+    }), y = (m) => {
+      const d = u(m), { render: C } = Rt(vr(m));
+      C(He(d), c.value);
+    }, f = (m, d = !1) => {
+      dt(m.scene.value), d && (m.renderer.value.dispose(), m.renderer.value.renderLists.dispose(), m.renderer.value.forceContextLoss()), c.value.__tres = {
+        root: m
+      }, y(m);
+    }, g = V(() => r.disableRender), v = $(null);
+    return t({ context: v, dispose: () => f(v.value, !0) }), St(() => {
+      const m = l;
+      v.value = hr({
+        scene: c.value,
+        canvas: m,
+        windowSize: r.windowSize ?? !1,
+        disableRender: g.value ?? !1,
+        rendererOptions: r,
+        emit: s
+      });
+      const { registerCamera: d, camera: C, cameras: E, deregisterCamera: P } = v.value;
+      y(v.value);
+      const S = () => {
+        const M = new we(
           45,
           window.innerWidth / window.innerHeight,
           0.1,
           1e3
         );
-        w.position.set(3, 3, 3), w.lookAt(0, 0, 0), y(w);
-        const S = D(() => {
-          x.value.length >= 2 && (w.removeFromParent(), C(w), S == null || S());
+        M.position.set(3, 3, 3), M.lookAt(0, 0, 0), d(M);
+        const _ = Te(() => {
+          E.value.length >= 2 && (M.removeFromParent(), P(M), _ == null || _());
         });
       };
-      ge(
-        () => t.camera,
-        (w, S) => {
-          w && y(w), S && (S.removeFromParent(), C(S));
+      ce(
+        () => r.camera,
+        (M, _) => {
+          M && d(M), _ && (_.removeFromParent(), P(_));
         },
         {
           immediate: !0
         }
-      ), b.value || (o(
+      ), C.value || (i(
         "No camera found. Creating a default perspective camera. To have full control over a camera, please add one to the scene."
-      ), M());
-    }), (p, y) => ($e(), Ne("canvas", {
+      ), S());
+    }), K(() => {
+      f(v.value);
+    }), (m, d) => (At(), kt("canvas", {
       ref_key: "canvas",
-      ref: s,
-      "data-scene": i.value.uuid,
-      class: Ve(p.$attrs.class),
-      "data-tres": `tresjs ${ze(Nt).version}`,
-      style: We({
+      ref: l,
+      "data-scene": c.value.uuid,
+      class: xt(m.$attrs.class),
+      "data-tres": `tresjs ${J(An).version}`,
+      style: Lt({
         display: "block",
         width: "100%",
         height: "100%",
-        position: p.windowSize ? "fixed" : "relative",
+        position: m.windowSize ? "fixed" : "relative",
         top: 0,
         left: 0,
         pointerEvents: "auto",
         touchAction: "none",
-        ...p.$attrs.style
+        ...m.$attrs.style
       })
-    }, null, 14, Sr));
+    }, null, 14, xr));
   }
-}), kr = [
+}), Rr = [
   "TresCanvas",
   "TresLeches",
   "TresScene"
-], Tr = {
+], Or = {
   template: {
     compilerOptions: {
-      isCustomElement: (e) => e.startsWith("Tres") && !kr.includes(e) || e === "primitive"
+      isCustomElement: (e) => e.startsWith("Tres") && !Rr.includes(e) || e === "primitive"
     }
   }
-}, Wr = Tr, Ur = {
-  mounted: (e, r) => {
-    if (r.arg) {
-      console.log(`v-log:${r.arg}`, e[r.arg]);
+}, Jr = Or, Kr = {
+  mounted: (e, t) => {
+    if (t.arg) {
+      console.log(`v-log:${t.arg}`, e[t.arg]);
       return;
     }
     console.log("v-log", e);
   }
 };
-class Ae extends nt {
-  constructor(r, t) {
-    const o = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], s = new ae();
-    s.setAttribute("position", new le(o, 3)), s.computeBoundingSphere();
-    const i = new st({ fog: !1 });
-    super(s, i), this.light = r, this.color = t, this.type = "RectAreaLightHelper";
-    const n = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], a = new ae();
-    a.setAttribute("position", new le(n, 3)), a.computeBoundingSphere(), this.add(new it(a, new we({ side: at, fog: !1 })));
+class wt extends zt {
+  constructor(t, n) {
+    const r = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], s = new $e();
+    s.setAttribute("position", new Ue(r, 3)), s.computeBoundingSphere();
+    const a = new Gt({ fog: !1 });
+    super(s, a), this.light = t, this.color = n, this.type = "RectAreaLightHelper";
+    const i = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], l = new $e();
+    l.setAttribute("position", new Ue(i, 3)), l.computeBoundingSphere(), this.add(new Vt(l, new ot({ side: Yt, fog: !1 })));
   }
   updateMatrixWorld() {
     if (this.scale.set(0.5 * this.light.width, 0.5 * this.light.height, 1), this.color !== void 0)
       this.material.color.set(this.color), this.children[0].material.color.set(this.color);
     else {
       this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
-      const r = this.material.color, t = Math.max(r.r, r.g, r.b);
-      t > 1 && r.multiplyScalar(1 / t), this.children[0].material.color.copy(this.material.color);
+      const t = this.material.color, n = Math.max(t.r, t.g, t.b);
+      n > 1 && t.multiplyScalar(1 / n), this.children[0].material.color.copy(this.material.color);
     }
     this.matrixWorld.extractRotation(this.light.matrixWorld).scale(this.scale).copyPosition(this.light.matrixWorld), this.children[0].matrixWorld.copy(this.matrixWorld);
   }
@@ -1174,96 +1692,87 @@ class Ae extends nt {
     this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
   }
 }
-const { logWarning: me } = A();
-let z, k;
-const Ar = {
-  DirectionalLight: lt,
-  PointLight: ut,
-  SpotLight: ct,
-  HemisphereLight: dt,
-  RectAreaLight: Ae
-}, Fr = {
+const { logWarning: Ze } = Y();
+let le, W;
+const Dr = {
+  DirectionalLight: qt,
+  PointLight: Jt,
+  SpotLight: Kt,
+  HemisphereLight: Qt,
+  RectAreaLight: wt
+}, Qr = {
   mounted: (e) => {
     if (!e.isLight) {
-      me(`${e.type} is not a light`);
+      Ze(`${e.type} is not a light`);
       return;
     }
-    z = Ar[e.type], e.parent.add(new z(e, 1, e.color.getHex()));
+    le = Dr[e.type], e.parent.add(new le(e, 1, e.color.getHex()));
   },
   updated: (e) => {
-    k = e.parent.children.find((r) => r instanceof z), !(k instanceof Ae) && k.update();
+    W = e.parent.children.find((t) => t instanceof le), !(W instanceof wt) && W.update();
   },
   unmounted: (e) => {
     if (!e.isLight) {
-      me(`${e.type} is not a light`);
-      return;
-    }
-    k = e.parent.children.find((r) => r instanceof z), k && k.dispose && k.dispose(), e.parent.remove(k);
-  }
-}, { logWarning: Lr } = A(), Gr = {
-  updated: (e, r) => {
-    const t = xe(r);
-    if (!t) {
-      Lr(`v-always-look-at: problem with binding value: ${r.value}`);
+      Ze(`${e.type} is not a light`);
       return;
     }
-    const { onLoop: o } = re();
-    o(() => {
-      e.lookAt(t);
-    });
+    W = e.parent.children.find((t) => t instanceof le), W && W.dispose && W.dispose(), e.parent.remove(W);
   }
-}, { logWarning: Or } = A(), Jr = {
-  updated: (e, r) => {
+}, { logWarning: jr } = Y();
+let I = null;
+const Xr = {
+  updated: (e, t) => {
     var s;
-    const t = xe(r);
-    if (!t) {
-      Or(`v-distance-to: problem with binding value: ${r.value}`);
+    const n = Xn(t);
+    if (!n) {
+      jr(`v-distance-to: problem with binding value: ${t.value}`);
       return;
     }
-    P && (P.dispose(), e.parent.remove(P));
-    const o = t.clone().sub(e.position);
-    o.normalize(), P = new ft(o, e.position, e.position.distanceTo(t), 16776960), e.parent.add(P), console.table(
+    I && (I.dispose(), e.parent.remove(I));
+    const r = n.clone().sub(e.position);
+    r.normalize(), I = new Xt(r, e.position, e.position.distanceTo(n), 16776960), e.parent.add(I), console.table(
       [
-        ["Distance:", e.position.distanceTo(t)],
+        ["Distance:", e.position.distanceTo(n)],
         [`origin: ${e.name || e.type}`, `x:${e.position.x}, y:${e.position.y}, z:${(s = e.position) == null ? void 0 : s.z}`],
-        [`Destiny: ${e.name || e.type}`, `x:${t.x}, y:${t.y}, z:${t == null ? void 0 : t.z}`]
+        [`Destiny: ${e.name || e.type}`, `x:${n.x}, y:${n.y}, z:${n == null ? void 0 : n.z}`]
       ]
     );
   },
   unmounted: (e) => {
-    P == null || P.dispose(), e.parent.remove(P);
+    I == null || I.dispose(), e.parent.remove(I);
   }
-};
-let P = null;
-const Qr = {
+}, Zr = {
   install(e) {
-    e.component("TresCanvas", Pr);
+    e.component("TresCanvas", Lr);
   }
 };
 export {
-  Pr as TresCanvas,
-  Z as catalogue,
-  Qr as default,
-  oe as extend,
-  Rr as isProd,
-  Ft as normalizeColor,
-  Ir as normalizeVectorFlexibleParam,
-  Wr as templateCompilerOptions,
-  sr as trasverseObjects,
-  Vt as useCamera,
-  $r as useLoader,
-  A as useLogger,
-  ar as usePointerEventHandler,
-  ir as useRaycaster,
-  re as useRenderLoop,
-  or as useRenderer,
-  Vr as useSeek,
-  Nr as useTexture,
-  zr as useTres,
-  dr as useTresContext,
-  cr as useTresContextProvider,
-  Gr as vAlwaysLookAt,
-  Jr as vDistanceTo,
-  Fr as vLightHelper,
-  Ur as vLog
+  Lr as TresCanvas,
+  Me as catalogue,
+  pr as createRenderLoop,
+  Zr as default,
+  dt as dispose,
+  Ce as extend,
+  Fr as isProd,
+  Un as normalizeColor,
+  Wr as normalizeVectorFlexibleParam,
+  Vr as onTresReady,
+  Jr as templateCompilerOptions,
+  lr as trasverseObjects,
+  Bn as useCamera,
+  Nr as useLoader,
+  Y as useLogger,
+  qr as useLoop,
+  cr as useRaycaster,
+  Ur as useRenderLoop,
+  ir as useRenderer,
+  Gr as useSeek,
+  zr as useTexture,
+  Yr as useTres,
+  pe as useTresContext,
+  hr as useTresContextProvider,
+  fr as useTresEventManager,
+  Xr as vDistanceTo,
+  Qr as vLightHelper,
+  Kr as vLog
 };
diff --git a/node_modules/@tresjs/core/dist/tres.umd.cjs b/node_modules/@tresjs/core/dist/tres.umd.cjs
index 038f480..f9e38cd 100644
--- a/node_modules/@tresjs/core/dist/tres.umd.cjs
+++ b/node_modules/@tresjs/core/dist/tres.umd.cjs
@@ -1,8 +1,8 @@
 /**
  * name: @tresjs/core
- * version: v3.8.0
+ * version: v4.2.5
  * (c) 2024
  * description: Declarative ThreeJS using Vue Components
  * author: Alvaro Saburido <hola@alvarosaburido.dev> (https://github.com/alvarosabu/)
  */
-(function(v,u){typeof exports=="object"&&typeof module<"u"?u(exports,require("vue"),require("three"),require("@vueuse/core")):typeof define=="function"&&define.amd?define(["exports","vue","three","@vueuse/core"],u):(v=typeof globalThis<"u"?globalThis:v||self,u(v.tres={},v.Vue,v.Three,v.VueUseCore))})(this,function(v,u,p,y){"use strict";var yt=Object.defineProperty;var wt=(v,u,p)=>u in v?yt(v,u,{enumerable:!0,configurable:!0,writable:!0,value:p}):v[u]=p;var Q=(v,u,p)=>(wt(v,typeof u!="symbol"?u+"":u,p),p);function _e(e){const r=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(e){for(const t in e)if(t!=="default"){const n=Object.getOwnPropertyDescriptor(e,t);Object.defineProperty(r,t,n.get?n:{enumerable:!0,get:()=>e[t]})}}return r.default=e,Object.freeze(r)}const Y=_e(p),Ce={name:"@tresjs/core",type:"module",version:"3.8.0",packageManager:"pnpm@8.15.6",description:"Declarative ThreeJS using Vue Components",author:"Alvaro Saburido <hola@alvarosaburido.dev> (https://github.com/alvarosabu/)",license:"MIT",keywords:["vue","3d","threejs","three","threejs-vue"],sideEffects:!1,exports:{".":{types:"./dist/index.d.ts",require:"./dist/tres.umd.cjs",import:"./dist/tres.js"},"./components":{types:"./dist/components/index.d.ts"},"./composables":{types:"./dist/composables/index.d.ts"},"./types":{types:"./dist/types/index.d.ts"},"./utils":{types:"./dist/utils/index.d.ts"},"./*":"./*"},main:"./dist/tres.js",module:"./dist/tres.js",types:"./dist/index.d.ts",files:["dist","*.d.ts"],publishConfig:{access:"public"},scripts:{dev:"cd playground && npm run dev",build:"vite build",playground:"cd playground && npm run dev",test:"vitest","test:ci":"vitest run","test:ui":"vitest --ui",release:"release-it",coverage:"vitest run --coverage",lint:"eslint . --ext .js,.jsx,.ts,.tsx,.vue","docs:dev":"vitepress dev docs","docs:build":"vitepress build docs","docs:serve":"vitepress serve docs","docs:preview":"vitepress preview docs","docs:contributors":"esno scripts/update-contributors.ts"},peerDependencies:{three:">=0.133",vue:">=3.3"},dependencies:{"@alvarosabu/utils":"^3.1.1","@vue/devtools-api":"^6.6.1","@vueuse/core":"^10.7.0"},devDependencies:{"@release-it/conventional-changelog":"^8.0.1","@stackblitz/sdk":"^1.9.0","@tresjs/cientos":"3.8.0","@tresjs/eslint-config-vue":"^0.2.1","@types/three":"^0.163.0","@typescript-eslint/eslint-plugin":"^7.5.0","@typescript-eslint/parser":"^7.5.0","@vitejs/plugin-vue":"^5.0.4","@vitest/coverage-c8":"^0.33.0","@vitest/ui":"^1.0.4","@vue/test-utils":"^2.4.3",eslint:"^8.55.0","eslint-plugin-vue":"^9.19.2",esno:"^4.0.0",gsap:"^3.12.3",jsdom:"^24.0.0",kolorist:"^1.8.0",ohmyfetch:"^0.4.21",pathe:"^1.1.1","release-it":"^17.0.1","rollup-plugin-analyzer":"^4.0.0","rollup-plugin-copy":"^3.5.0","rollup-plugin-visualizer":"^5.11.0",three:"^0.163.0",unocss:"^0.58.0",unplugin:"^1.10.1","unplugin-vue-components":"^0.26.0",vite:"^5.2.7","vite-plugin-banner":"^0.7.1","vite-plugin-dts":"3.8.1","vite-plugin-inspect":"^0.8.1","vite-plugin-require-transform":"^1.0.21","vite-svg-loader":"^5.1.0",vitepress:"1.0.2",vitest:"^1.0.4",vue:"^3.3.11","vue-demi":"^0.14.6"}},K=({sizes:e,scene:r})=>{const t=u.ref([]),n=u.computed(()=>t.value[0]),s=(a,l=!1)=>{t.value.some(({uuid:d})=>d===a.uuid)||(l?o(a):t.value.push(a))},i=a=>{t.value=t.value.filter(({uuid:l})=>l!==a.uuid)},o=a=>{const l=a instanceof p.Camera?a:t.value.find(h=>h.uuid===a);if(!l)return;const d=t.value.filter(({uuid:h})=>h!==l.uuid);t.value=[l,...d]};return u.watchEffect(()=>{e.aspectRatio.value&&t.value.forEach(a=>{a instanceof p.PerspectiveCamera&&(a.aspect=e.aspectRatio.value),(a instanceof p.PerspectiveCamera||a instanceof p.OrthographicCamera)&&a.updateProjectionMatrix()})}),r.userData.tres__registerCamera=s,r.userData.tres__deregisterCamera=i,u.onUnmounted(()=>{t.value=[]}),{camera:n,cameras:t,registerCamera:s,deregisterCamera:i,setCameraActive:o}},X=y.createEventHook(),Z=y.createEventHook(),H=y.createEventHook(),j=new p.Clock;let E=0,I=0;const{pause:Me,resume:Pe,isActive:ke}=y.useRafFn(()=>{X.trigger({delta:E,elapsed:I,clock:j}),Z.trigger({delta:E,elapsed:I,clock:j}),H.trigger({delta:E,elapsed:I,clock:j})},{immediate:!1});H.on(()=>{E=j.getDelta(),I=j.getElapsedTime()});const $=()=>({onBeforeLoop:X.on,onLoop:Z.on,onAfterLoop:H.on,pause:Me,resume:Pe,isActive:ke}),Se=!0,z="[TresJS ▲ ■ ●] ";function D(){function e(...n){typeof n[0]=="string"?n[0]=z+n[0]:n.unshift(z),console.error(...n)}function r(...n){typeof n[0]=="string"?n[0]=z+n[0]:n.unshift(z),console.warn(...n)}function t(n,s){}return{logError:e,logWarning:r,logMessage:t}}function Ae(e){return typeof e=="number"?[e,e,e]:e instanceof p.Vector3?[e.x,e.y,e.z]:e}function ee(e){return e instanceof p.Color?e:Array.isArray(e)?new p.Color(...e):new p.Color(e)}class Le extends Y.Mesh{constructor(...t){super(...t);Q(this,"type","HightlightMesh");Q(this,"createTime");this.createTime=Date.now()}onBeforeRender(){const n=(Date.now()-this.createTime)/1e3,o=1+.07*Math.sin(2.5*n);this.scale.set(o,o,o)}}const te=(e,r)=>{for(const t of Object.keys(r))r[t]instanceof Object&&Object.assign(r[t],te(e[t],r[t]));return Object.assign(e||{},r),e},Oe=De("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot");function re(e){return e&&e.nodeType===1}function N(e){return e.replace(/-([a-z])/g,(r,t)=>t.toUpperCase())}function De(e,r){const t=Object.create(null),n=e.split(",");for(let s=0;s<n.length;s++)t[n[s]]=!0;return r?s=>!!t[s.toLowerCase()]:s=>!!t[s]}const xe=(e,r)=>{const t=new Set,n=[];for(const s of e){const i=r(s);t.has(i)||(t.add(i),n.push(s))}return n},ne=(e,r)=>{if(!r)return;const t=Array.isArray(r)?r:r.match(/([^[.\]])+/g);return t==null?void 0:t.reduce((n,s)=>n&&n[s],e)},Te=(e,r,t)=>{const n=Array.isArray(r)?r:r.match(/([^[.\]])+/g);n&&n.reduce((s,i,o)=>(s[i]===void 0&&(s[i]={}),o===n.length-1&&(s[i]=t),s[i]),e)};function oe(e,r){if(re(e)&&re(r)){const s=e.attributes,i=r.attributes;return s.length!==i.length?!1:Array.from(s).every(({name:o,value:a})=>r.getAttribute(o)===a)}if(e===r)return!0;if(e===null||typeof e!="object"||r===null||typeof r!="object")return!1;const t=Object.keys(e),n=Object.keys(r);if(t.length!==n.length)return!1;for(const s of t)if(!n.includes(s)||!oe(e[s],r[s]))return!1;return!0}function Be(e,r){if(!Array.isArray(e)||!Array.isArray(r)||e.length!==r.length)return!1;for(let t=0;t<e.length;t++)if(!oe(e[t],r[t]))return!1;return!0}const je=Array.isArray;function Ve(e,r,t,n){const s=l=>{if(l.uuid===r)return l;for(const d of l.children){const h=s(d);if(h)return h}},i=s(e);if(!i){console.warn("Object with UUID not found in the scene.");return}let o=i;for(let l=0;l<t.length-1;l++)if(o[t[l]]!==void 0)o=o[t[l]];else{console.warn(`Property path is not valid: ${t.join(".")}`);return}const a=t[t.length-1];o[a]!==void 0?o[a]=n:console.warn(`Property path is not valid: ${t.join(".")}`)}function Ee(e){const r=new p.MeshBasicMaterial({color:11003607,transparent:!0,opacity:.2,depthTest:!1,side:p.DoubleSide});return new Le(e.geometry.clone(),r)}function se(e){var t;let r=e.value;return e.value&&((t=e.value)!=null&&t.isMesh)&&(r=e.value.position),Array.isArray(e.value)&&(r=new p.Vector3(...r)),r}const Ie=Number.parseInt(p.REVISION.replace("dev","")),U={realistic:{shadows:!0,physicallyCorrectLights:!0,outputColorSpace:p.SRGBColorSpace,toneMapping:p.ACESFilmicToneMapping,toneMappingExposure:3,shadowMap:{enabled:!0,type:p.PCFSoftShadowMap}}};function ie({scene:e,canvas:r,options:t,disableRender:n,contextParts:{sizes:s,camera:i}}){const o=u.computed(()=>({alpha:y.toValue(t.alpha),depth:y.toValue(t.depth),canvas:y.unrefElement(r),context:y.toValue(t.context),stencil:y.toValue(t.stencil),antialias:y.toValue(t.antialias)===void 0?!0:y.toValue(t.antialias),precision:y.toValue(t.precision),powerPreference:y.toValue(t.powerPreference),premultipliedAlpha:y.toValue(t.premultipliedAlpha),preserveDrawingBuffer:y.toValue(t.preserveDrawingBuffer),logarithmicDepthBuffer:y.toValue(t.logarithmicDepthBuffer),failIfMajorPerformanceCaveat:y.toValue(t.failIfMajorPerformanceCaveat)})),a=u.shallowRef(new p.WebGLRenderer(o.value));u.watch(o,()=>{a.value.dispose(),a.value=new p.WebGLRenderer(o.value)}),u.watchEffect(()=>{a.value.setSize(s.width.value,s.height.value)});const{pixelRatio:l}=y.useDevicePixelRatio();u.watchEffect(()=>{a.value.setPixelRatio(l.value)});const{logError:d}=D(),f=(()=>{const g=new p.WebGLRenderer,C={shadowMap:{enabled:g.shadowMap.enabled,type:g.shadowMap.type},toneMapping:g.toneMapping,toneMappingExposure:g.toneMappingExposure,outputColorSpace:g.outputColorSpace};return g.dispose(),C})();u.watchEffect(()=>{const g=y.toValue(t.preset);g&&(g in U||d(`Renderer Preset must be one of these: ${Object.keys(U).join(", ")}`),te(a.value,U[g]));const C=(S,A)=>{const M=y.toValue(S),O=()=>{if(g)return ne(U[g],A)};if(M!==void 0)return M;const b=O();return b!==void 0?b:ne(f,A)},P=(S,A)=>Te(a.value,A,C(S,A));P(t.shadows,"shadowMap.enabled"),P(t.toneMapping,"toneMapping"),P(t.shadowMapType,"shadowMap.type"),Ie<150&&P(!t.useLegacyLights,"physicallyCorrectLights"),P(t.outputColorSpace,"outputColorSpace"),P(t.toneMappingExposure,"toneMappingExposure");const L=C(t.clearColor,"clearColor");L&&a.value.setClearColor(L?ee(L):new p.Color(0))});const{pause:c,resume:m,onLoop:_}=$();return _(()=>{i.value&&!y.toValue(n)&&a.value.render(e,i.value)}),m(),u.onUnmounted(()=>{c(),a.value.dispose(),a.value.forceContextLoss()}),{renderer:a}}const ae=e=>typeof e=="function",$e=e=>!!e&&e.constructor===Array;function le(e){const r={nodes:{},materials:{}};return e&&e.traverse(t=>{t.name&&(r.nodes[t.name]=t),t.material&&!r.materials[t.material.name]&&(r.materials[t.material.name]=t.material)}),r}async function ze(e,r,t,n,s){const{logError:i}=D(),o=new e;s&&s(o),t&&t(o);const l=(Array.isArray(r)?r:[r]).map(d=>new Promise((h,f)=>{o.load(d,c=>{c.scene&&Object.assign(c,le(c.scene)),h(c)},n,c=>f(i("[useLoader] - Failed to load resource",c)))}));return $e(r)?await Promise.all(l):await l[0]}async function Ne(e,r){const t=new p.TextureLoader(r),n=s=>new Promise((i,o)=>{t.load(s,a=>i(a),()=>null,()=>{o(new Error("[useTextures] - Failed to load texture"))})});if(je(e)){const s=await Promise.all(e.map(i=>n(i)));return e.length>1?s:s[0]}else{const{map:s,displacementMap:i,normalMap:o,roughnessMap:a,metalnessMap:l,aoMap:d,alphaMap:h,matcap:f}=e;return{map:s?await n(s):null,displacementMap:i?await n(i):null,normalMap:o?await n(o):null,roughnessMap:a?await n(a):null,metalnessMap:l?await n(l):null,aoMap:d?await n(d):null,alphaMap:h?await n(h):null,matcap:f?await n(f):null}}}const ue=(e,{renderer:r,camera:t,raycaster:n})=>{const s=u.computed(()=>r.value.domElement),{x:i,y:o}=y.usePointer({target:s}),{width:a,height:l,top:d,left:h}=y.useElementBounding(s),f=({x:b,y:k})=>{if(s.value)return{x:(b-h.value)/a.value*2-1,y:-((k-d.value)/l.value)*2+1}},c=({x:b,y:k})=>{if(t.value)return n.value.setFromCamera(new p.Vector2(b,k),t.value),n.value.intersectObjects(e.value,!1)},m=b=>{const k=f({x:(b==null?void 0:b.clientX)??i.value,y:(b==null?void 0:b.clientY)??o.value});return k?c(k)||[]:[]},_=u.computed(()=>m()),g=y.createEventHook(),C=y.createEventHook(),P=(b,k)=>{b.trigger({event:k,intersects:m(k)})},L=b=>{P(C,b)};let S;const A=b=>{var k;S=(k=m(b)[0])==null?void 0:k.object},M=b=>{var k;b instanceof PointerEvent&&S===((k=m(b)[0])==null?void 0:k.object)&&P(g,b)},O=b=>C.trigger({event:b,intersects:[]});return s.value.addEventListener("pointerup",M),s.value.addEventListener("pointerdown",A),s.value.addEventListener("pointermove",L),s.value.addEventListener("pointerleave",O),u.onUnmounted(()=>{s!=null&&s.value&&(s.value.removeEventListener("pointerup",M),s.value.removeEventListener("pointerdown",A),s.value.removeEventListener("pointermove",L),s.value.removeEventListener("pointerleave",O))}),{intersects:_,onClick:b=>g.on(b).off,onPointerMove:b=>C.on(b).off}};function Ue(){const{logWarning:e}=D();function r(i,o,a){let l=null;return i.traverse(d=>{d[o]===a&&(l=d)}),l||e(`Child with ${o} '${a}' not found.`),l}function t(i,o,a){const l=[];return i.traverse(d=>{d[o].includes(a)&&l.push(d)}),l.length||e(`Children with ${o} '${a}' not found.`),l}function n(i,o){return r(i,"name",o)}function s(i,o){return t(i,"name",o)}return{seek:r,seekByName:n,seekAll:t,seekAllByName:s}}const ce=({scene:e,contextParts:r})=>{const t=u.reactive({click:new Map,pointerMove:new Map,pointerEnter:new Map,pointerLeave:new Map}),n=u.ref(new Set),s=c=>{n.value.add(c)},i=c=>{n.value.delete(c)},o=c=>{Object.values(t).forEach(m=>m.delete(c)),i(c)},a=c=>{const{onClick:m,onPointerMove:_,onPointerEnter:g,onPointerLeave:C}=c;m&&t.click.set(c,m),_&&t.pointerMove.set(c,_),g&&t.pointerEnter.set(c,g),C&&t.pointerLeave.set(c,C)};e.userData.tres__registerAtPointerEventHandler=a,e.userData.tres__deregisterAtPointerEventHandler=o,e.userData.tres__registerBlockingObjectAtPointerEventHandler=s,e.userData.tres__deregisterBlockingObjectAtPointerEventHandler=i;const l=u.computed(()=>xe([...Array.from(n.value),...Object.values(t).map(c=>Array.from(c.keys())).flat()],({uuid:c})=>c)),{onClick:d,onPointerMove:h}=ue(l,r);d(({intersects:c,event:m})=>{var _;c.length&&((_=t.click.get(c[0].object))==null||_(c[0],m))});let f;return h(({intersects:c,event:m})=>{var L,S,A,M;const _=(L=c==null?void 0:c[0])==null?void 0:L.object,{pointerLeave:g,pointerEnter:C,pointerMove:P}=t;f&&f!==_&&((S=g.get(f))==null||S(f,m)),_&&(f!==_&&((A=C.get(_))==null||A(c[0],m)),(M=P.get(_))==null||M(c[0],m)),f=_||null}),{registerObject:a,deregisterObject:o}};function de(e){let r=0;return e.traverse(t=>{if(t.isMesh&&t.geometry){const n=t.geometry,s=n.attributes.position.count*3*Float32Array.BYTES_PER_ELEMENT,i=n.index?n.index.count*Uint32Array.BYTES_PER_ELEMENT:0,o=n.attributes.normal?n.attributes.normal.count*3*Float32Array.BYTES_PER_ELEMENT:0,a=n.attributes.uv?n.attributes.uv.count*2*Float32Array.BYTES_PER_ELEMENT:0,l=s+i+o+a;r+=l}}),r}function We(e){return(e/1024).toFixed(2)}const W=u.ref({}),F=e=>Object.assign(W.value,e);function Fe(e,r,t=10){const n=y.toValue(e)?y.useWindowSize():y.useElementSize(u.computed(()=>y.toValue(r).parentElement)),s=u.readonly(y.refDebounced(n.width,t)),i=u.readonly(y.refDebounced(n.height,t)),o=u.computed(()=>s.value/i.value);return{height:i,width:s,aspectRatio:o}}function fe({scene:e,canvas:r,windowSize:t,disableRender:n,rendererOptions:s}){const i=Fe(t,r),o=u.shallowRef(e),{camera:a,cameras:l,registerCamera:d,deregisterCamera:h,setCameraActive:f}=K({sizes:i,scene:e}),{renderer:c}=ie({scene:e,canvas:r,options:s,contextParts:{sizes:i,camera:a},disableRender:n}),m={sizes:i,scene:o,camera:a,cameras:u.readonly(l),renderer:c,raycaster:u.shallowRef(new p.Raycaster),controls:u.ref(null),perf:{maxFrames:160,fps:{value:0,accumulator:[]},memory:{currentMem:0,allocatedMem:0,accumulator:[]}},extend:F,registerCamera:d,setCameraActive:f,deregisterCamera:h};u.provide("useTres",m);const _=100,g=y.useFps({every:_}),{isSupported:C,memory:P}=y.useMemory({interval:_}),L=160;let S=performance.now();const A=({timestamp:R})=>{m.scene.value&&(m.perf.memory.allocatedMem=de(m.scene.value)),R-S>=_&&(S=R,m.perf.fps.accumulator.push(g.value),m.perf.fps.accumulator.length>L&&m.perf.fps.accumulator.shift(),m.perf.fps.value=g.value,C.value&&P.value&&(m.perf.memory.accumulator.push(P.value.usedJSHeapSize/1024/1024),m.perf.memory.accumulator.length>L&&m.perf.memory.accumulator.shift(),m.perf.memory.currentMem=m.perf.memory.accumulator.reduce((ht,vt)=>ht+vt,0)/m.perf.memory.accumulator.length))};let M=0;const O=1,{pause:b,resume:k}=y.useRafFn(({delta:R})=>{window.__TRES__DEVTOOLS__&&(A({timestamp:performance.now()}),M+=R,M>=O&&(window.__TRES__DEVTOOLS__.cb(m),M=0))},{immediate:!0});return u.onUnmounted(()=>{b()}),m}function pe(){const e=u.inject("useTres");if(!e)throw new Error("useTresContext must be used together with useTresContextProvider");return e}const Ge=pe;function Nt(e){}let w=null;const{logError:me}=D(),q=["onClick","onPointerMove","onPointerEnter","onPointerLeave"],Re={createElement(e,r,t,n){var o,a;if(n||(n={}),n.args||(n.args=[]),e==="template"||Oe(e))return null;let s=e.replace("Tres",""),i;if(e==="primitive"){(n==null?void 0:n.object)===void 0&&me("Tres primitives need a prop 'object'");const l=n.object;s=l.type,i=Object.assign(l,{type:s,attach:n.attach,primitive:!0})}else{const l=W.value[s];l||me(`${s} is not defined on the THREE namespace. Use extend to add it to the catalog.`),i=new l(...n.args)}return i.isCamera&&(n!=null&&n.position||i.position.set(3,3,3),n!=null&&n.lookAt||i.lookAt(0,0,0)),(n==null?void 0:n.attach)===void 0&&(i.isMaterial?i.attach="material":i.isBufferGeometry&&(i.attach="geometry")),i.isObject3D&&((o=n==null?void 0:n.material)!=null&&o.isMaterial&&(i.userData.tres__materialViaProp=!0),(a=n==null?void 0:n.geometry)!=null&&a.isBufferGeometry&&(i.userData.tres__geometryViaProp=!0)),i.userData={...i.userData,tres__name:s},i},insert(e,r){var n,s,i,o;r&&r.isScene&&(w=r);const t=r||w;if(e!=null&&e.isObject3D){if(e!=null&&e.isCamera){if(!(w!=null&&w.userData.tres__registerCamera))throw"could not find tres__registerCamera on scene's userData";(s=w==null?void 0:(n=w.userData).tres__registerCamera)==null||s.call(n,e)}if(e&&q.some(a=>e[a])){if(!(w!=null&&w.userData.tres__registerAtPointerEventHandler))throw"could not find tres__registerAtPointerEventHandler on scene's userData";(o=w==null?void 0:(i=w.userData).tres__registerAtPointerEventHandler)==null||o.call(i,e)}}e!=null&&e.isObject3D&&(t!=null&&t.isObject3D)?(t.add(e),e.dispatchEvent({type:"added"})):e!=null&&e.isFog?t.fog=e:typeof(e==null?void 0:e.attach)=="string"&&(e.__previousAttach=e[t==null?void 0:t.attach],t&&(t[e.attach]=e))},remove(e){var r,t;if(e){if(e.isObject3D){const n=e,s=d=>{var f,c;const h=d;d.userData.tres__materialViaProp||((f=h.material)==null||f.dispose(),h.material=void 0),d.userData.tres__geometryViaProp||((c=h.geometry)==null||c.dispose(),h.geometry=void 0)},i=w==null?void 0:w.userData.tres__deregisterAtPointerEventHandler,o=w==null?void 0:w.userData.tres__deregisterBlockingObjectAtPointerEventHandler,a=d=>{var h,f;if(!o)throw"could not find tres__deregisterBlockingObjectAtPointerEventHandler on scene's userData";if((f=w==null?void 0:(h=w.userData).tres__deregisterBlockingObjectAtPointerEventHandler)==null||f.call(h,d),!i)throw"could not find tres__deregisterAtPointerEventHandler on scene's userData";d&&q.some(c=>d[c])&&(i==null||i(d))},l=d=>{const h=w==null?void 0:w.userData.tres__deregisterCamera;if(!h)throw"could not find tres__deregisterCamera on scene's userData";d.isCamera&&(h==null||h(d))};(r=e.removeFromParent)==null||r.call(e),n.traverse(d=>{s(d),l(d),a==null||a(d)}),s(n),l(n),a==null||a(n)}(t=e.dispose)==null||t.call(e)}},patchProp(e,r,t,n){var s,i,o,a;if(e){let l=e,d=r;if(e.isObject3D&&d==="blocks-pointer-events"){n||n===""?(i=w==null?void 0:(s=w.userData).tres__registerBlockingObjectAtPointerEventHandler)==null||i.call(s,e):(a=w==null?void 0:(o=w.userData).tres__deregisterBlockingObjectAtPointerEventHandler)==null||a.call(o,e);return}let h=N(d),f=l==null?void 0:l[h];if(d==="args"){const m=e,_=t??[],g=n??[],C=e.userData.tres__name||e.type;C&&_.length&&!Be(_,g)&&(l=Object.assign(m,new W.value[C](...n)));return}if(l.type==="BufferGeometry"){if(d==="args")return;l.setAttribute(N(d),new p.BufferAttribute(...n));return}if(d.includes("-")&&f===void 0){const m=d.split("-");f=m.reduce((_,g)=>_[N(g)],l),d=m.pop(),h=d.toLowerCase(),f!=null&&f.set||(l=m.reduce((_,g)=>_[N(g)],l))}let c=n;if(c===""&&(c=!0),ae(f)){q.includes(r)||(Array.isArray(c)?e[h](...c):e[h](c));return}!(f!=null&&f.set)&&!ae(f)?l[h]=c:f.constructor===c.constructor&&(f!=null&&f.copy)?f==null||f.copy(c):Array.isArray(c)?f.set(...c):!f.isColor&&f.setScalar?f.setScalar(c):f.set(c)}},parentNode(e){return(e==null?void 0:e.parent)||null},createText:()=>void 0,createComment:()=>void 0,setText:()=>void 0,setElementText:()=>void 0,nextSibling:()=>void 0,querySelector:()=>void 0,setScopeId:()=>void 0,cloneNode:()=>void 0,insertStaticContent:()=>void 0},{render:He}=u.createRenderer(Re);F(Y);function qe(){return ge().__VUE_DEVTOOLS_GLOBAL_HOOK__}function ge(){return typeof navigator<"u"&&typeof window<"u"?window:typeof globalThis<"u"?globalThis:{}}const Je=typeof Proxy=="function",Qe="devtools-plugin:setup",Ye="plugin:settings:set";let B,J;function Ke(){var e;return B!==void 0||(typeof window<"u"&&window.performance?(B=!0,J=window.performance):typeof globalThis<"u"&&(!((e=globalThis.perf_hooks)===null||e===void 0)&&e.performance)?(B=!0,J=globalThis.perf_hooks.performance):B=!1),B}function Xe(){return Ke()?J.now():Date.now()}class Ze{constructor(r,t){this.target=null,this.targetQueue=[],this.onQueue=[],this.plugin=r,this.hook=t;const n={};if(r.settings)for(const o in r.settings){const a=r.settings[o];n[o]=a.defaultValue}const s=`__vue-devtools-plugin-settings__${r.id}`;let i=Object.assign({},n);try{const o=localStorage.getItem(s),a=JSON.parse(o);Object.assign(i,a)}catch{}this.fallbacks={getSettings(){return i},setSettings(o){try{localStorage.setItem(s,JSON.stringify(o))}catch{}i=o},now(){return Xe()}},t&&t.on(Ye,(o,a)=>{o===this.plugin.id&&this.fallbacks.setSettings(a)}),this.proxiedOn=new Proxy({},{get:(o,a)=>this.target?this.target.on[a]:(...l)=>{this.onQueue.push({method:a,args:l})}}),this.proxiedTarget=new Proxy({},{get:(o,a)=>this.target?this.target[a]:a==="on"?this.proxiedOn:Object.keys(this.fallbacks).includes(a)?(...l)=>(this.targetQueue.push({method:a,args:l,resolve:()=>{}}),this.fallbacks[a](...l)):(...l)=>new Promise(d=>{this.targetQueue.push({method:a,args:l,resolve:d})})})}async setRealTarget(r){this.target=r;for(const t of this.onQueue)this.target.on[t.method](...t.args);for(const t of this.targetQueue)t.resolve(await this.target[t.method](...t.args))}}function et(e,r){const t=e,n=ge(),s=qe(),i=Je&&t.enableEarlyProxy;if(s&&(n.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__||!i))s.emit(Qe,e,r);else{const o=i?new Ze(t,s):null;(n.__VUE_DEVTOOLS_PLUGINS__=n.__VUE_DEVTOOLS_PLUGINS__||[]).push({pluginDescriptor:t,setupFn:r,proxy:o}),o&&r(o.proxiedTarget)}}function tt(e,r){const t=`▲ ■ ●${e}`;typeof __VUE_DEVTOOLS_TOAST__=="function"?__VUE_DEVTOOLS_TOAST__(t,r):r==="error"?console.error(t):r==="warn"?console.warn(t):console.log(t)}const he=e=>{const r={id:e.uuid,label:e.type,children:[],tags:[]};e.name!==""&&r.tags.push({label:e.name,textColor:5750629,backgroundColor:15793395});const t=de(e);return t>0&&r.tags.push({label:`${We(t)} KB`,textColor:15707189,backgroundColor:16775644,tooltip:"Memory usage"}),e.type.includes("Light")&&(r.tags.push({label:`${e.intensity}`,textColor:9738662,backgroundColor:16316922,tooltip:"Intensity"}),r.tags.push({label:`#${e.color.getHexString()}`,textColor:9738662,backgroundColor:16316922,tooltip:"Color"})),e.type.includes("Camera")&&(r.tags.push({label:`${e.fov}°`,textColor:9738662,backgroundColor:16316922,tooltip:"Field of view"}),r.tags.push({label:`x: ${Math.round(e.position.x)} y: ${Math.round(e.position.y)} z: ${Math.round(e.position.z)}`,textColor:9738662,backgroundColor:16316922,tooltip:"Position"})),r};function ve(e,r){e.children.forEach(t=>{if(t.type==="HightlightMesh")return;const n=he(t);r.children.push(n),ve(t,n)})}const rt=[],V="tres:inspector",nt=u.reactive({sceneGraph:null});function ot(e,r){et({id:"dev.esm.tres",label:"TresJS 🪐",logo:"https://raw.githubusercontent.com/Tresjs/tres/main/public/favicon.svg",packageName:"tresjs",homepage:"https://tresjs.org",componentStateTypes:rt,app:e},t=>{typeof t.now!="function"&&tt("You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html."),t.addInspector({id:V,label:"TresJS 🪐",icon:"account_tree",treeFilterPlaceholder:"Search instances"}),setInterval(()=>{t.sendInspectorTree(V)},1e3),setInterval(()=>{t.notifyComponentUpdate()},5e3),t.on.getInspectorTree(i=>{if(i.inspectorId===V){const o=he(r.scene.value);ve(r.scene.value,o),nt.sceneGraph=o,i.rootNodes=[o]}});let n=null,s=null;t.on.getInspectorState(i=>{if(i.inspectorId===V){const[o]=r.scene.value.getObjectsByProperty("uuid",i.nodeId);if(!o)return;if(s&&n&&n.parent&&s.remove(n),o.isMesh){const a=Ee(o);o.add(a),n=a,s=o}i.state={object:[{key:"uuid",editable:!0,value:o.uuid},{key:"name",editable:!0,value:o.name},{key:"type",editable:!0,value:o.type},{key:"position",editable:!0,value:o.position},{key:"rotation",editable:!0,value:o.rotation},{key:"scale",editable:!0,value:o.scale},{key:"geometry",value:o.geometry},{key:"material",value:o.material},{key:"color",editable:!0,value:o.color},{key:"intensity",editable:!0,value:o.intensity},{key:"castShadow",editable:!0,value:o.castShadow},{key:"receiveShadow",editable:!0,value:o.receiveShadow},{key:"frustumCulled",editable:!0,value:o.frustumCulled},{key:"matrixAutoUpdate",editable:!0,value:o.matrixAutoUpdate},{key:"matrixWorldNeedsUpdate",editable:!0,value:o.matrixWorldNeedsUpdate},{key:"matrixWorld",value:o.matrixWorld},{key:"visible",editable:!0,value:o.visible}]}}}),t.on.editInspectorState(i=>{i.inspectorId===V&&Ve(r.scene.value,i.nodeId,i.path,i.state.value)})})}const st=["data-scene","data-tres"],ye=u.defineComponent({__name:"TresCanvas",props:{shadows:{type:Boolean,default:void 0},clearColor:{},toneMapping:{},shadowMapType:{},useLegacyLights:{type:Boolean,default:void 0},outputColorSpace:{},toneMappingExposure:{},camera:{},preset:{},windowSize:{type:Boolean,default:void 0},disableRender:{type:Boolean,default:void 0},context:{},precision:{},alpha:{type:Boolean,default:void 0},premultipliedAlpha:{type:Boolean},antialias:{type:Boolean,default:void 0},stencil:{type:Boolean,default:void 0},preserveDrawingBuffer:{type:Boolean,default:void 0},powerPreference:{},depth:{type:Boolean,default:void 0},logarithmicDepthBuffer:{type:Boolean,default:void 0},failIfMajorPerformanceCaveat:{type:Boolean,default:void 0}},setup(e,{expose:r}){var _;const t=e,{logWarning:n}=D(),s=u.ref(),i=u.shallowRef(new p.Scene),{resume:o}=$(),a=u.useSlots(),l=(_=u.getCurrentInstance())==null?void 0:_.appContext.app,d=g=>u.defineComponent({setup(){var P;const C=(P=u.getCurrentInstance())==null?void 0:P.appContext;return C&&(C.app=l),u.provide("useTres",g),u.provide("extend",F),typeof window<"u"&&ot(C.app,g),()=>u.h(u.Fragment,null,a!=null&&a.default?a.default():[])}}),h=g=>{const C=d(g);He(u.h(C),i.value)},f=(g,C=!1)=>{i.value.children=[],C&&(g.renderer.value.dispose(),g.renderer.value.renderLists.dispose(),g.renderer.value.forceContextLoss()),h(g),o()},c=u.computed(()=>t.disableRender),m=u.shallowRef(null);return r({context:m,dispose:()=>f(m.value,!0)}),u.onMounted(()=>{const g=s;m.value=fe({scene:i.value,canvas:g,windowSize:t.windowSize,disableRender:c,rendererOptions:t}),ce({scene:i.value,contextParts:m.value});const{registerCamera:C,camera:P,cameras:L,deregisterCamera:S}=m.value;h(m.value);const A=()=>{const M=new p.PerspectiveCamera(45,window.innerWidth/window.innerHeight,.1,1e3);M.position.set(3,3,3),M.lookAt(0,0,0),C(M);const O=u.watchEffect(()=>{L.value.length>=2&&(M.removeFromParent(),S(M),O==null||O())})};u.watch(()=>t.camera,(M,O)=>{M&&C(M),O&&(O.removeFromParent(),S(O))},{immediate:!0}),P.value||(n("No camera found. Creating a default perspective camera. To have full control over a camera, please add one to the scene."),A())}),(g,C)=>(u.openBlock(),u.createElementBlock("canvas",{ref_key:"canvas",ref:s,"data-scene":i.value.uuid,class:u.normalizeClass(g.$attrs.class),"data-tres":`tresjs ${u.unref(Ce).version}`,style:u.normalizeStyle({display:"block",width:"100%",height:"100%",position:g.windowSize?"fixed":"relative",top:0,left:0,pointerEvents:"auto",touchAction:"none",...g.$attrs.style})},null,14,st))}}),it=["TresCanvas","TresLeches","TresScene"],at={template:{compilerOptions:{isCustomElement:e=>e.startsWith("Tres")&&!it.includes(e)||e==="primitive"}}},lt={mounted:(e,r)=>{if(r.arg){console.log(`v-log:${r.arg}`,e[r.arg]);return}console.log("v-log",e)}};class we extends p.Line{constructor(r,t){const n=[1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],s=new p.BufferGeometry;s.setAttribute("position",new p.Float32BufferAttribute(n,3)),s.computeBoundingSphere();const i=new p.LineBasicMaterial({fog:!1});super(s,i),this.light=r,this.color=t,this.type="RectAreaLightHelper";const o=[1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],a=new p.BufferGeometry;a.setAttribute("position",new p.Float32BufferAttribute(o,3)),a.computeBoundingSphere(),this.add(new p.Mesh(a,new p.MeshBasicMaterial({side:p.BackSide,fog:!1})))}updateMatrixWorld(){if(this.scale.set(.5*this.light.width,.5*this.light.height,1),this.color!==void 0)this.material.color.set(this.color),this.children[0].material.color.set(this.color);else{this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);const r=this.material.color,t=Math.max(r.r,r.g,r.b);t>1&&r.multiplyScalar(1/t),this.children[0].material.color.copy(this.material.color)}this.matrixWorld.extractRotation(this.light.matrixWorld).scale(this.scale).copyPosition(this.light.matrixWorld),this.children[0].matrixWorld.copy(this.matrixWorld)}dispose(){this.geometry.dispose(),this.material.dispose(),this.children[0].geometry.dispose(),this.children[0].material.dispose()}}const{logWarning:be}=D();let G,T;const ut={DirectionalLight:p.DirectionalLightHelper,PointLight:p.PointLightHelper,SpotLight:p.SpotLightHelper,HemisphereLight:p.HemisphereLightHelper,RectAreaLight:we},ct={mounted:e=>{if(!e.isLight){be(`${e.type} is not a light`);return}G=ut[e.type],e.parent.add(new G(e,1,e.color.getHex()))},updated:e=>{T=e.parent.children.find(r=>r instanceof G),!(T instanceof we)&&T.update()},unmounted:e=>{if(!e.isLight){be(`${e.type} is not a light`);return}T=e.parent.children.find(r=>r instanceof G),T&&T.dispose&&T.dispose(),e.parent.remove(T)}},{logWarning:dt}=D(),ft={updated:(e,r)=>{const t=se(r);if(!t){dt(`v-always-look-at: problem with binding value: ${r.value}`);return}const{onLoop:n}=$();n(()=>{e.lookAt(t)})}},{logWarning:pt}=D(),mt={updated:(e,r)=>{var s;const t=se(r);if(!t){pt(`v-distance-to: problem with binding value: ${r.value}`);return}x&&(x.dispose(),e.parent.remove(x));const n=t.clone().sub(e.position);n.normalize(),x=new p.ArrowHelper(n,e.position,e.position.distanceTo(t),16776960),e.parent.add(x),console.table([["Distance:",e.position.distanceTo(t)],[`origin: ${e.name||e.type}`,`x:${e.position.x}, y:${e.position.y}, z:${(s=e.position)==null?void 0:s.z}`],[`Destiny: ${e.name||e.type}`,`x:${t.x}, y:${t.y}, z:${t==null?void 0:t.z}`]])},unmounted:e=>{x==null||x.dispose(),e.parent.remove(x)}};let x=null;const gt={install(e){e.component("TresCanvas",ye)}};v.TresCanvas=ye,v.catalogue=W,v.default=gt,v.extend=F,v.isProd=Se,v.normalizeColor=ee,v.normalizeVectorFlexibleParam=Ae,v.templateCompilerOptions=at,v.trasverseObjects=le,v.useCamera=K,v.useLoader=ze,v.useLogger=D,v.usePointerEventHandler=ce,v.useRaycaster=ue,v.useRenderLoop=$,v.useRenderer=ie,v.useSeek=Ue,v.useTexture=Ne,v.useTres=Ge,v.useTresContext=pe,v.useTresContextProvider=fe,v.vAlwaysLookAt=ft,v.vDistanceTo=mt,v.vLightHelper=ct,v.vLog=lt,Object.defineProperties(v,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
+(function(b,d){typeof exports=="object"&&typeof module<"u"?d(exports,require("vue"),require("three"),require("@vueuse/core")):typeof define=="function"&&define.amd?define(["exports","vue","three","@vueuse/core"],d):(b=typeof globalThis<"u"?globalThis:b||self,d(b.tres={},b.Vue,b.Three,b.VueUseCore))})(this,function(b,d,_,C){"use strict";var _n=Object.defineProperty;var wn=(b,d,_)=>d in b?_n(b,d,{enumerable:!0,configurable:!0,writable:!0,value:_}):b[d]=_;var ye=(b,d,_)=>wn(b,typeof d!="symbol"?d+"":d,_);function it(e){const t=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(e){for(const n in e)if(n!=="default"){const r=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(t,n,r.get?r:{enumerable:!0,get:()=>e[n]})}}return t.default=e,Object.freeze(t)}const _e=it(_),at={name:"@tresjs/core",type:"module",version:"4.2.5",packageManager:"pnpm@9.1.4",description:"Declarative ThreeJS using Vue Components",author:"Alvaro Saburido <hola@alvarosaburido.dev> (https://github.com/alvarosabu/)",license:"MIT",keywords:["vue","3d","threejs","three","threejs-vue"],sideEffects:!1,exports:{".":{types:"./dist/index.d.ts",import:"./dist/tres.js",require:"./dist/tres.umd.cjs"},"./components":{types:"./dist/src/components/index.d.ts"},"./composables":{types:"./dist/src/composables/index.d.ts"},"./types":{types:"./dist/src/types/index.d.ts"},"./utils":{types:"./dist/src/utils/index.d.ts"},"./*":"./*"},main:"./dist/tres.js",module:"./dist/tres.js",types:"./dist/index.d.ts",files:["*.d.ts","dist"],publishConfig:{access:"public"},scripts:{dev:"cd playground && npm run dev",build:"vite build",playground:"cd playground && npm run dev",test:"vitest","test:ci":"vitest run","test:ui":"vitest --ui --coverage.enabled=true",release:"release-it",coverage:"vitest run --coverage",lint:"eslint .","lint:fix":"eslint . --fix","docs:dev":"vitepress dev docs","docs:build":"vitepress build docs","docs:serve":"vitepress serve docs","docs:preview":"vitepress preview docs","docs:contributors":"esno scripts/update-contributors.ts",prepare:"node .husky/install.mjs"},peerDependencies:{three:">=0.133",vue:">=3.4"},dependencies:{"@alvarosabu/utils":"^3.2.0","@vue/devtools-api":"^6.6.3","@vueuse/core":"^10.11.0"},devDependencies:{"@release-it/conventional-changelog":"^8.0.1","@stackblitz/sdk":"^1.11.0","@tresjs/cientos":"3.9.0","@tresjs/eslint-config":"^1.1.0","@types/three":"^0.166.0","@typescript-eslint/eslint-plugin":"^7.16.0","@typescript-eslint/parser":"^7.16.0","@vitejs/plugin-vue":"^5.0.5","@vitest/coverage-c8":"^0.33.0","@vitest/coverage-v8":"^2.0.2","@vitest/ui":"^2.0.2","@vue/test-utils":"^2.4.6",eslint:"^9.6.0","eslint-plugin-vue":"^9.27.0",esno:"^4.7.0",gsap:"^3.12.5",husky:"^9.0.11",jsdom:"^24.1.0",kolorist:"^1.8.0",ohmyfetch:"^0.4.21",pathe:"^1.1.2","release-it":"^17.5.0","rollup-plugin-analyzer":"^4.0.0","rollup-plugin-copy":"^3.5.0","rollup-plugin-visualizer":"^5.12.0",sponsorkit:"^0.14.6",three:"^0.166.1",unocss:"^0.61.3",unplugin:"^1.11.0","unplugin-vue-components":"^0.27.2",vite:"^5.3.3","vite-plugin-banner":"^0.7.1","vite-plugin-dts":"3.9.1","vite-plugin-inspect":"^0.8.4","vite-plugin-require-transform":"^1.0.21","vite-svg-loader":"^5.1.0",vitepress:"1.3.0",vitest:"^2.0.2",vue:"^3.4.31","vue-demi":"^0.14.8"}};function fe(e){return typeof e>"u"}function Z(e){return Array.isArray(e)}function lt(e){return typeof e=="number"}function we(e){return typeof e=="string"}function G(e){return typeof e=="function"}function U(e){return e===Object(e)&&!Z(e)&&!G(e)}function F(e){return U(e)&&"isObject3D"in e&&!!e.isObject3D}function be(e){return U(e)&&"isCamera"in e&&!!e.isCamera}function ct(e){return U(e)&&"isBufferGeometry"in e&&!!e.isBufferGeometry}function ut(e){return U(e)&&"isMaterial"in e&&!!e.isMaterial}function ft(e){return U(e)&&"isLight"in e&&!!e.isLight}function dt(e){return U(e)&&"isFog"in e&&!!e.isFog}function pt(e){return U(e)&&"isScene"in e&&!!e.isScene}function ee(e){return F(e)||ct(e)||ut(e)||dt(e)}function mt(e){return U(e)&&!!e.isPrimitive}const Ce=({sizes:e})=>{const t=d.ref([]),n=d.computed(()=>t.value[0]),r=i=>{const l=i instanceof _.Camera?i:t.value.find(o=>o.uuid===i);if(!l)return;const c=t.value.filter(({uuid:o})=>o!==l.uuid);t.value=[l,...c]},s=(i,l=!1)=>{if(be(i)){const c=i;if(t.value.some(({uuid:o})=>o===c.uuid))return;l?r(c):t.value.push(c)}},a=i=>{if(be(i)){const l=i;t.value=t.value.filter(({uuid:c})=>c!==l.uuid)}};return d.watchEffect(()=>{e.aspectRatio.value&&t.value.forEach(i=>{!i.manual&&(i instanceof _.PerspectiveCamera||ht(i))&&(i instanceof _.PerspectiveCamera?i.aspect=e.aspectRatio.value:(i.left=e.width.value*-.5,i.right=e.width.value*.5,i.top=e.height.value*.5,i.bottom=e.height.value*-.5),i.updateProjectionMatrix())})}),d.onUnmounted(()=>{t.value=[]}),{camera:n,cameras:t,registerCamera:s,deregisterCamera:a,setCameraActive:r}};function ht(e){return e.hasOwnProperty("isOrthographicCamera")&&e.isOrthographicCamera}const Me=C.createEventHook(),Pe=C.createEventHook(),de=C.createEventHook(),K=new _.Clock;let te=0,ne=0;const{pause:gt,resume:Se,isActive:vt}=C.useRafFn(()=>{Me.trigger({delta:te,elapsed:ne,clock:K}),Pe.trigger({delta:te,elapsed:ne,clock:K}),de.trigger({delta:te,elapsed:ne,clock:K})},{immediate:!1});de.on(()=>{te=K.getDelta(),ne=K.getElapsedTime()});let ke=!1;const yt=()=>(ke||(ke=!0,Se()),{onBeforeLoop:Me.on,onLoop:Pe.on,onAfterLoop:de.on,pause:gt,resume:Se,isActive:vt}),_t=!0,re="[TresJS ▲ ■ ●] ";function W(){function e(...r){typeof r[0]=="string"?r[0]=re+r[0]:r.unshift(re),console.error(...r)}function t(...r){typeof r[0]=="string"?r[0]=re+r[0]:r.unshift(re),console.warn(...r)}function n(r,s){}return{logError:e,logWarning:t,logMessage:n}}function wt(e){return typeof e=="number"?[e,e,e]:e instanceof _.Vector3?[e.x,e.y,e.z]:e}function Ae(e){return e instanceof _.Color?e:Array.isArray(e)?new _.Color(...e):new _.Color(e)}class bt extends _e.Mesh{constructor(...n){super(...n);ye(this,"type","HightlightMesh");ye(this,"createTime");this.createTime=Date.now()}onBeforeRender(){const r=(Date.now()-this.createTime)/1e3,i=1+.07*Math.sin(2.5*r);this.scale.set(i,i,i)}}const Le=(e,t)=>{for(const n of Object.keys(t))t[n]instanceof Object&&Object.assign(t[n],Le(e[n],t[n]));return Object.assign(e||{},t),e},Ct=St("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot");function Oe(e){return e&&e.nodeType===1}function oe(e){return e.replace(/-([a-z])/g,(t,n)=>n.toUpperCase())}const Mt=/\B([A-Z])/g;function Pt(e){return e.replace(Mt,"-$1").toLowerCase()}function St(e,t){const n=Object.create(null),r=e.split(",");for(let s=0;s<r.length;s++)n[r[s]]=!0;return s=>!!n[s]}const De=(e,t)=>{if(!t)return;const n=Array.isArray(t)?t:t.match(/([^[.\]])+/g);return n==null?void 0:n.reduce((r,s)=>r&&r[s],e)},kt=(e,t,n)=>{const r=Array.isArray(t)?t:t.match(/([^[.\]])+/g);r&&r.reduce((s,a,i)=>(s[a]===void 0&&(s[a]={}),i===r.length-1&&(s[a]=n),s[a]),e)};function je(e,t){if(Oe(e)&&Oe(t)){const s=e.attributes,a=t.attributes;return s.length!==a.length?!1:Array.from(s).every(({name:i,value:l})=>t.getAttribute(i)===l)}if(e===t)return!0;if(e===null||typeof e!="object"||t===null||typeof t!="object")return!1;const n=Object.keys(e),r=Object.keys(t);if(n.length!==r.length)return!1;for(const s of n)if(!r.includes(s)||!je(e[s],t[s]))return!1;return!0}function At(e,t){if(!Array.isArray(e)||!Array.isArray(t)||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(!je(e[n],t[n]))return!1;return!0}const Lt=Array.isArray;function Ot(e,t,n,r){const s=c=>{if(c.uuid===t)return c;for(const o of c.children){const u=s(o);if(u)return u}},a=s(e);if(!a){console.warn("Object with UUID not found in the scene.");return}let i=a;for(let c=0;c<n.length-1;c++)if(i[n[c]]!==void 0)i=i[n[c]];else{console.warn(`Property path is not valid: ${n.join(".")}`);return}const l=n[n.length-1];i[l]!==void 0?i[l]=r:console.warn(`Property path is not valid: ${n.join(".")}`)}function Dt(e){const t=new _.MeshBasicMaterial({color:11003607,transparent:!0,opacity:.2,depthTest:!1,side:_.DoubleSide});return new bt(e.geometry.clone(),t)}function jt(e){var n;let t=e.value;return e.value&&((n=e.value)!=null&&n.isMesh)&&(t=e.value.position),Array.isArray(e.value)&&(t=new _.Vector3(...t)),t}function Tt(e){return"map"in e}function Te(e){Tt(e)&&e.map&&e.map.dispose(),e.dispose()}function pe(e){var n,r;if(e.parent&&((n=e.removeFromParent)==null||n.call(e)),delete e.__tres,[...e.children].forEach(s=>pe(s)),!(e instanceof _.Scene)){const s=e;e&&((r=e.dispose)==null||r.call(e)),s.geometry&&(s.geometry.dispose(),delete s.geometry),Array.isArray(s.material)?(s.material.forEach(a=>Te(a)),delete s.material):s.material&&(Te(s.material),delete s.material)}}function xt(e,t){let n=0;for(let r=0;r<e.length;r++)t(e[r],r)&&(e[n]=e[r],n++);return e.length=n,e}function me(e,t){let n=e;if(t.includes("-")){const r=t.split("-");let s=r.shift();for(;n&&r.length;)s in n?(n=n[s],s=r.shift()):s=xe(s,r.shift());return{target:n,key:xe(s,...r)}}else return{target:n,key:t}}function xe(...e){return e.map((t,n)=>n===0?t:t.charAt(0).toUpperCase()+t.slice(1)).join("")}const Be=/-\d+$/;function Bt(e,t,n){if(we(n)){if(Be.test(n)){const a=n.replace(Be,""),{target:i,key:l}=me(e,a);if(!Array.isArray(i[l])){const c=i[l],o=[];o.__tresDetach=()=>{o.every(u=>fe(u))&&(i[l]=c)},i[l]=o}}const{target:r,key:s}=me(e,n);t.__tres.previousAttach=r[s],r[s]=Y(t)}else t.__tres.previousAttach=n(e,t)}function It(e,t,n){var r,s,a;if(we(n)){const{target:i,key:l}=me(e,n),c=t.__tres.previousAttach;c===void 0?delete i[l]:i[l]=c,"__tresDetach"in i&&i.__tresDetach()}else(s=(r=t.__tres)==null?void 0:r.previousAttach)==null||s.call(r,e,t);(a=t.__tres)==null||delete a.previousAttach}function q(e,t,n){const r=e;return r.__tres={type:"unknown",eventCount:0,root:n,handlers:{},memoizedProps:{},objects:[],parent:null,previousAttach:null,...t},r.__tres.attach||(r.isMaterial?r.__tres.attach="material":r.isBufferGeometry?r.__tres.attach="geometry":r.isFog&&(r.__tres.attach="fog")),r}function Ie(e){var n;const t=(n=e==null?void 0:e.__tres)==null?void 0:n.root;t&&t.render&&t.render.canBeInvalidated.value&&t.invalidate()}function Fn(e){}function Rt(e,t,n){var s;if(!G(e.setPixelRatio))return;let r=0;if(Z(n)&&n.length>=2){const[a,i]=n;r=_.MathUtils.clamp(t,a,i)}else lt(n)?r=n:r=t;r!==((s=e.getPixelRatio)==null?void 0:s.call(e))&&e.setPixelRatio(r)}function Et(e,t,n,r,s){const a=[...t.__tres.objects],i=Y(t);if(e=Y(e),i===e)return!0;const l=q(e,t.__tres??{},s),c=t.parent??t.__tres.parent??null,o={...t.__tres.memoizedProps};delete o.object;for(const u of a)Re(u,s),Ee(u,s);i.__tres.objects=[],r.remove(t);for(const[u,w]of Object.entries(o))r.patchProp(l,u,l[u],w);n(e),r.insert(t,c);for(const u of a)r.insert(u,t);return!0}function Y(e){return mt(e)?(e.object.__tres=e.__tres,e.object):e}function Re(e,t){var r,s,a,i;const n=((r=e.__tres)==null?void 0:r.parent)||t.scene.value;e.__tres&&(e.__tres.parent=null),n&&n.__tres&&"objects"in n.__tres&&xt(n.__tres.objects,l=>l!==e),(s=e.__tres)!=null&&s.attach?It(n,e,e.__tres.attach):((i=(a=e.parent)==null?void 0:a.remove)==null||i.call(a,Y(e)),e.parent=null)}function Ee(e,t){var n;(n=e.traverse)==null||n.call(e,r=>{var s;t.deregisterCamera(r),(s=t.eventManager)==null||s.deregisterPointerMissedObject(r)}),t.deregisterCamera(e),Ie(e)}const $t=Number.parseInt(_.REVISION.replace("dev","")),se={realistic:{shadows:!0,physicallyCorrectLights:!0,outputColorSpace:_.SRGBColorSpace,toneMapping:_.ACESFilmicToneMapping,toneMappingExposure:3,shadowMap:{enabled:!0,type:_.PCFSoftShadowMap}},flat:{toneMapping:_.NoToneMapping,toneMappingExposure:1}};function $e({canvas:e,options:t,contextParts:{sizes:n,render:r,invalidate:s,advance:a}}){const i=d.computed(()=>({alpha:C.toValue(t.alpha)??!0,depth:C.toValue(t.depth),canvas:C.unrefElement(e),context:C.toValue(t.context),stencil:C.toValue(t.stencil),antialias:C.toValue(t.antialias)??!0,precision:C.toValue(t.precision),powerPreference:C.toValue(t.powerPreference),premultipliedAlpha:C.toValue(t.premultipliedAlpha),preserveDrawingBuffer:C.toValue(t.preserveDrawingBuffer),logarithmicDepthBuffer:C.toValue(t.logarithmicDepthBuffer),failIfMajorPerformanceCaveat:C.toValue(t.failIfMajorPerformanceCaveat)})),l=d.shallowRef(new _.WebGLRenderer(i.value));function c(){t.renderMode==="on-demand"&&s()}d.watch(i,()=>{l.value.dispose(),l.value=new _.WebGLRenderer(i.value),c()}),d.watch([n.width,n.height],()=>{l.value.setSize(n.width.value,n.height.value),c()},{immediate:!0}),d.watch(()=>t.clearColor,c);const{pixelRatio:o}=C.useDevicePixelRatio(),{logError:u}=W(),f=(()=>{const y=new _.WebGLRenderer,S={shadowMap:{enabled:y.shadowMap.enabled,type:y.shadowMap.type},toneMapping:y.toneMapping,toneMappingExposure:y.toneMappingExposure,outputColorSpace:y.outputColorSpace};return y.dispose(),S})(),v=C.toValue(t.renderMode);return v==="on-demand"&&s(),v==="manual"&&setTimeout(()=>{a()},100),d.watchEffect(()=>{const y=C.toValue(t.preset);y&&(y in se||u(`Renderer Preset must be one of these: ${Object.keys(se).join(", ")}`),Le(l.value,se[y])),Rt(l.value,o.value,C.toValue(t.dpr)),v==="always"&&(r.frames.value=Math.max(1,r.frames.value));const S=(L,O)=>{const k=C.toValue(L),j=()=>{if(y)return De(se[y],O)};if(k!==void 0)return k;const A=j();return A!==void 0?A:De(f,O)},h=(L,O)=>kt(l.value,O,S(L,O));h(t.shadows,"shadowMap.enabled"),h(t.toneMapping??_.ACESFilmicToneMapping,"toneMapping"),h(t.shadowMapType,"shadowMap.type"),$t<150&&h(!t.useLegacyLights,"physicallyCorrectLights"),h(t.outputColorSpace,"outputColorSpace"),h(t.toneMappingExposure,"toneMappingExposure");const p=S(t.clearColor,"clearColor");p&&l.value.setClearColor(p?Ae(p):new _.Color(0))}),d.onUnmounted(()=>{l.value.dispose(),l.value.forceContextLoss()}),{renderer:l}}const Ut=e=>!!e&&e.constructor===Array;function Ue(e){const t={nodes:{},materials:{}};return e&&e.traverse(n=>{n.name&&(t.nodes[n.name]=n),n.material&&!t.materials[n.material.name]&&(t.materials[n.material.name]=n.material)}),t}async function Vt(e,t,n,r,s){const{logError:a}=W(),i=new e;s&&s(i),n&&n(i);const c=(Array.isArray(t)?t:[t]).map(o=>new Promise((u,w)=>{i.load(o,f=>{const v=f;v.scene&&Object.assign(v,Ue(v.scene)),u(v)},r,f=>w(a("[useLoader] - Failed to load resource",f)))}));return Ut(t)?await Promise.all(c):await c[0]}async function Ft(e,t){const n=new _.TextureLoader(t),r=s=>new Promise((a,i)=>{n.load(s,l=>a(l),()=>null,()=>{i(new Error("[useTextures] - Failed to load texture"))})});if(Lt(e)){const s=await Promise.all(e.map(a=>r(a)));return e.length>1?s:s[0]}else{const{map:s,displacementMap:a,normalMap:i,roughnessMap:l,metalnessMap:c,aoMap:o,alphaMap:u,matcap:w}=e;return{map:s?await r(s):null,displacementMap:a?await r(a):null,normalMap:i?await r(i):null,roughnessMap:l?await r(l):null,metalnessMap:c?await r(c):null,aoMap:o?await r(o):null,alphaMap:u?await r(u):null,matcap:w?await r(w):null}}}const Ve=(e,t)=>{const n=d.computed(()=>t.renderer.value.domElement),r=d.shallowRef([]),{x:s,y:a}=C.usePointer({target:n});let i=0;const{width:l,height:c,top:o,left:u}=C.useElementBounding(n),w=({x:g,y:D})=>{if(n.value)return{x:(g-u.value)/l.value*2-1,y:-((D-o.value)/c.value)*2+1}},f=({x:g,y:D})=>{if(t.camera.value)return t.raycaster.value.setFromCamera(new _.Vector2(g,D),t.camera.value),r.value=t.raycaster.value.intersectObjects(e.value,!0),r.value},v=g=>{const D=w({x:(g==null?void 0:g.clientX)??s.value,y:(g==null?void 0:g.clientY)??a.value});return D?f(D)||[]:[]},y=C.createEventHook(),S=C.createEventHook(),h=C.createEventHook(),p=C.createEventHook(),L=C.createEventHook(),O=C.createEventHook(),k=C.createEventHook(),j=C.createEventHook();function A(g){const D={};for(const z in g)typeof z!="function"&&(D[z]=g[z]);return D}const M=(g,D)=>{var rt,ot,st;const z=A(D),ue=new _.Vector3(D==null?void 0:D.clientX,D==null?void 0:D.clientY,0).unproject((rt=t.camera)==null?void 0:rt.value);g.trigger({...z,intersections:r.value,unprojectedPoint:ue,ray:(ot=t.raycaster)==null?void 0:ot.value.ray,camera:(st=t.camera)==null?void 0:st.value,sourceEvent:D,delta:i,stopPropagating:!1})};let B;const x=g=>{v(g),M(h,g),B=g},m=()=>{B&&x(B)};let P,T,E;const R=g=>{var D;P=(D=r.value[0])==null?void 0:D.object,i=0,T=new _.Vector2((g==null?void 0:g.clientX)??s.value,(g==null?void 0:g.clientY)??a.value),M(L,g)};let $,I=!1;const ce=g=>{var D,z,ue;g instanceof PointerEvent&&(r.value.length===0&&M(O,g),P===((D=r.value[0])==null?void 0:D.object)&&(E=new _.Vector2((g==null?void 0:g.clientX)??s.value,(g==null?void 0:g.clientY)??a.value),i=T==null?void 0:T.distanceTo(E),g.button===0?(M(y,g),$===((z=r.value[0])==null?void 0:z.object)?I=!0:($=(ue=r.value[0])==null?void 0:ue.object,I=!1)):g.button===2&&M(k,g)),M(p,g))},et=g=>{I&&(M(S,g),$=void 0,I=!1)},tt=g=>M(h,g),nt=g=>M(j,g);return n.value.addEventListener("pointerup",ce),n.value.addEventListener("pointerdown",R),n.value.addEventListener("pointermove",x),n.value.addEventListener("pointerleave",tt),n.value.addEventListener("dblclick",et),n.value.addEventListener("wheel",nt),d.onUnmounted(()=>{n!=null&&n.value&&(n.value.removeEventListener("pointerup",ce),n.value.removeEventListener("pointerdown",R),n.value.removeEventListener("pointermove",x),n.value.removeEventListener("pointerleave",tt),n.value.removeEventListener("dblclick",et),n.value.removeEventListener("wheel",nt))}),{intersects:r,onClick:g=>y.on(g).off,onDblClick:g=>S.on(g).off,onContextMenu:g=>k.on(g).off,onPointerMove:g=>h.on(g).off,onPointerUp:g=>p.on(g).off,onPointerDown:g=>L.on(g).off,onPointerMissed:g=>O.on(g).off,onWheel:g=>j.on(g).off,forceUpdate:m}};function Wt(){const{logWarning:e}=W();function t(a,i,l){let c=null;return a.traverse(o=>{o[i]===l&&(c=o)}),c||e(`Child with ${i} '${l}' not found.`),c}function n(a,i,l){const c=[];return a.traverse(o=>{o[i].includes(l)&&c.push(o)}),c.length||e(`Children with ${i} '${l}' not found.`),c}function r(a,i){return t(a,"name",i)}function s(a,i){return n(a,"name",i)}return{seek:t,seekByName:r,seekAll:n,seekAllByName:s}}function he(e){let t=0;return e.traverse(n=>{if(n.isMesh&&n.geometry&&n.type!=="HightlightMesh"){const r=n.geometry,s=r.attributes.position.count*3*Float32Array.BYTES_PER_ELEMENT,a=r.index?r.index.count*Uint32Array.BYTES_PER_ELEMENT:0,i=r.attributes.normal?r.attributes.normal.count*3*Float32Array.BYTES_PER_ELEMENT:0,l=r.attributes.uv?r.attributes.uv.count*2*Float32Array.BYTES_PER_ELEMENT:0,c=s+a+i+l;t+=c}}),t}function Nt(e){return(e/1024).toFixed(2)}const ie=d.ref({}),ae=e=>Object.assign(ie.value,e);function Fe(e,t,n){var x;const r=d.shallowRef(),s=d.shallowRef();e&&(r.value=e),t&&(s.value=t);const a=m=>{var P;return((P=m.__tres)==null?void 0:P.eventCount)>0},i=m=>{var P;return((P=m.children)==null?void 0:P.some(T=>i(T)))||a(m)},l=d.shallowRef(((x=r.value)==null?void 0:x.children).filter(i)||[]);function c(m,P){if(Array.isArray(m))for(const T of m)T(P);typeof m=="function"&&m(P)}function o(m,P){const T=[],E=()=>P.stopPropagating=!0;P.stopPropagation=E;for(const R of P==null?void 0:P.intersections){if(P.stopPropagating)return;P={...P,...R};const{object:$}=R;P.eventObject=$,c($[m],P),T.push($);let I=$.parent;for(;I!==null&&!P.stopPropagating&&!T.includes(I);)P.eventObject=I,c(I[m],P),T.push(I),I=I.parent;const ce=Pt(m.slice(2));n(ce,{intersection:R,event:P})}}const{onClick:u,onDblClick:w,onContextMenu:f,onPointerMove:v,onPointerDown:y,onPointerUp:S,onPointerMissed:h,onWheel:p,forceUpdate:L}=Ve(l,t);S(m=>o("onPointerUp",m)),y(m=>o("onPointerDown",m)),u(m=>o("onClick",m)),w(m=>o("onDoubleClick",m)),f(m=>o("onContextMenu",m)),p(m=>o("onWheel",m));let O=[];v(m=>{const P=m.intersections.map(({object:E})=>E),T=m.intersections;O.forEach(({object:E})=>{P.includes(E)||(m.intersections=O,o("onPointerLeave",m),o("onPointerOut",m))}),m.intersections=T,m.intersections.forEach(({object:E})=>{O.includes(E)||(o("onPointerEnter",m),o("onPointerOver",m))}),o("onPointerMove",m),O=m.intersections});const k=[];h(m=>{const P=()=>m.stopPropagating=!0;m.stopPropagation=P,k.forEach(T=>{m.stopPropagating||(m.eventObject=T,c(T.onPointerMissed,m))}),n("pointer-missed",{event:m})});function j(m){ee(m)&&F(m)&&l.value.push(m)}function A(m){if(ee(m)&&F(m)){const P=l.value.indexOf(m);P>-1&&l.value.splice(P,1)}}function M(m){ee(m)&&F(m)&&m.onPointerMissed&&k.push(m)}function B(m){if(ee(m)&&F(m)){const P=k.indexOf(m);P>-1&&k.splice(P,1)}}return t.eventManager={forceUpdate:L,registerObject:j,deregisterObject:A,registerPointerMissedObject:M,deregisterPointerMissedObject:B},{forceUpdate:L,registerObject:j,deregisterObject:A,registerPointerMissedObject:M,deregisterPointerMissedObject:B}}function zt(e,t,n=10){const r=C.toValue(e)?C.useWindowSize():C.useElementSize(d.computed(()=>C.toValue(t).parentElement)),s=d.readonly(C.refDebounced(r.width,n)),a=d.readonly(C.refDebounced(r.height,n)),i=d.computed(()=>s.value/a.value);return{height:a,width:s,aspectRatio:i}}function ge(){const e=new Map,t=new Set;let n=0,r=!1;const s=()=>{const o=Array.from(e.entries()).sort((u,w)=>{const f=u[1].priority-w[1].priority;return f===0?u[1].addI-w[1].addI:f});t.clear(),o.forEach(u=>t.add(u[0]))},a=o=>{e.delete(o),t.delete(o)};return{on:(o,u=0)=>{e.set(o,{priority:u,addI:n++});const w=()=>a(o);return C.tryOnScopeDispose(w),r=!0,{off:w}},off:a,trigger:(...o)=>{r&&(s(),r=!1),t.forEach(u=>u(...o))},dispose:()=>{e.clear(),t.clear()},get count(){return e.size}}}function We(){let e=!0,t=!0,n=!1;const r=new _.Clock(!1),s=d.ref(r.running),a=d.ref(!1);let i;const l=_.MathUtils.generateUUID();let c=null;const o=ge(),u=ge(),w=ge();A();let f={};function v(M){f=M}function y(M,B,x=0){switch(B){case"before":return o.on(M,x);case"render":return c||(c=M),u.dispose(),u.on(M);case"after":return w.on(M,x)}}function S(){t&&(t=!1,A(),j())}function h(){t=!0,A(),cancelAnimationFrame(i)}function p(){n=!1,A()}function L(){n=!0,A()}function O(){a.value=!0}function k(){a.value=!1}function j(){if(!e){i=requestAnimationFrame(j);return}const M=r.getDelta(),B=r.getElapsedTime(),x={camera:d.unref(f.camera),scene:d.unref(f.scene),renderer:d.unref(f.renderer),raycaster:d.unref(f.raycaster),controls:d.unref(f.controls),invalidate:f.invalidate,advance:f.advance},m={delta:M,elapsed:B,clock:r,...x};s.value&&o.trigger(m),a.value||(u.count?u.trigger(m):c&&c(m)),s.value&&w.trigger(m),i=requestAnimationFrame(j)}function A(){const M=!t&&!n;r.running!==M&&(r.running?r.stop():r.start()),s.value=r.running}return{loopId:l,register:(M,B,x)=>y(M,B,x),start:S,stop:h,pause:L,resume:p,pauseRender:O,resumeRender:k,isRenderPaused:a,isActive:s,setContext:v,setReady:M=>e=M}}function Gt(e,t,n=100){n=n<=0?100:n;const r=C.createEventHook(),s=new Set;let a=!1,i=!1,l=null;function c(){l&&clearTimeout(l),!i&&!a&&e()?(r.trigger(t),s.forEach(f=>f()),s.clear(),a=!0):!i&&!a&&(l=setTimeout(c,n))}function o(){i=!0,l&&clearTimeout(l)}c();const u=(f,...v)=>{f(...v)};return{on:f=>{if(a)return u(f,t),{off:()=>{}};{const v=r.on(f);return s.add(v.off),r.on(f)}},off:r.off,trigger:r.trigger,cancel:o}}const Q=new WeakMap;function Ne(e){if(e=e||X(),Q.has(e))return Q.get(e);const t=100,n=Date.now(),a=Gt(()=>{if(Date.now()-n>=t)return!0;{const i=e.renderer.value,l=(i==null?void 0:i.domElement)||{width:0,height:0};return!!(i&&l.width>0&&l.height>0)}},e);return Q.set(e,a),a}function qt(e){const t=X();if(t)return Q.has(t)?Q.get(t).on(e):Ne(t).on(e)}function ze({scene:e,canvas:t,windowSize:n,disableRender:r,rendererOptions:s,emit:a}){const i=d.shallowRef(e),l=zt(n,t),{camera:c,cameras:o,registerCamera:u,deregisterCamera:w,setCameraActive:f}=Ce({sizes:l,scene:e}),v={mode:d.ref(s.renderMode||"always"),priority:d.ref(0),frames:d.ref(0),maxFrames:60,canBeInvalidated:d.computed(()=>v.mode.value==="on-demand"&&v.frames.value===0)};function y(R=1){s.renderMode==="on-demand"&&(v.frames.value=Math.min(v.maxFrames,v.frames.value+R))}function S(){s.renderMode==="manual"&&(v.frames.value=1)}const{renderer:h}=$e({scene:e,canvas:t,options:s,emit:a,contextParts:{sizes:l,camera:c,render:v,invalidate:y,advance:S},disableRender:r}),p={sizes:l,scene:i,camera:c,cameras:d.readonly(o),renderer:h,raycaster:d.shallowRef(new _.Raycaster),controls:d.ref(null),perf:{maxFrames:160,fps:{value:0,accumulator:[]},memory:{currentMem:0,allocatedMem:0,accumulator:[]}},render:v,advance:S,extend:ae,invalidate:y,registerCamera:u,setCameraActive:f,deregisterCamera:w,loop:We()};d.provide("useTres",p),p.scene.value.__tres={root:p},p.loop.register(()=>{c.value&&v.frames.value>0&&(h.value.render(e,c.value),a("render",p.renderer.value)),v.priority.value=0,v.mode.value==="always"?v.frames.value=1:v.frames.value=Math.max(0,v.frames.value-1)},"render");const{on:L,cancel:O}=Ne(p);p.loop.setReady(!1),p.loop.start(),L(()=>{a("ready",p),p.loop.setReady(!0),Fe(e,p,a)}),d.onUnmounted(()=>{O(),p.loop.stop()});const k=100,j=C.useFps({every:k}),{isSupported:A,memory:M}=C.useMemory({interval:k}),B=160;let x=performance.now();const m=({timestamp:R})=>{p.scene.value&&(p.perf.memory.allocatedMem=he(p.scene.value)),R-x>=k&&(x=R,p.perf.fps.accumulator.push(j.value),p.perf.fps.accumulator.length>B&&p.perf.fps.accumulator.shift(),p.perf.fps.value=j.value,A.value&&M.value&&(p.perf.memory.accumulator.push(M.value.usedJSHeapSize/1024/1024),p.perf.memory.accumulator.length>B&&p.perf.memory.accumulator.shift(),p.perf.memory.currentMem=p.perf.memory.accumulator.reduce(($,I)=>$+I,0)/p.perf.memory.accumulator.length))};let P=0;const T=1,{pause:E}=C.useRafFn(({delta:R})=>{window.__TRES__DEVTOOLS__&&(m({timestamp:performance.now()}),P+=R,P>=T&&(window.__TRES__DEVTOOLS__.cb(p),P=0))},{immediate:!0});return d.onUnmounted(()=>{E()}),p}function X(){const e=d.inject("useTres");if(!e)throw new Error("useTresContext must be used together with useTresContextProvider");return e}const Yt=X;function Jt(){const{camera:e,scene:t,renderer:n,loop:r,raycaster:s,controls:a,invalidate:i,advance:l}=X();r.setContext({camera:e,scene:t,renderer:n,raycaster:s,controls:a,invalidate:i,advance:l});function c(w,f=0){return r.register(w,"before",f)}function o(w){return r.register(w,"render")}function u(w,f=0){return r.register(w,"after",f)}return{pause:r.pause,resume:r.resume,pauseRender:r.pauseRender,resumeRender:r.resumeRender,isActive:r.isActive,onBeforeRender:c,render:o,onAfterRender:u}}function Kt(e,t={},n={}){let r=e;const s=l=>{r=l};let a=new Proxy({},{});const i={has(l,c){return c in t||c in r},get(l,c,o){return c in t?t[c](r):r[c]},set(l,c,o){return n[c]?n[c](o,r,a,s):r[c]=o,!0}};return a=new Proxy({},i),a}const{logError:Ge}=W(),qe=["onClick","onContextMenu","onPointerMove","onPointerEnter","onPointerLeave","onPointerOver","onPointerOut","onDoubleClick","onPointerDown","onPointerUp","onPointerCancel","onPointerMissed","onLostPointerCapture","onWheel"],Qt=e=>{const t=e.scene.value;function n(o,u,w,f){if(f||(f={}),f.args||(f.args=[]),o==="template"||Ct(o))return null;let v=o.replace("Tres",""),y;if(o==="primitive"){(!U(f.object)||d.isRef(f.object))&&Ge("Tres primitives need an 'object' prop, whose value is an object or shallowRef<object>"),v=f.object.type;const S={};y=Kt(f.object,{object:p=>p,isPrimitive:()=>!0,__tres:()=>S},{object:(p,L,O,k)=>{Et(p,O,k,{patchProp:a,remove:s,insert:r},e)},__tres:p=>{Object.assign(S,p)}})}else{const S=ie.value[v];S||Ge(`${v} is not defined on the THREE namespace. Use extend to add it to the catalog.`),y=new S(...f.args)}return y?(y.isCamera&&(f!=null&&f.position||y.position.set(3,3,3),f!=null&&f.lookAt||y.lookAt(0,0,0)),y=q(y,{...y.__tres,type:v,memoizedProps:f,eventCount:0,primitive:o==="primitive",attach:f.attach},e),y):null}function r(o,u){var v,y,S;if(!o)return;u=u||t;const w=o.__tres?o:q(o,{},e),f=u.__tres?u:q(u,{},e);o=Y(w),u=Y(f),o.__tres&&((v=o.__tres)==null?void 0:v.eventCount)>0&&((y=e.eventManager)==null||y.registerObject(o)),e.registerCamera(o),(S=e.eventManager)==null||S.registerPointerMissedObject(o),w.__tres.attach?Bt(f,w,w.__tres.attach):F(o)&&F(f)&&(f.add(o),o.dispatchEvent({type:"added"})),w.__tres.parent=f,f.__tres.objects&&!f.__tres.objects.includes(w)&&f.__tres.objects.push(w)}function s(o,u){var y,S,h,p;if(!o)return;o!=null&&o.__tres&&((y=o.__tres)==null?void 0:y.eventCount)>0&&((S=e.eventManager)==null||S.deregisterObject(o)),u=fe(u)?"default":u;const w=(h=o.__tres)==null?void 0:h.dispose;fe(w)||(w===null?u=!1:u=w);const f=(p=o.__tres)==null?void 0:p.primitive,v=u==="default"?!f:!!u;if(o.__tres&&"objects"in o.__tres&&[...o.__tres.objects].forEach(L=>s(L,u)),v&&o.children&&[...o.children].forEach(L=>s(L,u)),Re(o,e),Ee(o,e),v&&!pt(o)){if(G(u))u(o);else if(G(o.dispose))try{o.dispose()}catch{}}"__tres"in o&&delete o.__tres}function a(o,u,w,f){var L,O;if(!o)return;let v=o,y=u;if(o.__tres&&(o.__tres.memoizedProps[u]=f),u==="attach"){const k=((L=o.__tres)==null?void 0:L.parent)||o.parent;s(o),q(o,{attach:f},e),k&&r(o,k);return}if(u==="dispose"){o.__tres||(o=q(o,{},e)),o.__tres.dispose=f;return}if(F(o)&&y==="blocks-pointer-events"){f||f===""?o[y]=f:delete o[y];return}qe.includes(u)&&o.__tres&&(o.__tres.eventCount+=1);let S=oe(y),h=v==null?void 0:v[S];if(y==="args"){const k=o,j=w??[],A=f??[],M=((O=o.__tres)==null?void 0:O.type)||o.type;M&&j.length&&!At(j,A)&&(v=Object.assign(k,new ie.value[M](...f)));return}if(v.type==="BufferGeometry"){if(y==="args")return;v.setAttribute(oe(y),new _.BufferAttribute(...f));return}if(y.includes("-")&&h===void 0){const k=y.split("-");h=k.reduce((j,A)=>j[oe(A)],v),y=k.pop(),S=y,h!=null&&h.set||(v=k.reduce((j,A)=>j[oe(A)],v))}let p=f;if(p===""&&(p=!0),G(h)){qe.includes(u)||(Z(p)?o[S](...p):o[S](p)),S.startsWith("on")&&G(p)&&(v[S]=p);return}!(h!=null&&h.set)&&!G(h)?v[S]=p:h.constructor===p.constructor&&(h!=null&&h.copy)?h==null||h.copy(p):Z(p)?h.set(...p):!h.isColor&&h.setScalar?h.setScalar(p):h.set(p),Ie(o)}function i(o){var u;return((u=o==null?void 0:o.__tres)==null?void 0:u.parent)||null}function l(o){return null;const u=q(new _.Object3D,{type:"Comment"},e);return u.name=o,u}function c(o){var v;const u=i(o),w=((v=u==null?void 0:u.__tres)==null?void 0:v.objects)||[],f=w.indexOf(o);return f<0||f>=w.length-1?null:w[f+1]}return{insert:r,remove:s,createElement:n,patchProp:a,parentNode:i,createText:()=>void 0,createComment:l,setText:()=>void 0,setElementText:()=>void 0,nextSibling:c,querySelector:()=>void 0,setScopeId:()=>void 0,cloneNode:()=>void 0,insertStaticContent:()=>void 0}};function Xt(){return Ye().__VUE_DEVTOOLS_GLOBAL_HOOK__}function Ye(){return typeof navigator<"u"&&typeof window<"u"?window:typeof globalThis<"u"?globalThis:{}}const Ht=typeof Proxy=="function",Zt="devtools-plugin:setup",en="plugin:settings:set";let J,ve;function tn(){var e;return J!==void 0||(typeof window<"u"&&window.performance?(J=!0,ve=window.performance):typeof globalThis<"u"&&(!((e=globalThis.perf_hooks)===null||e===void 0)&&e.performance)?(J=!0,ve=globalThis.perf_hooks.performance):J=!1),J}function nn(){return tn()?ve.now():Date.now()}class rn{constructor(t,n){this.target=null,this.targetQueue=[],this.onQueue=[],this.plugin=t,this.hook=n;const r={};if(t.settings)for(const i in t.settings){const l=t.settings[i];r[i]=l.defaultValue}const s=`__vue-devtools-plugin-settings__${t.id}`;let a=Object.assign({},r);try{const i=localStorage.getItem(s),l=JSON.parse(i);Object.assign(a,l)}catch{}this.fallbacks={getSettings(){return a},setSettings(i){try{localStorage.setItem(s,JSON.stringify(i))}catch{}a=i},now(){return nn()}},n&&n.on(en,(i,l)=>{i===this.plugin.id&&this.fallbacks.setSettings(l)}),this.proxiedOn=new Proxy({},{get:(i,l)=>this.target?this.target.on[l]:(...c)=>{this.onQueue.push({method:l,args:c})}}),this.proxiedTarget=new Proxy({},{get:(i,l)=>this.target?this.target[l]:l==="on"?this.proxiedOn:Object.keys(this.fallbacks).includes(l)?(...c)=>(this.targetQueue.push({method:l,args:c,resolve:()=>{}}),this.fallbacks[l](...c)):(...c)=>new Promise(o=>{this.targetQueue.push({method:l,args:c,resolve:o})})})}async setRealTarget(t){this.target=t;for(const n of this.onQueue)this.target.on[n.method](...n.args);for(const n of this.targetQueue)n.resolve(await this.target[n.method](...n.args))}}function on(e,t){const n=e,r=Ye(),s=Xt(),a=Ht&&n.enableEarlyProxy;if(s&&(r.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__||!a))s.emit(Zt,e,t);else{const i=a?new rn(n,s):null;(r.__VUE_DEVTOOLS_PLUGINS__=r.__VUE_DEVTOOLS_PLUGINS__||[]).push({pluginDescriptor:n,setupFn:t,proxy:i}),i&&t(i.proxiedTarget)}}function sn(e,t){const n=`▲ ■ ●${e}`;typeof Je=="function"?Je(n,t):console.log(n)}function Je(e,t){throw new Error(e+t)}const Ke=e=>{const t={id:e.uuid,label:e.type,children:[],tags:[]};e.name!==""&&t.tags.push({label:e.name,textColor:5750629,backgroundColor:15793395});const n=he(e);return n>0&&t.tags.push({label:`${Nt(n)} KB`,textColor:15707189,backgroundColor:16775644,tooltip:"Memory usage"}),e.type.includes("Light")&&(ft(e)&&t.tags.push({label:`${e.intensity}`,textColor:9738662,backgroundColor:16316922,tooltip:"Intensity"}),t.tags.push({label:`#${new _.Color(e.color).getHexString()}`,textColor:9738662,backgroundColor:16316922,tooltip:"Color"})),e.type.includes("Camera")&&(t.tags.push({label:`${e.fov}°`,textColor:9738662,backgroundColor:16316922,tooltip:"Field of view"}),t.tags.push({label:`x: ${Math.round(e.position.x)} y: ${Math.round(e.position.y)} z: ${Math.round(e.position.z)}`,textColor:9738662,backgroundColor:16316922,tooltip:"Position"})),t};function Qe(e,t,n=""){e.children.forEach(r=>{if(r.type==="HightlightMesh"||n&&!r.type.includes(n)&&!r.name.includes(n))return;const s=Ke(r);t.children.push(s),Qe(r,s,n)})}const an=[],H="tres:inspector",ln=d.reactive({sceneGraph:null});function cn(e,t){on({id:"dev.esm.tres",label:"TresJS 🪐",logo:"https://raw.githubusercontent.com/Tresjs/tres/main/public/favicon.svg",packageName:"tresjs",homepage:"https://tresjs.org",componentStateTypes:an,app:e},n=>{typeof n.now!="function"&&sn("You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html."),n.addInspector({id:H,label:"TresJS 🪐",icon:"account_tree",treeFilterPlaceholder:"Search instances"}),setInterval(()=>{n.sendInspectorTree(H)},1e3),setInterval(()=>{n.notifyComponentUpdate()},5e3),n.on.getInspectorTree(a=>{if(a.inspectorId===H){const i=Ke(t.scene.value);Qe(t.scene.value,i,a.filter),ln.sceneGraph=i,a.rootNodes=[i]}});let r=null,s=null;n.on.getInspectorState(a=>{var i;if(a.inspectorId===H){const[l]=t.scene.value.getObjectsByProperty("uuid",a.nodeId);if(!l)return;if(s&&r&&r.parent&&s.remove(r),l.isMesh){const c=Dt(l);l.add(c),r=c,s=l}a.state={object:Object.entries(l).map(([c,o])=>c==="children"?{key:c,value:o.filter(u=>u.type!=="HightlightMesh")}:{key:c,value:o,editable:!0}).filter(({key:c})=>c!=="parent")},l.isScene&&(a.state.info={memory:he(l),objects:l.children.length,calls:t.renderer.value.info.render.calls,triangles:t.renderer.value.info.render.triangles,points:t.renderer.value.info.render.points,lines:t.renderer.value.info.render.lines},a.state.programs=((i=t.renderer.value.info.programs)==null?void 0:i.map(c=>({key:c.name,value:{...c,vertexShader:c.vertexShader,attributes:c.getAttributes(),uniforms:c.getUniforms()}})))||[])}}),n.on.editInspectorState(a=>{a.inspectorId===H&&Ot(t.scene.value,a.nodeId,a.path,a.state.value)})})}const un=["data-scene","data-tres"],Xe=d.defineComponent({__name:"TresCanvas",props:{shadows:{type:Boolean,default:void 0},clearColor:{},toneMapping:{},shadowMapType:{},useLegacyLights:{type:Boolean,default:void 0},outputColorSpace:{},toneMappingExposure:{},renderMode:{default:"always"},dpr:{},camera:{},preset:{},windowSize:{type:Boolean,default:void 0},disableRender:{type:Boolean,default:void 0},context:{},precision:{},alpha:{type:Boolean,default:void 0},premultipliedAlpha:{type:Boolean},antialias:{type:Boolean,default:void 0},stencil:{type:Boolean,default:void 0},preserveDrawingBuffer:{type:Boolean,default:void 0},powerPreference:{},depth:{type:Boolean,default:void 0},logarithmicDepthBuffer:{type:Boolean,default:void 0},failIfMajorPerformanceCaveat:{type:Boolean,default:void 0}},emits:["render","click","double-click","context-menu","pointer-move","pointer-up","pointer-down","pointer-enter","pointer-leave","pointer-over","pointer-out","pointer-missed","wheel","ready"],setup(e,{expose:t,emit:n}){var S;const r=e,s=n,a=d.useSlots(),{logWarning:i}=W(),l=d.ref(),c=d.shallowRef(new _.Scene),o=(S=d.getCurrentInstance())==null?void 0:S.appContext.app;ae(_e);const u=h=>d.defineComponent({setup(){var L;const p=(L=d.getCurrentInstance())==null?void 0:L.appContext;return p&&(p.app=o),d.provide("useTres",h),d.provide("extend",ae),typeof window<"u"&&cn(p==null?void 0:p.app,h),()=>d.h(d.Fragment,null,a!=null&&a.default?a.default():[])}}),w=h=>{const p=u(h),{render:L}=d.createRenderer(Qt(h));L(d.h(p),c.value)},f=(h,p=!1)=>{pe(h.scene.value),p&&(h.renderer.value.dispose(),h.renderer.value.renderLists.dispose(),h.renderer.value.forceContextLoss()),c.value.__tres={root:h},w(h)},v=d.computed(()=>r.disableRender),y=d.shallowRef(null);return t({context:y,dispose:()=>f(y.value,!0)}),d.onMounted(()=>{const h=l;y.value=ze({scene:c.value,canvas:h,windowSize:r.windowSize??!1,disableRender:v.value??!1,rendererOptions:r,emit:s});const{registerCamera:p,camera:L,cameras:O,deregisterCamera:k}=y.value;w(y.value);const j=()=>{const A=new _.PerspectiveCamera(45,window.innerWidth/window.innerHeight,.1,1e3);A.position.set(3,3,3),A.lookAt(0,0,0),p(A);const M=d.watchEffect(()=>{O.value.length>=2&&(A.removeFromParent(),k(A),M==null||M())})};d.watch(()=>r.camera,(A,M)=>{A&&p(A),M&&(M.removeFromParent(),k(M))},{immediate:!0}),L.value||(i("No camera found. Creating a default perspective camera. To have full control over a camera, please add one to the scene."),j())}),d.onUnmounted(()=>{f(y.value)}),(h,p)=>(d.openBlock(),d.createElementBlock("canvas",{ref_key:"canvas",ref:l,"data-scene":c.value.uuid,class:d.normalizeClass(h.$attrs.class),"data-tres":`tresjs ${d.unref(at).version}`,style:d.normalizeStyle({display:"block",width:"100%",height:"100%",position:h.windowSize?"fixed":"relative",top:0,left:0,pointerEvents:"auto",touchAction:"none",...h.$attrs.style})},null,14,un))}}),fn=["TresCanvas","TresLeches","TresScene"],dn={template:{compilerOptions:{isCustomElement:e=>e.startsWith("Tres")&&!fn.includes(e)||e==="primitive"}}},pn={mounted:(e,t)=>{if(t.arg){console.log(`v-log:${t.arg}`,e[t.arg]);return}console.log("v-log",e)}};class He extends _.Line{constructor(t,n){const r=[1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],s=new _.BufferGeometry;s.setAttribute("position",new _.Float32BufferAttribute(r,3)),s.computeBoundingSphere();const a=new _.LineBasicMaterial({fog:!1});super(s,a),this.light=t,this.color=n,this.type="RectAreaLightHelper";const i=[1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],l=new _.BufferGeometry;l.setAttribute("position",new _.Float32BufferAttribute(i,3)),l.computeBoundingSphere(),this.add(new _.Mesh(l,new _.MeshBasicMaterial({side:_.BackSide,fog:!1})))}updateMatrixWorld(){if(this.scale.set(.5*this.light.width,.5*this.light.height,1),this.color!==void 0)this.material.color.set(this.color),this.children[0].material.color.set(this.color);else{this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);const t=this.material.color,n=Math.max(t.r,t.g,t.b);n>1&&t.multiplyScalar(1/n),this.children[0].material.color.copy(this.material.color)}this.matrixWorld.extractRotation(this.light.matrixWorld).scale(this.scale).copyPosition(this.light.matrixWorld),this.children[0].matrixWorld.copy(this.matrixWorld)}dispose(){this.geometry.dispose(),this.material.dispose(),this.children[0].geometry.dispose(),this.children[0].material.dispose()}}const{logWarning:Ze}=W();let le,N;const mn={DirectionalLight:_.DirectionalLightHelper,PointLight:_.PointLightHelper,SpotLight:_.SpotLightHelper,HemisphereLight:_.HemisphereLightHelper,RectAreaLight:He},hn={mounted:e=>{if(!e.isLight){Ze(`${e.type} is not a light`);return}le=mn[e.type],e.parent.add(new le(e,1,e.color.getHex()))},updated:e=>{N=e.parent.children.find(t=>t instanceof le),!(N instanceof He)&&N.update()},unmounted:e=>{if(!e.isLight){Ze(`${e.type} is not a light`);return}N=e.parent.children.find(t=>t instanceof le),N&&N.dispose&&N.dispose(),e.parent.remove(N)}},{logWarning:gn}=W();let V=null;const vn={updated:(e,t)=>{var s;const n=jt(t);if(!n){gn(`v-distance-to: problem with binding value: ${t.value}`);return}V&&(V.dispose(),e.parent.remove(V));const r=n.clone().sub(e.position);r.normalize(),V=new _.ArrowHelper(r,e.position,e.position.distanceTo(n),16776960),e.parent.add(V),console.table([["Distance:",e.position.distanceTo(n)],[`origin: ${e.name||e.type}`,`x:${e.position.x}, y:${e.position.y}, z:${(s=e.position)==null?void 0:s.z}`],[`Destiny: ${e.name||e.type}`,`x:${n.x}, y:${n.y}, z:${n==null?void 0:n.z}`]])},unmounted:e=>{V==null||V.dispose(),e.parent.remove(V)}},yn={install(e){e.component("TresCanvas",Xe)}};b.TresCanvas=Xe,b.catalogue=ie,b.createRenderLoop=We,b.default=yn,b.dispose=pe,b.extend=ae,b.isProd=_t,b.normalizeColor=Ae,b.normalizeVectorFlexibleParam=wt,b.onTresReady=qt,b.templateCompilerOptions=dn,b.trasverseObjects=Ue,b.useCamera=Ce,b.useLoader=Vt,b.useLogger=W,b.useLoop=Jt,b.useRaycaster=Ve,b.useRenderLoop=yt,b.useRenderer=$e,b.useSeek=Wt,b.useTexture=Ft,b.useTres=Yt,b.useTresContext=X,b.useTresContextProvider=ze,b.useTresEventManager=Fe,b.vDistanceTo=vn,b.vLightHelper=hn,b.vLog=pn,Object.defineProperties(b,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
diff --git a/node_modules/@tresjs/core/types.d.ts b/node_modules/@tresjs/core/types.d.ts
index 0dad945..9551693 100644
--- a/node_modules/@tresjs/core/types.d.ts
+++ b/node_modules/@tresjs/core/types.d.ts
@@ -1 +1 @@
-export * from './dist/types/index.js'
+export * from './dist/src/types/index.js'
diff --git a/node_modules/@tresjs/core/utils.d.ts b/node_modules/@tresjs/core/utils.d.ts
index 6dde10d..3143f36 100644
--- a/node_modules/@tresjs/core/utils.d.ts
+++ b/node_modules/@tresjs/core/utils.d.ts
@@ -1 +1 @@
-export * from './dist/utils/index.js'
+export * from './dist/src/utils/index.js'
